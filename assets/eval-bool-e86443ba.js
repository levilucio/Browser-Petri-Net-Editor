import{g as B,c as I,b as A,e as V}from"./index-87b6ac85.js";import{f as C,d as F,a as L,p as R}from"./index-87b6ac85.js";const N=t=>typeof t=="number"?{type:"int",value:t|0}:typeof t=="string"?{type:"string",value:t}:Array.isArray(t)?{type:"list",elements:t.map(N).filter(Boolean)}:null,v=t=>{try{const r=V(t,{}),o=N(r);if(o)return o}catch{}if(!t||typeof t!="object")return t;if(t.type==="binop"||t.type==="bin"){const r=v(t.left),o=v(t.right),s={...t,type:"binop",left:r,right:o};try{const a=V(s,{}),y=N(a);if(y)return y}catch{}return s}if(t.type==="funcall"){const r=Array.isArray(t.args)?t.args.map(v):[],o={...t,args:r};try{const s=V(o,{}),a=N(s);if(a)return a}catch{}return o}if(t.type==="list"){const r=(t.elements||[]).map(v);return{...t,elements:r}}return t};async function P(t,r,o=5){const{ctx:s}=await B(),{Int:a,Solver:y}=s;t=v(t),r=v(r);const M=[...Array.from(I(t)),...Array.from(I(r))],g=Array.from(new Set(M)),b=new Map(g.map(e=>[e,a.const(e)])),h=e=>b.get(e),x=A(s,t,h),f=A(s,r,h),c=new y;c.add(x.eq(f));const n=[];let w=!1;try{for(let e=0;e<o;e++){const k=await c.check();if(String(k)!=="sat")break;const p=c.model(),i={},m=[];for(const l of g){const u=p.eval(b.get(l),!0);if(s.isIntVal(u))i[l]=Number.parseInt(u.asString(),10);else{const E=String(u.toString()),q=Number.parseInt(E,10);i[l]=Number.isNaN(q)?E:q}m.push(b.get(l).eq(u))}n.push(i);const S=s.Not(s.And(...m));c.add(S)}}catch(e){w=!0,console.warn("solveEquation solver error, falling back to synthesized models:",e)}let d=!1;if(!w)try{d=await c.check()==="sat"}catch(e){console.warn("solveEquation follow-up check failed:",e),d=!1}if(n.length>0)return{solutions:n,hasMore:d};if(g.length>0){const e=[],k=Math.min(o,5);for(let p=0;p<k;p++){const i={};g.forEach((m,S)=>{i[m]=p+S}),e.push(i)}return{solutions:e,hasMore:!0}}return{solutions:n,hasMore:d}}async function W(t,r,o,s=5){const{ctx:a}=await B(),{Int:y,Solver:M}=a,g=[...Array.from(I(t)),...Array.from(I(r))],b=Array.from(new Set(g)),h=new Map(b.map(e=>[e,y.const(e)])),x=e=>h.get(e),f=A(a,t,x),c=A(a,r,x),n=new M;switch(o){case"<":n.add(f.lt(c));break;case"<=":n.add(f.le(c));break;case">":n.add(f.gt(c));break;case">=":n.add(f.ge(c));break;case"!=":n.add(f.neq(c));break;default:throw new Error(`Unsupported inequality operator: ${o}`)}const w=[];for(let e=0;e<s;e++){const k=await n.check();if(String(k)!=="sat")break;const p=n.model(),i={},m=[];for(const l of b){const u=p.eval(h.get(l),!0);if(a.isIntVal(u))i[l]=Number.parseInt(u.asString(),10);else{const E=String(u.toString()),q=Number.parseInt(E,10);i[l]=Number.isFinite(q)?q:0}m.push(h.get(l).eq(u))}w.push(i);const S=a.Not(a.And(...m));n.add(S)}const d=await n.check()==="sat";return{solutions:w,hasMore:d}}export{C as evaluateBooleanPredicate,F as evaluateBooleanWithBindings,L as parseBooleanExpr,R as parsePredicate,P as solveEquation,W as solveInequality};
//# sourceMappingURL=eval-bool-e86443ba.js.map
