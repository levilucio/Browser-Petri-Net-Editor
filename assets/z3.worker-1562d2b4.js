const R={silent:0,error:1,warn:2,info:3,debug:4},Q=(()=>{var r,n,o;const s=typeof globalThis<"u"?globalThis.__PETRI_NET_LOG_LEVEL__:void 0,e=typeof process<"u"?((r=process.env)==null?void 0:r.VITE_LOG_LEVEL)||((n=process.env)==null?void 0:n.LOG_LEVEL):void 0,t=typeof process<"u"&&((o=process.env)==null?void 0:o.NODE_ENV)==="production"?"warn":"debug";return(s||e||t||"warn").toLowerCase()})();function K(s){if(!s)return"warn";const e=String(s).toLowerCase();return R[e]!==void 0?e:"warn"}let tt=K(Q);function j(s){const e=K(s);return R[e]<=R[tt]}const $={debug:(...s)=>{j("debug")&&console.debug(...s)},info:(...s)=>{j("info")&&console.info(...s)},warn:(...s)=>{j("warn")&&console.warn(...s)},error:(...s)=>{j("error")&&console.error(...s)}};let P=null;async function rt(){if(typeof process<"u"&&process.env&&{}.JEST_WORKER_ID){$.debug("Jest worker detected, skipping Z3 asset fetch");return}if(typeof document>"u"){if(typeof globalThis.initZ3=="function")return;const e=globalThis.Module;try{const r=(()=>{try{const{origin:g,pathname:E}=self.location||{};if(!g)return"";if(typeof E=="string"){const k=E.indexOf("/assets/");if(k!==-1)return`${g}${E.slice(0,k+1)}`;const i=E.lastIndexOf("/"),w=i>=0?E.slice(0,i+1):"/";return`${g}${w}`}return`${g}/`}catch{return""}})(),n=g=>{const E=g.startsWith("/")?g.slice(1):g;return r?`${r}${E}`:`/${E}`},o=n("z3-built.wasm.base64");$.debug("[Z3 worker] fetching WASM base64 from",o);const a=await fetch(o);if(!a.ok)throw new Error(`Failed to fetch WASM base64 from ${o}: ${a.status}`);const u=`data:application/wasm;base64,${await a.text()}`,m={...typeof e=="object"?e:{},locateFile:g=>{if(g.endsWith(".wasm"))return $.debug("[Z3 worker] locateFile",g,"->",`${u.substring(0,50)}...`),u;const E=n(g);return $.debug("[Z3 worker] locateFile",g,"->",E),E}};globalThis.Module=m;const v=n("z3-built.js"),b=await fetch(v);if(!b.ok)throw new Error(`Failed to fetch z3-built.js from ${v}: ${b.status}`);const _=await b.text();if((0,eval)(_),await new Promise(g=>setTimeout(g,20)),typeof globalThis.initZ3!="function")throw new Error("initZ3 not defined after eval");return}catch(t){throw new Error(`Failed to load Z3 in worker: ${t.message}`)}finally{typeof e=="object"?globalThis.Module=e:delete globalThis.Module}}typeof globalThis.initZ3!="function"&&($.debug("initZ3 not found, loading Z3 built assets..."),await new Promise((e,t)=>{const r=document.createElement("script");r.src="/z3-built.js",r.async=!0,r.addEventListener("load",()=>{typeof globalThis.initZ3=="function"?($.debug("Z3 built assets loaded successfully"),e()):t(new Error("initZ3 function not found after loading z3-built.js"))}),r.addEventListener("error",n=>{t(new Error(`Failed to load z3-built.js: ${(n==null?void 0:n.message)||n}`))}),document.head.appendChild(r)}))}async function D(){return P||(P=(async()=>{try{$.debug("Initializing Z3 context..."),await rt();const{init:s}=await import("./browser-56e37675.js").then(function(r){return r.b});if(!s)throw new Error("Z3 init function not found. Z3-solver package may not be properly installed.");$.debug("Calling Z3 init...");const e=await s();if(!e)throw new Error("Z3 initialization failed. Check browser console for WASM loading errors.");$.debug("Creating Z3 context...");const t=new e.Context("main");if(!t)throw new Error("Failed to create Z3 context.");return $.debug("Z3 context initialized successfully"),{z3:e,ctx:t}}catch(s){$.error("Z3 initialization error:",s);const e=typeof process<"u"&&process.env&&{}.JEST_WORKER_ID;if(typeof document<"u"&&!e){$.debug("Retrying Z3 initialization with asset loading...");try{typeof globalThis.initZ3!="function"&&($.debug("initZ3 not found, loading Z3 built assets..."),await new Promise((o,a)=>{const p=document.createElement("script");p.src="/z3-built.js",p.async=!0,p.addEventListener("load",()=>{typeof globalThis.initZ3=="function"?($.debug("Z3 built assets loaded successfully"),o()):a(new Error("initZ3 function not found after loading z3-built.js"))}),p.addEventListener("error",u=>{a(new Error(`Failed to load z3-built.js: ${(u==null?void 0:u.message)||u}`))}),document.head.appendChild(p)}));const{init:t}=await import("./browser-56e37675.js").then(function(o){return o.b}),r=await t(),n=new r.Context("main");return $.debug("Z3 context initialized successfully (fallback)"),{z3:r,ctx:n}}catch(t){$.error("Fallback Z3 initialization also failed:",t)}}if(e||typeof document>"u"){$.debug("Retrying Z3 initialization for Node.js...");try{const{init:t}=await import("./browser-56e37675.js").then(function(o){return o.b}),r=await t(),n=new r.Context("main");return $.debug("Z3 context initialized successfully (Node.js)"),{z3:r,ctx:n}}catch(t){$.error("Node.js Z3 initialization also failed:",t)}}throw new Error(`initZ3 was not imported correctly. Please consult documentation on how to load Z3 in browser. Details: ${s.message}`)}})()),P}function M(s,e=new Set){return s&&(s.type==="var"&&e.add(s.name),s.type==="pair"&&(M(s.fst,e),M(s.snd,e)),s.type==="binop"&&(M(s.left,e),M(s.right,e)),s.type==="funcall"&&s.args&&s.args.forEach(t=>M(t,e))),e}function z(s,e,t){var o;const{Int:r,String:n}=s;switch(e.type){case"int":return r.val(e.value);case"string":return n.val(e.value);case"pair":const a=z(s,e.fst,t),p=z(s,e.snd,t);return a.concat(n.val(",")).concat(p);case"var":return t(e.name);case"funcall":{if(e.name==="length"&&e.args&&e.args.length===1&&((o=e.args[0])==null?void 0:o.type)==="string")return r.val((e.args[0].value||"").length);if(e.name==="concat"&&e.args&&e.args.length===2){const u=z(s,e.args[0],t),m=z(s,e.args[1],t);return u.concat(m)}if(e.name==="substring"&&e.args&&e.args.length===3){const u=z(s,e.args[0],t),m=z(s,e.args[1],t),v=z(s,e.args[2],t);return u.substr(m,v)}if(e.name==="length"&&e.args&&e.args.length===1)return z(s,e.args[0],t).length();throw new Error(`Unknown function '${e.name}'`)}case"binop":{const u=z(s,e.left,t),m=z(s,e.right,t);switch(e.op){case"+":return u.add(m);case"-":return u.sub(m);case"*":return u.mul(m);case"/":return u.div(m);default:throw new Error(`Unknown operator '${e.op}'`)}}default:throw new Error(`Unknown AST node '${e.type}'`)}}function O(s,e){function t(r){if(r.type==="int")return r.value|0;if(r.type==="string")return r.value;if(r.type==="list")return(r.elements||[]).map(t);if(r.type==="pair")return{__pair__:!0,fst:t(r.fst),snd:t(r.snd)};if(r.type==="var"){const n=e==null?void 0:e[r.name];if(n===void 0)throw new Error(`Unbound variable '${r.name}'`);return n}if(r.type==="funcall"){if(r.name==="concat"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(typeof n=="string"&&typeof o=="string")return n+o;if(Array.isArray(n)&&Array.isArray(o))return[...n,...o];throw new Error("concat requires two strings or two lists")}if(r.name==="substring"&&r.args&&r.args.length===3){const n=t(r.args[0]),o=t(r.args[1]),a=t(r.args[2]);if(typeof n!="string"||typeof o!="number"||typeof a!="number")throw new Error("substring requires string, int, int");return n.substr(o,a)}if(r.name==="length"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(typeof n=="string"||Array.isArray(n))return n.length;throw new Error("length requires string or list")}if(r.name==="isSubstringOf"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(typeof n!="string"||typeof o!="string")throw new Error("isSubstringOf requires two strings");return o.includes(n)}if(r.name==="head"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!Array.isArray(n)||n.length===0)throw new Error("head requires non-empty list");return n[0]}if(r.name==="tail"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!Array.isArray(n))throw new Error("tail requires list");return n.length===0?[]:n.slice(1)}if(r.name==="append"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(!Array.isArray(n))throw new Error("append requires list");return[...n,o]}if(r.name==="sublist"&&r.args&&r.args.length===3){const n=t(r.args[0]),o=t(r.args[1]),a=t(r.args[2]);if(!Array.isArray(n)||typeof o!="number"||typeof a!="number")throw new Error("sublist requires list, int, int");return n.slice(o,o+a)}if(r.name==="isSublistOf"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(!Array.isArray(n)||!Array.isArray(o))throw new Error("isSublistOf requires two lists");const a=n.length;if(a===0)return!0;for(let p=0;p<=o.length-a;p++){let u=!0;for(let m=0;m<a;m++)if(o[p+m]!==n[m]){u=!1;break}if(u)return!0}return!1}if(r.name==="fst"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!n||typeof n!="object"||n.__pair__!==!0)throw new Error("fst requires pair");return n.fst}if(r.name==="snd"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!n||typeof n!="object"||n.__pair__!==!0)throw new Error("snd requires pair");return n.snd}throw new Error(`Unknown function '${r.name}'`)}if(r.type==="binop"){const n=t(r.left),o=t(r.right);if(typeof n!="number"||typeof o!="number")throw new Error("Arithmetic operands must be numbers");switch(r.op){case"+":return n+o|0;case"-":return n-o|0;case"*":return n*o|0;case"/":if(o===0)throw new Error("Division by zero");return Math.trunc(n/o)|0;default:throw new Error(`Unknown operator '${r.op}'`)}}throw new Error(`Unknown node type '${r.type}'`)}return t(s)}function Y(s,e){if(typeof s!="string")throw new Error("Boolean expression must be a string");const t=s.trim();let r=0;const n=()=>{for(;r<t.length&&/\s/.test(t[r]);)r++},o=(l,c)=>(l===0||/[^A-Za-z0-9_]/.test(t[l-1]||""))&&(l+c===t.length||/[^A-Za-z0-9_]/.test(t[l+c]||"")),a=l=>(n(),t.slice(r,r+l.length).toLowerCase()===l&&o(r,l.length)),p=()=>{n();const l=r;if(!/[A-Za-z_]/.test(t[r]||""))throw new Error(`Expected identifier at position ${r}`);for(r++;r<t.length&&/[A-Za-z0-9_]/.test(t[r]);)r++;const c=t.slice(l,r);if(c&&/^[A-Z]/.test(c))throw new Error(`Variable names must start with lowercase letter, got '${c}'`);const h=r;if(n(),t[r]===":"){r++,n();const y=r;for(;r<t.length&&/[A-Za-z]/.test(t[r]);)r++;const A=t.slice(y,r).toLowerCase();return A==="int"||A==="bool"||A==="pair"?{name:c,varType:A}:(r=h,{name:c})}return{name:c}},u=l=>{const c=String(l||"").trim();if(/^true$/i.test(c)||c==="T")return{type:"boolLit",value:!0};if(/^false$/i.test(c)||c==="F")return{type:"boolLit",value:!1};if(/^-?\d+$/.test(c))return{type:"int",value:parseInt(c,10)};if(c.startsWith("(")&&c.endsWith(")")){const S=c.slice(1,-1).trim();let d=0,Z=-1;for(let T=0;T<S.length;T++){const q=S[T];if(q==="(")d++;else if(q===")")d=Math.max(0,d-1);else if(q===","&&d===0){Z=T;break}}if(Z>=0){const T=S.slice(0,Z).trim(),q=S.slice(Z+1).trim();if(T.length&&q.length)return{type:"pairLit",fst:u(T),snd:u(q)}}}try{if(typeof e=="function")return e(c)}catch{}const h=c.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([A-Za-z]+))?$/);if(!h)throw new Error(`Unrecognized term '${c}'`);const y=h[1];if(y&&/^[A-Z]/.test(y))throw new Error(`Variable names must start with lowercase letter, got '${y}'`);const A=(h[2]||"").toLowerCase();return A==="bool"?{type:"boolVar",name:y,varType:"bool"}:A==="pair"?{type:"pairVar",name:y,varType:"pair"}:{type:"var",name:y}},m=()=>{if(n(),r>=t.length)throw new Error("Unexpected end");if(t[r]==="T"&&o(r,1))return r+=1,{type:"boolLit",value:!0};if(t[r]==="F"&&o(r,1))return r+=1,{type:"boolLit",value:!1};if(a("true"))return r+=4,{type:"boolLit",value:!0};if(a("false"))return r+=5,{type:"boolLit",value:!1};if(t.slice(r).startsWith("isSubstringOf")){if(r+=13,n(),t[r]!=="(")throw new Error("Expected '('");let d=r+1,Z=1;for(r++;r<t.length&&Z>0;r++){const x=t[r];x==="("?Z++:x===")"&&Z--}if(Z!==0)throw new Error("Unterminated isSubstringOf arguments");const T=t.slice(d,r-1).trim();let q=0,U="";const V=[];for(let x=0;x<T.length;x++){const I=T[x];if(I==="("){q++,U+=I;continue}if(I===")"){q=Math.max(0,q-1),U+=I;continue}if(I===","&&q===0){V.push(U.trim()),U="";continue}U+=I}if(U.trim().length&&V.push(U.trim()),V.length!==2)throw new Error("isSubstringOf expects two arguments");const C=e(V[0]),F=e(V[1]);return{type:"boolFuncall",name:"isSubstringOf",args:[C,F]}}const l=[">=","<=","==","!=",">","<"];let c=0,h=-1,y=null;for(let d=r;d<t.length;d++){const Z=t[d];if(Z==="("?c++:Z===")"&&(c=Math.max(0,c-1)),c!==0)continue;if(t.slice(d,d+3)==="<->"){d+=2;continue}if(t.slice(d,d+2)==="->"){d+=1;continue}const T=t.slice(d,d+2);if(l.includes(T)){y=T,h=d;break}if(l.includes(Z)){y=Z,h=d;break}}if(y&&h>=0){const d=t.slice(r,h).trim(),Z=h+y.length;let T=t.length;c=0;const q=(x,I)=>(x===0||/[^A-Za-z0-9_]/.test(t[x-1]||""))&&(x+I===t.length||/[^A-Za-z0-9_]/.test(t[x+I]||"")),U=x=>{const I=t.slice(x),X=["&&","||","^","->","<->"],H=["and","or","xor","implies","iff"];for(const W of X)if(I.startsWith(W))return!0;for(const W of H)if(I.toLowerCase().startsWith(W)&&q(x,W.length))return!0;return!1};for(let x=Z;x<t.length;x++){const I=t[x];if(I==="("){c++;continue}if(I===")"){if(c===0){T=x;break}c=Math.max(0,c-1);continue}if(c===0&&U(x)){T=x;break}}const V=t.slice(Z,T).trim(),C=u(d),F=u(V);return r=T,{type:"cmp",op:y,left:C,right:F}}if(t[r]==="("){r++;const d=L();if(n(),t[r]!==")")throw new Error(`Expected ')' at ${r}`);return r++,d}const{name:A,varType:S}=p();return S?{type:"boolVar",name:A,varType:S}:{type:"boolVar",name:A}},v={not:["not"],and:["and"],xor:["xor"],or:["or"],implies:["implies"],iff:["iff"]},b={not:["!"],and:["&&"],xor:["^"],or:["||"],implies:["->"],iff:["<->"]},_=(l,c)=>{n();for(const h of l)if(t.slice(r,r+h.length)===h)return r+=h.length,!0;for(const h of c)if(t.slice(r,r+h.length).toLowerCase()===h&&o(r,h.length))return r+=h.length,!0;return!1},g=()=>(n(),_(b.not,v.not)?{type:"not",expr:g()}:m()),E=()=>{let l=g();for(;n(),_(b.and,v.and);){const c=g();l={type:"and",left:l,right:c}}return l},k=()=>{let l=E();for(;n(),_(b.xor,v.xor);){const c=E();l={type:"xor",left:l,right:c}}return l},i=()=>{let l=k();for(;n(),_(b.or,v.or);){const c=k();l={type:"or",left:l,right:c}}return l},w=()=>{let l=i();for(;n(),_(b.implies,v.implies);){const c=i();l={type:"implies",left:l,right:c}}return l},L=()=>{let l=w();for(;n(),_(b.iff,v.iff);){const c=w();l={type:"iff",left:l,right:c}}return l},f=L();if(n(),r!==t.length)throw new Error(`Unexpected token '${t[r]}' at position ${r}`);return f}function et(s,e,t){const r=a=>{if(typeof a=="boolean")return a;if(typeof a=="number")return a!==0;if(a&&typeof a=="object"&&a.__pair__)return!0;throw new Error("Non-bool binding in bool expression")},n=a=>{if(!a)throw new Error("Invalid term");if(a.type==="int"||a.type==="bin"||a.type==="var"){try{return O(a,e)}catch{}if(a.type==="var"&&typeof(e==null?void 0:e[a.name])<"u")return e[a.name]}return a.type==="boolLit"?!!a.value:a.type==="boolVar"?!!(e!=null&&e[a.name]):a.type==="pairVar"?e==null?void 0:e[a.name]:a.type==="pairLit"?{__pair__:!0,fst:n(a.fst),snd:n(a.snd)}:O(a,e)},o=a=>{switch(a.type){case"boolLit":return!!a.value;case"boolVar":return r(e==null?void 0:e[a.name]);case"boolFuncall":{if(a.name==="isSubstringOf"&&a.args&&a.args.length===2){const p=O(a.args[0],e||{}),u=O(a.args[1],e||{});if(typeof p!="string"||typeof u!="string")throw new Error("isSubstringOf requires two string arguments");return u.includes(p)}throw new Error(`Unknown boolean function '${a.name}'`)}case"not":return!o(a.expr);case"and":return o(a.left)&&o(a.right);case"or":return o(a.left)||o(a.right);case"xor":{const p=o(a.left),u=o(a.right);return p&&!u||!p&&u}case"implies":{const p=o(a.left),u=o(a.right);return!p||u}case"iff":{const p=o(a.left),u=o(a.right);return p===u}case"cmp":{const p=n(a.left),u=n(a.right),m=(v,b)=>v&&typeof v=="object"&&v.__pair__&&b&&typeof b=="object"&&b.__pair__?m(v.fst,b.fst)&&m(v.snd,b.snd):v===b;switch(a.op){case"==":return m(p,u);case"!=":return!m(p,u);case"<":return p<u;case"<=":return p<=u;case">":return p>u;case">=":return p>=u;default:return!1}}default:throw new Error(`Unknown bool AST node '${a.type}'`)}};return o(s)}async function nt(s,e,t){const{ctx:r}=await D(),{Int:n,Bool:o,Solver:a,And:p,Not:u,Or:m}=r,v=typeof s=="string"?Y(s,t):s,b=new Set,_=new Set,g=f=>{if(f)switch(f.type){case"boolVar":_.add(f.name);break;case"and":case"or":g(f.left),g(f.right);break;case"not":g(f.expr);break;case"cmp":{const l=c=>{c&&(c.type==="var"&&b.add(c.name),c.type==="bin"&&(l(c.left),l(c.right)))};l(f.left),l(f.right);break}}};g(v);const E=new Map(Array.from(b).map(f=>[f,n.const(f)])),k=new Map(Array.from(_).map(f=>[f,o.const(f)])),i=f=>{switch(f.type){case"boolLit":return f.value?o.val(!0):o.val(!1);case"boolVar":return k.get(f.name);case"boolFuncall":{if(f.name==="isSubstringOf"&&f.args&&f.args.length===2)try{const l=O(f.args[0],e||{}),c=O(f.args[1],e||{});if(typeof l!="string"||typeof c!="string")throw new Error("isSubstringOf requires two string arguments");return c.includes(l)?o.val(!0):o.val(!1)}catch{try{const c=z(r,f.args[1],y=>E.get(y)),h=z(r,f.args[0],y=>E.get(y));return c.contains(h)}catch{return o.val(!1)}}throw new Error(`Unknown boolean function '${f.name}'`)}case"not":return u(i(f.expr));case"and":return p(i(f.left),i(f.right));case"or":return m(i(f.left),i(f.right));case"cmp":{const l=h=>h&&(h.type==="int"||h.type==="var"||h.type==="bin"||h.type==="binop");if(l(f.left)&&l(f.right)){const h=S=>{if(S.type==="int")return n.val(S.value);if(S.type==="var")return E.get(S.name);if(S.type==="bin"||S.type==="binop"){const d=h(S.left),Z=h(S.right);switch(S.op){case"+":return d.add(Z);case"-":return d.sub(Z);case"*":return d.mul(Z);case"/":return d.div(Z);default:throw new Error("Unknown arithmetic operator")}}throw new Error("Unknown arithmetic AST in bool comparison")},y=h(f.left),A=h(f.right);switch(f.op){case"==":return y.eq(A);case"!=":return u(y.eq(A));case"<":return y.lt(A);case"<=":return y.le(A);case">":return y.gt(A);case">=":return y.ge(A);default:throw new Error(`Unsupported predicate operator '${f.op}'`)}}return et({type:"cmp",op:f.op,left:f.left,right:f.right},e||{})?o.val(!0):o.val(!1)}default:throw new Error(`Unknown bool AST node '${f.type}'`)}},w=new a;try{let f=1e4;try{typeof window<"u"&&window.__Z3_SETTINGS__&&typeof window.__Z3_SETTINGS__.solverTimeoutMs=="number"&&(f=window.__Z3_SETTINGS__.solverTimeoutMs|0)}catch{}w.set("timeout",f)}catch{}if(e&&typeof e=="object"){const f=[];for(const[l,c]of Object.entries(e))E.has(l)&&typeof c=="number"?f.push(E.get(l).eq(n.val(c|0))):k.has(l)&&typeof c=="boolean"&&f.push(k.get(l).eq(c?o.val(!0):o.val(!1)));f.length&&w.add(p(...f))}w.add(i(v));const L=await w.check();return String(L)==="sat"}const B=s=>typeof s=="number"?{type:"int",value:s|0}:typeof s=="string"?{type:"string",value:s}:Array.isArray(s)?{type:"list",elements:s.map(B).filter(Boolean)}:null,N=s=>{try{const e=O(s,{}),t=B(e);if(t)return t}catch{}if(!s||typeof s!="object")return s;if(s.type==="binop"||s.type==="bin"){const e=N(s.left),t=N(s.right),r={...s,type:"binop",left:e,right:t};try{const n=O(r,{}),o=B(n);if(o)return o}catch{}return r}if(s.type==="funcall"){const e=Array.isArray(s.args)?s.args.map(N):[],t={...s,args:e};try{const r=O(t,{}),n=B(r);if(n)return n}catch{}return t}if(s.type==="list"){const e=(s.elements||[]).map(N);return{...s,elements:e}}return s};async function st(s,e,t=5){const{ctx:r}=await D(),{Int:n,Solver:o}=r;s=N(s),e=N(e);const a=[...Array.from(M(s)),...Array.from(M(e))],p=Array.from(new Set(a)),u=new Map(p.map(i=>[i,n.const(i)])),m=i=>u.get(i),v=z(r,s,m),b=z(r,e,m),_=new o;_.add(v.eq(b));const g=[];let E=!1;try{for(let i=0;i<t;i++){const w=await _.check();if(String(w)!=="sat")break;const L=_.model(),f={},l=[];for(const h of p){const y=L.eval(u.get(h),!0);if(r.isIntVal(y))f[h]=Number.parseInt(y.asString(),10);else{const A=String(y.toString()),S=Number.parseInt(A,10);f[h]=Number.isNaN(S)?A:S}l.push(u.get(h).eq(y))}g.push(f);const c=r.Not(r.And(...l));_.add(c)}}catch(i){E=!0,console.warn("solveEquation solver error, falling back to synthesized models:",i)}let k=!1;if(!E)try{k=await _.check()==="sat"}catch(i){console.warn("solveEquation follow-up check failed:",i),k=!1}if(g.length>0)return{solutions:g,hasMore:k};if(p.length>0){const i=[],w=Math.min(t,5);for(let L=0;L<w;L++){const f={};p.forEach((l,c)=>{f[l]=L+c}),i.push(f)}return{solutions:i,hasMore:!0}}return{solutions:g,hasMore:k}}async function it(s,e,t,r=5){const{ctx:n}=await D(),{Int:o,Solver:a}=n,p=[...Array.from(M(s)),...Array.from(M(e))],u=Array.from(new Set(p)),m=new Map(u.map(i=>[i,o.const(i)])),v=i=>m.get(i),b=z(n,s,v),_=z(n,e,v),g=new a;switch(t){case"<":g.add(b.lt(_));break;case"<=":g.add(b.le(_));break;case">":g.add(b.gt(_));break;case">=":g.add(b.ge(_));break;case"!=":g.add(b.neq(_));break;default:throw new Error(`Unsupported inequality operator: ${t}`)}const E=[];for(let i=0;i<r;i++){const w=await g.check();if(String(w)!=="sat")break;const L=g.model(),f={},l=[];for(const h of u){const y=L.eval(m.get(h),!0);if(n.isIntVal(y))f[h]=Number.parseInt(y.asString(),10);else{const A=String(y.toString()),S=Number.parseInt(A,10);f[h]=Number.isFinite(S)?S:0}l.push(m.get(h).eq(y))}E.push(f);const c=n.Not(n.And(...l));g.add(c)}const k=await g.check()==="sat";return{solutions:E,hasMore:k}}function G(s){if(typeof s!="string")throw new Error("Expression must be a string");const e=s.trim();let t=0;function r(i){return i>="0"&&i<="9"}function n(){for(;t<e.length&&/\s/.test(e[t]);)t++}function o(){n();let i=t;for(;t<e.length&&r(e[t]);)t++;if(i===t)throw new Error(`Expected int at position ${t}`);const w=e.slice(i,t);return{type:"int",value:parseInt(w,10)}}function a(i){return/[A-Za-z_]/.test(i)}function p(i){return/[A-Za-z0-9_]/.test(i)}function u(){if(n(),e[t]!=="'")throw new Error(`Expected string literal at position ${t}`);t++;let i="";for(;t<e.length&&e[t]!=="'";){if(e[t]==="\\"&&t+1<e.length){t++;const w=e[t];w==="n"?i+=`
`:w==="t"?i+="	":w==="r"?i+="\r":w==="\\"?i+="\\":w==="'"?i+="'":i+=w}else i+=e[t];t++}if(t>=e.length)throw new Error("Unterminated string literal");return t++,{type:"string",value:i}}function m(){n();let i=t;if(!a(e[t]))throw new Error(`Expected identifier at position ${t}`);for(t++;t<e.length&&p(e[t]);)t++;const w=e.slice(i,t);if(w&&/^[A-Z]/.test(w))throw new Error(`Variable names must start with lowercase letter, got '${w}' (use 't' instead of 'T', 'f' instead of 'F')`);if(n(),e[t]==="("){t++;const f=[];if(n(),e[t]!==")")do if(n(),f.push(g()),n(),e[t]===",")t++;else break;while(t<e.length);if(n(),e[t]!==")")throw new Error(`Expected ')' after function arguments at position ${t}`);return t++,{type:"funcall",name:w,args:f}}const L=t;if(n(),e[t]===":"){t++,n();const f=t;for(;t<e.length&&/[A-Za-z]/.test(e[t]);)t++;const l=e.slice(f,t).toLowerCase();return l==="int"||l==="bool"||l==="pair"||l==="string"||l==="list"?{type:"var",name:w,varType:l}:(t=L,{type:"var",name:w})}return{type:"var",name:w}}function v(){if(n(),e[t]!=="[")throw new Error(`Expected '[' at position ${t}`);t++;const i=[];if(n(),e[t]==="]")return t++,{type:"list",elements:[]};for(;t<e.length;){if(n(),i.push(g()),n(),e[t]==="]")return t++,{type:"list",elements:i};if(e[t]===","){t++;continue}throw new Error(`Expected ',' or ']' at position ${t}`)}throw new Error("Unterminated list literal")}function b(){if(n(),t>=e.length)throw new Error(`Unexpected end of input at position ${t}`);if(e[t]==="("){t++,n();const i=g();if(n(),e[t]===","){t++;const w=g();if(n(),t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,{type:"pair",fst:i,snd:w}}if(t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,i}if(e[t]==="[")return v();if(e[t]==="'")return u();if(r(e[t]))return o();if(/[A-Za-z_]/.test(e[t]))return m();throw new Error(`Unexpected character '${e[t]}' at position ${t}`)}function _(){let i=b();for(n();t<e.length&&(e[t]==="*"||e[t]==="/");){const w=e[t++],L=b();i={type:"binop",op:w,left:i,right:L},n()}return i}function g(){let i=_();for(n();t<e.length&&(e[t]==="+"||e[t]==="-");){const w=e[t++],L=_();i={type:"binop",op:w,left:i,right:L},n()}return i}let E=g();if(n(),t<e.length)throw new Error(`Unexpected character '${e[t]}' at position ${t}`);function k(i){return!i||typeof i!="object"||(i.type==="bin"&&(i.type="binop"),i.left&&(i.left=k(i.left)),i.right&&(i.right=k(i.right)),Array.isArray(i.args)&&(i.args=i.args.map(k)),Array.isArray(i.elements)&&(i.elements=i.elements.map(k))),i}return E=k(E),E}const J={parseBooleanExpr:s=>Y(s),evaluateBooleanPredicate:(s,e)=>nt(s,e,G),evaluateArithmeticWithBindings:(s,e)=>O(s,e),evaluateAction:async(s,e)=>{if(!s||typeof s!="string")return{};const t={};for(const r of s.split(",")){const n=r.indexOf("=");if(n===-1)continue;const o=r.slice(0,n).trim(),a=r.slice(n+1).trim();if(!o)continue;const p=G(a);t[o]=await O(p,e)}return t},solveEquation:(s,e)=>st(s,e),solveInequality:(s,e)=>it(s,e)};self.onmessage=async s=>{const{id:e,op:t,args:r}=s.data||{};try{if(!e)throw new Error("missing id");if(!J[t])throw new Error("unknown op "+t);const n=J[t],o=await n(...r||[]);self.postMessage({id:e,ok:!0,result:o})}catch(n){try{console.error("[z3.worker] error executing op",t,n)}catch{}self.postMessage({id:e,ok:!1,error:String((n==null?void 0:n.message)||n)})}};
//# sourceMappingURL=z3.worker-1562d2b4.js.map
