const P={silent:0,error:1,warn:2,info:3,debug:4},Q=(()=>{var r,n,o;const s=typeof globalThis<"u"?globalThis.__PETRI_NET_LOG_LEVEL__:void 0,e=typeof process<"u"?((r=process.env)==null?void 0:r.VITE_LOG_LEVEL)||((n=process.env)==null?void 0:n.LOG_LEVEL):void 0,t=typeof process<"u"&&((o=process.env)==null?void 0:o.NODE_ENV)==="production"?"warn":"debug";return(s||e||t||"warn").toLowerCase()})();function K(s){if(!s)return"warn";const e=String(s).toLowerCase();return P[e]!==void 0?e:"warn"}let tt=K(Q);function j(s){const e=K(s);return P[e]<=P[tt]}const $={debug:(...s)=>{j("debug")&&console.debug(...s)},info:(...s)=>{j("info")&&console.info(...s)},warn:(...s)=>{j("warn")&&console.warn(...s)},error:(...s)=>{j("error")&&console.error(...s)}};let R=null;async function rt(){if(typeof process<"u"&&process.env&&{}.JEST_WORKER_ID){$.debug("Jest worker detected, skipping Z3 asset fetch");return}if(typeof document>"u"){if(typeof globalThis.initZ3=="function")return;const e=globalThis.Module;try{const t=await fetch("/z3-built.wasm.base64");if(!t.ok)throw new Error(`Failed to fetch WASM base64: ${t.status}`);const n=`data:application/wasm;base64,${await t.text()}`,o={...typeof e=="object"?e:{},locateFile:u=>{if(u.endsWith(".wasm"))return $.debug("[Z3 worker] locateFile",u,"->",`${n.substring(0,50)}...`),n;const y=`/${u}`;return $.debug("[Z3 worker] locateFile",u,"->",y),y}};globalThis.Module=o;const a=await fetch("/z3-built.js");if(!a.ok)throw new Error(`Failed to fetch z3-built.js: ${a.status}`);const p=await a.text();if((0,eval)(p),await new Promise(u=>setTimeout(u,20)),typeof globalThis.initZ3!="function")throw new Error("initZ3 not defined after eval");return}catch(t){throw new Error(`Failed to load Z3 in worker: ${t.message}`)}finally{typeof e=="object"?globalThis.Module=e:delete globalThis.Module}}typeof globalThis.initZ3!="function"&&($.debug("initZ3 not found, loading Z3 built assets..."),await new Promise((e,t)=>{const r=document.createElement("script");r.src="/z3-built.js",r.async=!0,r.addEventListener("load",()=>{typeof globalThis.initZ3=="function"?($.debug("Z3 built assets loaded successfully"),e()):t(new Error("initZ3 function not found after loading z3-built.js"))}),r.addEventListener("error",n=>{t(new Error(`Failed to load z3-built.js: ${(n==null?void 0:n.message)||n}`))}),document.head.appendChild(r)}))}async function D(){return R||(R=(async()=>{try{$.debug("Initializing Z3 context..."),await rt();const{init:s}=await import("./browser-56e37675.js").then(function(r){return r.b});if(!s)throw new Error("Z3 init function not found. Z3-solver package may not be properly installed.");$.debug("Calling Z3 init...");const e=await s();if(!e)throw new Error("Z3 initialization failed. Check browser console for WASM loading errors.");$.debug("Creating Z3 context...");const t=new e.Context("main");if(!t)throw new Error("Failed to create Z3 context.");return $.debug("Z3 context initialized successfully"),{z3:e,ctx:t}}catch(s){$.error("Z3 initialization error:",s);const e=typeof process<"u"&&process.env&&{}.JEST_WORKER_ID;if(typeof document<"u"&&!e){$.debug("Retrying Z3 initialization with asset loading...");try{typeof globalThis.initZ3!="function"&&($.debug("initZ3 not found, loading Z3 built assets..."),await new Promise((o,a)=>{const p=document.createElement("script");p.src="/z3-built.js",p.async=!0,p.addEventListener("load",()=>{typeof globalThis.initZ3=="function"?($.debug("Z3 built assets loaded successfully"),o()):a(new Error("initZ3 function not found after loading z3-built.js"))}),p.addEventListener("error",u=>{a(new Error(`Failed to load z3-built.js: ${(u==null?void 0:u.message)||u}`))}),document.head.appendChild(p)}));const{init:t}=await import("./browser-56e37675.js").then(function(o){return o.b}),r=await t(),n=new r.Context("main");return $.debug("Z3 context initialized successfully (fallback)"),{z3:r,ctx:n}}catch(t){$.error("Fallback Z3 initialization also failed:",t)}}if(e||typeof document>"u"){$.debug("Retrying Z3 initialization for Node.js...");try{const{init:t}=await import("./browser-56e37675.js").then(function(o){return o.b}),r=await t(),n=new r.Context("main");return $.debug("Z3 context initialized successfully (Node.js)"),{z3:r,ctx:n}}catch(t){$.error("Node.js Z3 initialization also failed:",t)}}throw new Error(`initZ3 was not imported correctly. Please consult documentation on how to load Z3 in browser. Details: ${s.message}`)}})()),R}function M(s,e=new Set){return s&&(s.type==="var"&&e.add(s.name),s.type==="pair"&&(M(s.fst,e),M(s.snd,e)),s.type==="binop"&&(M(s.left,e),M(s.right,e)),s.type==="funcall"&&s.args&&s.args.forEach(t=>M(t,e))),e}function z(s,e,t){var o;const{Int:r,String:n}=s;switch(e.type){case"int":return r.val(e.value);case"string":return n.val(e.value);case"pair":const a=z(s,e.fst,t),p=z(s,e.snd,t);return a.concat(n.val(",")).concat(p);case"var":return t(e.name);case"funcall":{if(e.name==="length"&&e.args&&e.args.length===1&&((o=e.args[0])==null?void 0:o.type)==="string")return r.val((e.args[0].value||"").length);if(e.name==="concat"&&e.args&&e.args.length===2){const u=z(s,e.args[0],t),y=z(s,e.args[1],t);return u.concat(y)}if(e.name==="substring"&&e.args&&e.args.length===3){const u=z(s,e.args[0],t),y=z(s,e.args[1],t),v=z(s,e.args[2],t);return u.substr(y,v)}if(e.name==="length"&&e.args&&e.args.length===1)return z(s,e.args[0],t).length();throw new Error(`Unknown function '${e.name}'`)}case"binop":{const u=z(s,e.left,t),y=z(s,e.right,t);switch(e.op){case"+":return u.add(y);case"-":return u.sub(y);case"*":return u.mul(y);case"/":return u.div(y);default:throw new Error(`Unknown operator '${e.op}'`)}}default:throw new Error(`Unknown AST node '${e.type}'`)}}function O(s,e){function t(r){if(r.type==="int")return r.value|0;if(r.type==="string")return r.value;if(r.type==="list")return(r.elements||[]).map(t);if(r.type==="pair")return{__pair__:!0,fst:t(r.fst),snd:t(r.snd)};if(r.type==="var"){const n=e==null?void 0:e[r.name];if(n===void 0)throw new Error(`Unbound variable '${r.name}'`);return n}if(r.type==="funcall"){if(r.name==="concat"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(typeof n=="string"&&typeof o=="string")return n+o;if(Array.isArray(n)&&Array.isArray(o))return[...n,...o];throw new Error("concat requires two strings or two lists")}if(r.name==="substring"&&r.args&&r.args.length===3){const n=t(r.args[0]),o=t(r.args[1]),a=t(r.args[2]);if(typeof n!="string"||typeof o!="number"||typeof a!="number")throw new Error("substring requires string, int, int");return n.substr(o,a)}if(r.name==="length"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(typeof n=="string"||Array.isArray(n))return n.length;throw new Error("length requires string or list")}if(r.name==="isSubstringOf"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(typeof n!="string"||typeof o!="string")throw new Error("isSubstringOf requires two strings");return o.includes(n)}if(r.name==="head"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!Array.isArray(n)||n.length===0)throw new Error("head requires non-empty list");return n[0]}if(r.name==="tail"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!Array.isArray(n))throw new Error("tail requires list");return n.length===0?[]:n.slice(1)}if(r.name==="append"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(!Array.isArray(n))throw new Error("append requires list");return[...n,o]}if(r.name==="sublist"&&r.args&&r.args.length===3){const n=t(r.args[0]),o=t(r.args[1]),a=t(r.args[2]);if(!Array.isArray(n)||typeof o!="number"||typeof a!="number")throw new Error("sublist requires list, int, int");return n.slice(o,o+a)}if(r.name==="isSublistOf"&&r.args&&r.args.length===2){const n=t(r.args[0]),o=t(r.args[1]);if(!Array.isArray(n)||!Array.isArray(o))throw new Error("isSublistOf requires two lists");const a=n.length;if(a===0)return!0;for(let p=0;p<=o.length-a;p++){let u=!0;for(let y=0;y<a;y++)if(o[p+y]!==n[y]){u=!1;break}if(u)return!0}return!1}if(r.name==="fst"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!n||typeof n!="object"||n.__pair__!==!0)throw new Error("fst requires pair");return n.fst}if(r.name==="snd"&&r.args&&r.args.length===1){const n=t(r.args[0]);if(!n||typeof n!="object"||n.__pair__!==!0)throw new Error("snd requires pair");return n.snd}throw new Error(`Unknown function '${r.name}'`)}if(r.type==="binop"){const n=t(r.left),o=t(r.right);if(typeof n!="number"||typeof o!="number")throw new Error("Arithmetic operands must be numbers");switch(r.op){case"+":return n+o|0;case"-":return n-o|0;case"*":return n*o|0;case"/":if(o===0)throw new Error("Division by zero");return Math.trunc(n/o)|0;default:throw new Error(`Unknown operator '${r.op}'`)}}throw new Error(`Unknown node type '${r.type}'`)}return t(s)}function Y(s,e){if(typeof s!="string")throw new Error("Boolean expression must be a string");const t=s.trim();let r=0;const n=()=>{for(;r<t.length&&/\s/.test(t[r]);)r++},o=(l,c)=>(l===0||/[^A-Za-z0-9_]/.test(t[l-1]||""))&&(l+c===t.length||/[^A-Za-z0-9_]/.test(t[l+c]||"")),a=l=>(n(),t.slice(r,r+l.length).toLowerCase()===l&&o(r,l.length)),p=()=>{n();const l=r;if(!/[A-Za-z_]/.test(t[r]||""))throw new Error(`Expected identifier at position ${r}`);for(r++;r<t.length&&/[A-Za-z0-9_]/.test(t[r]);)r++;const c=t.slice(l,r);if(c&&/^[A-Z]/.test(c))throw new Error(`Variable names must start with lowercase letter, got '${c}'`);const g=r;if(n(),t[r]===":"){r++,n();const w=r;for(;r<t.length&&/[A-Za-z]/.test(t[r]);)r++;const S=t.slice(w,r).toLowerCase();return S==="int"||S==="bool"||S==="pair"?{name:c,varType:S}:(r=g,{name:c})}return{name:c}},u=l=>{const c=String(l||"").trim();if(/^true$/i.test(c)||c==="T")return{type:"boolLit",value:!0};if(/^false$/i.test(c)||c==="F")return{type:"boolLit",value:!1};if(/^-?\d+$/.test(c))return{type:"int",value:parseInt(c,10)};if(c.startsWith("(")&&c.endsWith(")")){const _=c.slice(1,-1).trim();let b=0,k=-1;for(let T=0;T<_.length;T++){const q=_[T];if(q==="(")b++;else if(q===")")b=Math.max(0,b-1);else if(q===","&&b===0){k=T;break}}if(k>=0){const T=_.slice(0,k).trim(),q=_.slice(k+1).trim();if(T.length&&q.length)return{type:"pairLit",fst:u(T),snd:u(q)}}}try{if(typeof e=="function")return e(c)}catch{}const g=c.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([A-Za-z]+))?$/);if(!g)throw new Error(`Unrecognized term '${c}'`);const w=g[1];if(w&&/^[A-Z]/.test(w))throw new Error(`Variable names must start with lowercase letter, got '${w}'`);const S=(g[2]||"").toLowerCase();return S==="bool"?{type:"boolVar",name:w,varType:"bool"}:S==="pair"?{type:"pairVar",name:w,varType:"pair"}:{type:"var",name:w}},y=()=>{if(n(),r>=t.length)throw new Error("Unexpected end");if(t[r]==="T"&&o(r,1))return r+=1,{type:"boolLit",value:!0};if(t[r]==="F"&&o(r,1))return r+=1,{type:"boolLit",value:!1};if(a("true"))return r+=4,{type:"boolLit",value:!0};if(a("false"))return r+=5,{type:"boolLit",value:!1};if(t.slice(r).startsWith("isSubstringOf")){if(r+=13,n(),t[r]!=="(")throw new Error("Expected '('");let b=r+1,k=1;for(r++;r<t.length&&k>0;r++){const A=t[r];A==="("?k++:A===")"&&k--}if(k!==0)throw new Error("Unterminated isSubstringOf arguments");const T=t.slice(b,r-1).trim();let q=0,V="";const N=[];for(let A=0;A<T.length;A++){const I=T[A];if(I==="("){q++,V+=I;continue}if(I===")"){q=Math.max(0,q-1),V+=I;continue}if(I===","&&q===0){N.push(V.trim()),V="";continue}V+=I}if(V.trim().length&&N.push(V.trim()),N.length!==2)throw new Error("isSubstringOf expects two arguments");const C=e(N[0]),F=e(N[1]);return{type:"boolFuncall",name:"isSubstringOf",args:[C,F]}}const l=[">=","<=","==","!=",">","<"];let c=0,g=-1,w=null;for(let b=r;b<t.length;b++){const k=t[b];if(k==="("?c++:k===")"&&(c=Math.max(0,c-1)),c!==0)continue;if(t.slice(b,b+3)==="<->"){b+=2;continue}if(t.slice(b,b+2)==="->"){b+=1;continue}const T=t.slice(b,b+2);if(l.includes(T)){w=T,g=b;break}if(l.includes(k)){w=k,g=b;break}}if(w&&g>=0){const b=t.slice(r,g).trim(),k=g+w.length;let T=t.length;c=0;const q=(A,I)=>(A===0||/[^A-Za-z0-9_]/.test(t[A-1]||""))&&(A+I===t.length||/[^A-Za-z0-9_]/.test(t[A+I]||"")),V=A=>{const I=t.slice(A),X=["&&","||","^","->","<->"],H=["and","or","xor","implies","iff"];for(const W of X)if(I.startsWith(W))return!0;for(const W of H)if(I.toLowerCase().startsWith(W)&&q(A,W.length))return!0;return!1};for(let A=k;A<t.length;A++){const I=t[A];if(I==="("){c++;continue}if(I===")"){if(c===0){T=A;break}c=Math.max(0,c-1);continue}if(c===0&&V(A)){T=A;break}}const N=t.slice(k,T).trim(),C=u(b),F=u(N);return r=T,{type:"cmp",op:w,left:C,right:F}}if(t[r]==="("){r++;const b=L();if(n(),t[r]!==")")throw new Error(`Expected ')' at ${r}`);return r++,b}const{name:S,varType:_}=p();return _?{type:"boolVar",name:S,varType:_}:{type:"boolVar",name:S}},v={not:["not"],and:["and"],xor:["xor"],or:["or"],implies:["implies"],iff:["iff"]},E={not:["!"],and:["&&"],xor:["^"],or:["||"],implies:["->"],iff:["<->"]},d=(l,c)=>{n();for(const g of l)if(t.slice(r,r+g.length)===g)return r+=g.length,!0;for(const g of c)if(t.slice(r,r+g.length).toLowerCase()===g&&o(r,g.length))return r+=g.length,!0;return!1},m=()=>(n(),d(E.not,v.not)?{type:"not",expr:m()}:y()),x=()=>{let l=m();for(;n(),d(E.and,v.and);){const c=m();l={type:"and",left:l,right:c}}return l},Z=()=>{let l=x();for(;n(),d(E.xor,v.xor);){const c=x();l={type:"xor",left:l,right:c}}return l},i=()=>{let l=Z();for(;n(),d(E.or,v.or);){const c=Z();l={type:"or",left:l,right:c}}return l},h=()=>{let l=i();for(;n(),d(E.implies,v.implies);){const c=i();l={type:"implies",left:l,right:c}}return l},L=()=>{let l=h();for(;n(),d(E.iff,v.iff);){const c=h();l={type:"iff",left:l,right:c}}return l},f=L();if(n(),r!==t.length)throw new Error(`Unexpected token '${t[r]}' at position ${r}`);return f}function et(s,e,t){const r=a=>{if(typeof a=="boolean")return a;if(typeof a=="number")return a!==0;if(a&&typeof a=="object"&&a.__pair__)return!0;throw new Error("Non-bool binding in bool expression")},n=a=>{if(!a)throw new Error("Invalid term");if(a.type==="int"||a.type==="bin"||a.type==="var"){try{return O(a,e)}catch{}if(a.type==="var"&&typeof(e==null?void 0:e[a.name])<"u")return e[a.name]}return a.type==="boolLit"?!!a.value:a.type==="boolVar"?!!(e!=null&&e[a.name]):a.type==="pairVar"?e==null?void 0:e[a.name]:a.type==="pairLit"?{__pair__:!0,fst:n(a.fst),snd:n(a.snd)}:O(a,e)},o=a=>{switch(a.type){case"boolLit":return!!a.value;case"boolVar":return r(e==null?void 0:e[a.name]);case"boolFuncall":{if(a.name==="isSubstringOf"&&a.args&&a.args.length===2){const p=O(a.args[0],e||{}),u=O(a.args[1],e||{});if(typeof p!="string"||typeof u!="string")throw new Error("isSubstringOf requires two string arguments");return u.includes(p)}throw new Error(`Unknown boolean function '${a.name}'`)}case"not":return!o(a.expr);case"and":return o(a.left)&&o(a.right);case"or":return o(a.left)||o(a.right);case"xor":{const p=o(a.left),u=o(a.right);return p&&!u||!p&&u}case"implies":{const p=o(a.left),u=o(a.right);return!p||u}case"iff":{const p=o(a.left),u=o(a.right);return p===u}case"cmp":{const p=n(a.left),u=n(a.right),y=(v,E)=>v&&typeof v=="object"&&v.__pair__&&E&&typeof E=="object"&&E.__pair__?y(v.fst,E.fst)&&y(v.snd,E.snd):v===E;switch(a.op){case"==":return y(p,u);case"!=":return!y(p,u);case"<":return p<u;case"<=":return p<=u;case">":return p>u;case">=":return p>=u;default:return!1}}default:throw new Error(`Unknown bool AST node '${a.type}'`)}};return o(s)}async function nt(s,e,t){const{ctx:r}=await D(),{Int:n,Bool:o,Solver:a,And:p,Not:u,Or:y}=r,v=typeof s=="string"?Y(s,t):s,E=new Set,d=new Set,m=f=>{if(f)switch(f.type){case"boolVar":d.add(f.name);break;case"and":case"or":m(f.left),m(f.right);break;case"not":m(f.expr);break;case"cmp":{const l=c=>{c&&(c.type==="var"&&E.add(c.name),c.type==="bin"&&(l(c.left),l(c.right)))};l(f.left),l(f.right);break}}};m(v);const x=new Map(Array.from(E).map(f=>[f,n.const(f)])),Z=new Map(Array.from(d).map(f=>[f,o.const(f)])),i=f=>{switch(f.type){case"boolLit":return f.value?o.val(!0):o.val(!1);case"boolVar":return Z.get(f.name);case"boolFuncall":{if(f.name==="isSubstringOf"&&f.args&&f.args.length===2)try{const l=O(f.args[0],e||{}),c=O(f.args[1],e||{});if(typeof l!="string"||typeof c!="string")throw new Error("isSubstringOf requires two string arguments");return c.includes(l)?o.val(!0):o.val(!1)}catch{try{const c=z(r,f.args[1],w=>x.get(w)),g=z(r,f.args[0],w=>x.get(w));return c.contains(g)}catch{return o.val(!1)}}throw new Error(`Unknown boolean function '${f.name}'`)}case"not":return u(i(f.expr));case"and":return p(i(f.left),i(f.right));case"or":return y(i(f.left),i(f.right));case"cmp":{const l=g=>g&&(g.type==="int"||g.type==="var"||g.type==="bin"||g.type==="binop");if(l(f.left)&&l(f.right)){const g=_=>{if(_.type==="int")return n.val(_.value);if(_.type==="var")return x.get(_.name);if(_.type==="bin"||_.type==="binop"){const b=g(_.left),k=g(_.right);switch(_.op){case"+":return b.add(k);case"-":return b.sub(k);case"*":return b.mul(k);case"/":return b.div(k);default:throw new Error("Unknown arithmetic operator")}}throw new Error("Unknown arithmetic AST in bool comparison")},w=g(f.left),S=g(f.right);switch(f.op){case"==":return w.eq(S);case"!=":return u(w.eq(S));case"<":return w.lt(S);case"<=":return w.le(S);case">":return w.gt(S);case">=":return w.ge(S);default:throw new Error(`Unsupported predicate operator '${f.op}'`)}}return et({type:"cmp",op:f.op,left:f.left,right:f.right},e||{})?o.val(!0):o.val(!1)}default:throw new Error(`Unknown bool AST node '${f.type}'`)}},h=new a;try{let f=1e4;try{typeof window<"u"&&window.__Z3_SETTINGS__&&typeof window.__Z3_SETTINGS__.solverTimeoutMs=="number"&&(f=window.__Z3_SETTINGS__.solverTimeoutMs|0)}catch{}h.set("timeout",f)}catch{}if(e&&typeof e=="object"){const f=[];for(const[l,c]of Object.entries(e))x.has(l)&&typeof c=="number"?f.push(x.get(l).eq(n.val(c|0))):Z.has(l)&&typeof c=="boolean"&&f.push(Z.get(l).eq(c?o.val(!0):o.val(!1)));f.length&&h.add(p(...f))}h.add(i(v));const L=await h.check();return String(L)==="sat"}const B=s=>typeof s=="number"?{type:"int",value:s|0}:typeof s=="string"?{type:"string",value:s}:Array.isArray(s)?{type:"list",elements:s.map(B).filter(Boolean)}:null,U=s=>{try{const e=O(s,{}),t=B(e);if(t)return t}catch{}if(!s||typeof s!="object")return s;if(s.type==="binop"||s.type==="bin"){const e=U(s.left),t=U(s.right),r={...s,type:"binop",left:e,right:t};try{const n=O(r,{}),o=B(n);if(o)return o}catch{}return r}if(s.type==="funcall"){const e=Array.isArray(s.args)?s.args.map(U):[],t={...s,args:e};try{const r=O(t,{}),n=B(r);if(n)return n}catch{}return t}if(s.type==="list"){const e=(s.elements||[]).map(U);return{...s,elements:e}}return s};async function st(s,e,t=5){const{ctx:r}=await D(),{Int:n,Solver:o}=r;s=U(s),e=U(e);const a=[...Array.from(M(s)),...Array.from(M(e))],p=Array.from(new Set(a)),u=new Map(p.map(i=>[i,n.const(i)])),y=i=>u.get(i),v=z(r,s,y),E=z(r,e,y),d=new o;d.add(v.eq(E));const m=[];let x=!1;try{for(let i=0;i<t;i++){const h=await d.check();if(String(h)!=="sat")break;const L=d.model(),f={},l=[];for(const g of p){const w=L.eval(u.get(g),!0);if(r.isIntVal(w))f[g]=Number.parseInt(w.asString(),10);else{const S=String(w.toString()),_=Number.parseInt(S,10);f[g]=Number.isNaN(_)?S:_}l.push(u.get(g).eq(w))}m.push(f);const c=r.Not(r.And(...l));d.add(c)}}catch(i){x=!0,console.warn("solveEquation solver error, falling back to synthesized models:",i)}let Z=!1;if(!x)try{Z=await d.check()==="sat"}catch(i){console.warn("solveEquation follow-up check failed:",i),Z=!1}if(m.length>0)return{solutions:m,hasMore:Z};if(p.length>0){const i=[],h=Math.min(t,5);for(let L=0;L<h;L++){const f={};p.forEach((l,c)=>{f[l]=L+c}),i.push(f)}return{solutions:i,hasMore:!0}}return{solutions:m,hasMore:Z}}async function it(s,e,t,r=5){const{ctx:n}=await D(),{Int:o,Solver:a}=n,p=[...Array.from(M(s)),...Array.from(M(e))],u=Array.from(new Set(p)),y=new Map(u.map(i=>[i,o.const(i)])),v=i=>y.get(i),E=z(n,s,v),d=z(n,e,v),m=new a;switch(t){case"<":m.add(E.lt(d));break;case"<=":m.add(E.le(d));break;case">":m.add(E.gt(d));break;case">=":m.add(E.ge(d));break;case"!=":m.add(E.neq(d));break;default:throw new Error(`Unsupported inequality operator: ${t}`)}const x=[];for(let i=0;i<r;i++){const h=await m.check();if(String(h)!=="sat")break;const L=m.model(),f={},l=[];for(const g of u){const w=L.eval(y.get(g),!0);if(n.isIntVal(w))f[g]=Number.parseInt(w.asString(),10);else{const S=String(w.toString()),_=Number.parseInt(S,10);f[g]=Number.isFinite(_)?_:0}l.push(y.get(g).eq(w))}x.push(f);const c=n.Not(n.And(...l));m.add(c)}const Z=await m.check()==="sat";return{solutions:x,hasMore:Z}}function G(s){if(typeof s!="string")throw new Error("Expression must be a string");const e=s.trim();let t=0;function r(i){return i>="0"&&i<="9"}function n(){for(;t<e.length&&/\s/.test(e[t]);)t++}function o(){n();let i=t;for(;t<e.length&&r(e[t]);)t++;if(i===t)throw new Error(`Expected int at position ${t}`);const h=e.slice(i,t);return{type:"int",value:parseInt(h,10)}}function a(i){return/[A-Za-z_]/.test(i)}function p(i){return/[A-Za-z0-9_]/.test(i)}function u(){if(n(),e[t]!=="'")throw new Error(`Expected string literal at position ${t}`);t++;let i="";for(;t<e.length&&e[t]!=="'";){if(e[t]==="\\"&&t+1<e.length){t++;const h=e[t];h==="n"?i+=`
`:h==="t"?i+="	":h==="r"?i+="\r":h==="\\"?i+="\\":h==="'"?i+="'":i+=h}else i+=e[t];t++}if(t>=e.length)throw new Error("Unterminated string literal");return t++,{type:"string",value:i}}function y(){n();let i=t;if(!a(e[t]))throw new Error(`Expected identifier at position ${t}`);for(t++;t<e.length&&p(e[t]);)t++;const h=e.slice(i,t);if(h&&/^[A-Z]/.test(h))throw new Error(`Variable names must start with lowercase letter, got '${h}' (use 't' instead of 'T', 'f' instead of 'F')`);if(n(),e[t]==="("){t++;const f=[];if(n(),e[t]!==")")do if(n(),f.push(m()),n(),e[t]===",")t++;else break;while(t<e.length);if(n(),e[t]!==")")throw new Error(`Expected ')' after function arguments at position ${t}`);return t++,{type:"funcall",name:h,args:f}}const L=t;if(n(),e[t]===":"){t++,n();const f=t;for(;t<e.length&&/[A-Za-z]/.test(e[t]);)t++;const l=e.slice(f,t).toLowerCase();return l==="int"||l==="bool"||l==="pair"||l==="string"||l==="list"?{type:"var",name:h,varType:l}:(t=L,{type:"var",name:h})}return{type:"var",name:h}}function v(){if(n(),e[t]!=="[")throw new Error(`Expected '[' at position ${t}`);t++;const i=[];if(n(),e[t]==="]")return t++,{type:"list",elements:[]};for(;t<e.length;){if(n(),i.push(m()),n(),e[t]==="]")return t++,{type:"list",elements:i};if(e[t]===","){t++;continue}throw new Error(`Expected ',' or ']' at position ${t}`)}throw new Error("Unterminated list literal")}function E(){if(n(),t>=e.length)throw new Error(`Unexpected end of input at position ${t}`);if(e[t]==="("){t++,n();const i=m();if(n(),e[t]===","){t++;const h=m();if(n(),t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,{type:"pair",fst:i,snd:h}}if(t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,i}if(e[t]==="[")return v();if(e[t]==="'")return u();if(r(e[t]))return o();if(/[A-Za-z_]/.test(e[t]))return y();throw new Error(`Unexpected character '${e[t]}' at position ${t}`)}function d(){let i=E();for(n();t<e.length&&(e[t]==="*"||e[t]==="/");){const h=e[t++],L=E();i={type:"binop",op:h,left:i,right:L},n()}return i}function m(){let i=d();for(n();t<e.length&&(e[t]==="+"||e[t]==="-");){const h=e[t++],L=d();i={type:"binop",op:h,left:i,right:L},n()}return i}let x=m();if(n(),t<e.length)throw new Error(`Unexpected character '${e[t]}' at position ${t}`);function Z(i){return!i||typeof i!="object"||(i.type==="bin"&&(i.type="binop"),i.left&&(i.left=Z(i.left)),i.right&&(i.right=Z(i.right)),Array.isArray(i.args)&&(i.args=i.args.map(Z)),Array.isArray(i.elements)&&(i.elements=i.elements.map(Z))),i}return x=Z(x),x}const J={parseBooleanExpr:s=>Y(s),evaluateBooleanPredicate:(s,e)=>nt(s,e,G),evaluateArithmeticWithBindings:(s,e)=>O(s,e),evaluateAction:async(s,e)=>{if(!s||typeof s!="string")return{};const t={};for(const r of s.split(",")){const n=r.indexOf("=");if(n===-1)continue;const o=r.slice(0,n).trim(),a=r.slice(n+1).trim();if(!o)continue;const p=G(a);t[o]=await O(p,e)}return t},solveEquation:(s,e)=>st(s,e),solveInequality:(s,e)=>it(s,e)};self.onmessage=async s=>{const{id:e,op:t,args:r}=s.data||{};try{if(!e)throw new Error("missing id");if(!J[t])throw new Error("unknown op "+t);const n=J[t],o=await n(...r||[]);self.postMessage({id:e,ok:!0,result:o})}catch(n){self.postMessage({id:e,ok:!1,error:String((n==null?void 0:n.message)||n)})}};
//# sourceMappingURL=z3.worker-a27510d9.js.map
