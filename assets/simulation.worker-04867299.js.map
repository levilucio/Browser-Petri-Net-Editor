{"version":3,"file":"simulation.worker-04867299.js","sources":["../src/features/simulation/SimulationEventBus.js","../src/features/simulation/BaseSimulator.js","../src/features/simulation/token-io.js","../src/config/logging.js","../src/utils/logger.js","../src/features/simulation/pt-simulator.js","../src/utils/parse/arithmetic-impl.js","../src/utils/parse/pattern-impl.js","../src/utils/token-utils.js","../src/utils/ast-eval.js","../src/features/simulation/type-check.js","../src/features/simulation/ops/registry.js","../src/features/simulation/cache.js","../src/features/simulation/assignment.js","../src/features/simulation/guard-utils.js","../src/features/simulation/state-normalizer.js","../src/utils/z3/context.js","../src/utils/z3/builders.js","../src/utils/z3/eval-arith.js","../src/utils/z3/booleanParser.js","../src/utils/z3/booleanEvaluator.js","../src/utils/z3/booleanPredicateSolver.js","../src/utils/z3-arith.js","../src/utils/z3-remote.js","../src/features/simulation/algebraic/algebraicHelpers.js","../src/features/simulation/algebraic-simulator.js","../src/features/simulation/SimulatorFactory.js","../src/features/simulation/core/headlessRunner.js","../src/features/simulation/core/netModeDetection.js","../src/features/simulation/simulator-core.js","../src/workers/simulation.worker.js"],"sourcesContent":["/**\n * Simple event bus for simulation communication\n */\nexport class SimulationEventBus {\n  constructor() {\n    this.listeners = new Map();\n  }\n\n  /**\n   * Add an event listener\n   * @param {string} event - Event name\n   * @param {Function} callback - Callback function\n   */\n  on(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event).push(callback);\n  }\n\n  /**\n   * Remove an event listener\n   * @param {string} event - Event name\n   * @param {Function} callback - Callback function\n   */\n  off(event, callback) {\n    if (!this.listeners.has(event)) return;\n    \n    const callbacks = this.listeners.get(event);\n    const index = callbacks.indexOf(callback);\n    if (index > -1) {\n      callbacks.splice(index, 1);\n    }\n  }\n\n  /**\n   * Emit an event\n   * @param {string} event - Event name\n   * @param {*} data - Event data\n   */\n  emit(event, data) {\n    if (!this.listeners.has(event)) return;\n    \n    const callbacks = this.listeners.get(event);\n    for (const callback of callbacks) {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in event listener for ${event}:`, error);\n      }\n    }\n  }\n  /**\n   * Remove all listeners for an event\n   * @param {string} event - Event name\n   */\n  removeAllListeners(event) {\n    if (event) {\n      this.listeners.delete(event);\n    } else {\n      this.listeners.clear();\n    }\n  }\n\n  /**\n   * Get listener count for an event\n   * @param {string} event - Event name\n   * @returns {number} Listener count\n   */\n  listenerCount(event) {\n    return this.listeners.has(event) ? this.listeners.get(event).length : 0;\n  }\n}\n\nexport const SimulationEvents = {\n  transitionsChanged: 'transitionsChanged',\n  transitionFired: 'transitionFired',\n};\n\n// Export singleton instance\nexport const simulationEventBus = new SimulationEventBus();\nexport default simulationEventBus;\n","/**\n * Base class for all Petri net simulators\n * Provides a common interface and shared functionality\n */\nimport { SimulationEvents } from './SimulationEventBus.js';\n\nexport class BaseSimulator {\n  constructor() {\n    this.isInitialized = false;\n    this.petriNet = null;\n    this.eventBus = null;\n    this.simulationMode = 'single'; // 'single' or 'maximal'\n  }\n\n  /**\n   * Initialize the simulator with a Petri net\n   * @param {Object} petriNet - The Petri net structure\n   * @param {Object} options - Configuration options\n   */\n  async initialize(petriNet, options = {}) {\n    if (!this.validatePetriNet(petriNet)) {\n      throw new Error('Invalid Petri net structure');\n    }\n    \n    this.petriNet = this.normalizeNet(petriNet);\n    this.isInitialized = true;\n    this.simulationMode = options.simulationMode || 'single';\n    \n    // Initialize simulator-specific logic\n    await this.initializeSpecific(this.petriNet, options);\n  }\n\n  /**\n   * Simulator-specific initialization\n   * Override in subclasses\n   */\n  async initializeSpecific(petriNet, options) {\n    // Override in subclasses\n  }\n\n  /**\n   * Update the Petri net structure\n   * @param {Object} petriNet - Updated Petri net structure\n   */\n  async update(petriNet) {\n    if (!this.isInitialized) {\n      throw new Error('Simulator not initialized');\n    }\n    \n    if (!this.validatePetriNet(petriNet)) {\n      throw new Error('Invalid Petri net structure');\n    }\n    \n    this.petriNet = this.normalizeNet(petriNet);\n    await this.updateSpecific(this.petriNet);\n  }\n\n  /**\n   * Simulator-specific update logic\n   * Override in subclasses\n   */\n  async updateSpecific(petriNet) {\n    // Override in subclasses\n  }\n\n  /**\n   * Get enabled transitions\n   * @returns {Array} Array of enabled transition IDs\n   */\n  async getEnabledTransitions() {\n    if (!this.isInitialized) {\n      return [];\n    }\n    return await this.getEnabledTransitionsSpecific();\n  }\n\n  /**\n   * Simulator-specific enabled transitions logic\n   * Override in subclasses\n   */\n  async getEnabledTransitionsSpecific() {\n    return [];\n  }\n\n  /**\n   * Fire a specific transition\n   * @param {string} transitionId - ID of the transition to fire\n   * @returns {Object} Updated Petri net structure\n   */\n  async fireTransition(transitionId, options = {}) {\n    if (!this.isInitialized) {\n      throw new Error('Simulator not initialized');\n    }\n\n    // Skip expensive enabled checks if firing in batch mode (caller guarantees transitions are enabled)\n    const skipEnabledCheck = options.skipEnabledCheck || false;\n    if (!skipEnabledCheck) {\n      const enabled = await this.getEnabledTransitions();\n      if (!enabled.includes(transitionId)) {\n        throw new Error(`Transition ${transitionId} is not enabled`);\n      }\n    }\n\n    return await this.fireTransitionSpecific(transitionId, options);\n  }\n\n  /**\n   * Simulator-specific transition firing logic\n   * Override in subclasses\n   */\n  async fireTransitionSpecific(transitionId) {\n    // Override in subclasses\n    return this.petriNet;\n  }\n\n  /**\n   * Execute one simulation step\n   * @returns {Object} Updated Petri net structure\n   */\n  async stepSimulation() {\n    if (!this.isInitialized) {\n      throw new Error('Simulator not initialized');\n    }\n    \n    return await this.stepSimulationSpecific();\n  }\n\n  /**\n   * Simulator-specific step simulation logic\n   * Override in subclasses\n   */\n  async stepSimulationSpecific() {\n    // Override in subclasses\n    return this.petriNet;\n  }\n\n  /**\n   * Reset the simulator\n   */\n  reset() {\n    this.isInitialized = false;\n    this.petriNet = null;\n    this.simulationMode = 'single';\n    this.resetSpecific();\n  }\n\n  /**\n   * Simulator-specific reset logic\n   * Override in subclasses\n   */\n  resetSpecific() {\n    // Override in subclasses\n  }\n\n  /**\n   * Set the event bus for communication\n   * @param {Object} eventBus - Event bus instance\n   */\n  setEventBus(eventBus) {\n    this.eventBus = eventBus;\n  }\n\n  /**\n   * Emit transitionsChanged in a consistent shape via the shared event bus\n   * @param {{enabled: string[], previouslyEnabled?: string[], hasEnabled?: boolean}} payload\n   */\n  emitTransitionsChanged(payload = {}) {\n    if (!this.eventBus) return;\n    const enabled = Array.isArray(payload.enabled) ? payload.enabled : [];\n    const previouslyEnabled = Array.isArray(payload.previouslyEnabled) ? payload.previouslyEnabled : [];\n    const hasEnabled = typeof payload.hasEnabled === 'boolean' ? payload.hasEnabled : enabled.length > 0;\n    this.eventBus.emit(SimulationEvents.transitionsChanged, { enabled, previouslyEnabled, hasEnabled });\n  }\n\n  /**\n   * Emit transitionFired in a consistent shape via the shared event bus\n   * @param {{transitionId: string, newPetriNet?: object}} payload\n   */\n  emitTransitionFired(payload = {}) {\n    if (!this.eventBus) return;\n    const { transitionId, newPetriNet } = payload || {};\n    if (!transitionId) return;\n    this.eventBus.emit(SimulationEvents.transitionFired, { transitionId, newPetriNet });\n  }\n\n  /**\n   * Get simulator type\n   * @returns {string} Simulator type identifier\n   */\n  getType() {\n    throw new Error('getType() must be implemented by subclasses');\n  }\n\n  /**\n   * Validate Petri net structure\n   * @param {Object} petriNet - Petri net to validate\n   * @returns {boolean} True if valid\n   */\n  validatePetriNet(petriNet) {\n    if (!petriNet || typeof petriNet !== 'object') {\n      return false;\n    }\n    \n    const { places, transitions, arcs } = petriNet;\n    \n    if (!Array.isArray(places) || !Array.isArray(transitions) || !Array.isArray(arcs)) {\n      return false;\n    }\n    \n    // Basic validation - can be extended by subclasses\n    return true;\n  }\n\n  /**\n   * Normalize Petri net structure for internal use.\n   * - Ensure arcs have sourceId/targetId and bindings array\n   * - Ensure weights and tokens defaults\n   * - Keep legacy fields (source/target, binding) for compatibility\n   * @param {Object} petriNet\n   * @returns {Object} normalized net (deep-cloned)\n   */\n  normalizeNet(petriNet) {\n    const net = JSON.parse(JSON.stringify(petriNet || { places: [], transitions: [], arcs: [] }));\n\n    const places = Array.isArray(net.places) ? net.places : [];\n    const transitions = Array.isArray(net.transitions) ? net.transitions : [];\n    const arcs = Array.isArray(net.arcs) ? net.arcs : [];\n\n    const placeIdSet = new Set(places.map((p) => String(p.id)));\n    const transitionIdSet = new Set(transitions.map((t) => String(t.id)));\n\n    // Normalize places\n    for (const place of places) {\n      place.id = String(place.id);\n      // Ensure tokens reflect valueTokens if present; otherwise default to 0\n      if (Array.isArray(place.valueTokens)) {\n        const count = place.valueTokens.length;\n        if (!Number.isFinite(place.tokens) || place.tokens !== count) {\n          place.tokens = count;\n        }\n      } else if (!Number.isFinite(place.tokens)) {\n        place.tokens = 0;\n      }\n      // Ensure label/name fallbacks\n      if (!place.label && place.name) place.label = place.name;\n      if (!place.name && place.label) place.name = place.label;\n    }\n\n    // Normalize arcs\n    for (const arc of arcs) {\n      if (arc.id !== undefined) arc.id = String(arc.id);\n      const src = arc.sourceId || arc.source;\n      const tgt = arc.targetId || arc.target;\n      arc.sourceId = String(src);\n      arc.targetId = String(tgt);\n      // Keep legacy fields populated for compatibility\n      if (arc.source === undefined) arc.source = arc.sourceId;\n      if (arc.target === undefined) arc.target = arc.targetId;\n\n      // Weight default\n      const w = Number(arc.weight);\n      arc.weight = Number.isFinite(w) && w > 0 ? w : 1;\n\n      // Bindings array\n      if (Array.isArray(arc.bindings)) {\n        // no-op\n      } else if (arc.binding) {\n        arc.bindings = [String(arc.binding)];\n      } else {\n        arc.bindings = [];\n      }\n\n      // Infer types if missing\n      if (!arc.sourceType) {\n        arc.sourceType = placeIdSet.has(arc.sourceId) ? 'place' : (transitionIdSet.has(arc.sourceId) ? 'transition' : arc.sourceType);\n      }\n      if (!arc.targetType) {\n        arc.targetType = placeIdSet.has(arc.targetId) ? 'place' : (transitionIdSet.has(arc.targetId) ? 'transition' : arc.targetType);\n      }\n    }\n\n    net.places = places;\n    net.transitions = transitions;\n    net.arcs = arcs;\n    return net;\n  }\n\n  /**\n   * Check if simulator is ready\n   * @returns {boolean} True if ready\n   */\n  isReady() {\n    return this.isInitialized && this.petriNet !== null;\n  }\n\n  /**\n   * Get simulation statistics\n   * @returns {Object} Simulation statistics\n   */\n  getSimulationStats() {\n    if (!this.isInitialized) {\n      return { enabledTransitions: [], totalTokens: 0, totalPlaces: 0, totalTransitions: 0 };\n    }\n    \n    const { places, transitions } = this.petriNet;\n    const totalTokens = places.reduce((sum, place) => sum + (place.tokens || 0), 0);\n    \n    return {\n      enabledTransitions: [],\n      totalTokens,\n      totalPlaces: places.length,\n      totalTransitions: transitions.length\n    };\n  }\n}\n","// Token consumption/production helpers used by AlgebraicSimulator\n\nexport function consumeTokens(picks, placesById) {\n  const picksByPlace = new Map();\n  for (const p of picks) {\n    if (!p.srcId) continue;\n    if (!picksByPlace.has(p.srcId)) picksByPlace.set(p.srcId, []);\n    picksByPlace.get(p.srcId).push(p);\n  }\n  for (const [srcId, arr] of picksByPlace.entries()) {\n    const place = placesById[srcId];\n    if (!place) continue;\n    const fallbackCount = arr.filter(p => p.countFallback).length;\n    if (fallbackCount > 0) {\n      const current = Number(place.tokens || 0);\n      place.tokens = Math.max(0, current - fallbackCount);\n    }\n    const indexed = arr.filter(p => !p.countFallback);\n    if (Array.isArray(place.valueTokens) && indexed.length > 0) {\n      // Sort by descending index so earlier removals do not shift later ones\n      indexed.sort((a, b) => b.tokenIndex - a.tokenIndex);\n      for (const p of indexed) {\n        if (p.tokenIndex >= 0 && p.tokenIndex < place.valueTokens.length) {\n          place.valueTokens.splice(p.tokenIndex, 1);\n        }\n      }\n      place.tokens = place.valueTokens.length;\n    }\n  }\n}\n\nexport function produceTokens(outputArcs, bindingAstsByArc, env, placesById, evaluators) {\n  const { evaluateArithmeticWithBindings, evaluateBooleanWithBindings, evaluatePatternLiteral, parseArithmetic } = evaluators;\n  for (const arc of outputArcs) {\n    const tgtId = arc.targetId;\n    const place = placesById[tgtId];\n    if (!place) continue;\n    const bindingAsts = bindingAstsByArc.get(arc.id) || [];\n    if (bindingAsts.length > 0) {\n      if (!Array.isArray(place.valueTokens)) place.valueTokens = [];\n      for (const astObj of bindingAsts) {\n        try {\n          let v;\n          const { kind, ast } = astObj;\n          if (ast && (ast.type === 'var' || ast.type === 'boolVar' || ast.type === 'pairVar')) {\n            v = (env || {})[ast.name];\n          } else if (kind === 'arith') {\n            v = evaluateArithmeticWithBindings(ast, env);\n          } else if (kind === 'bool') {\n            v = evaluateBooleanWithBindings(ast, env, parseArithmetic);\n          } else if (kind === 'pattern') {\n            v = evaluatePatternLiteral(ast, env || {});\n          } else if (kind === 'pair') {\n            if (ast.type === 'pairLit') {\n              v = evaluatePatternLiteral(ast, env || {});\n            }\n          }\n          if (!Array.isArray(place.valueTokens)) place.valueTokens = [];\n          if (typeof v === 'number') {\n            place.valueTokens.push(v | 0);\n          }\n          else if (typeof v === 'boolean') {\n            place.valueTokens.push(v);\n          }\n          else if (typeof v === 'string') {\n            place.valueTokens.push(v);\n          }\n          else if (isPair(v)) {\n            place.valueTokens.push(v);\n          }\n          else if (Array.isArray(v)) {\n            // If it's from arith evaluation (list token), push as-is\n            // If it's from tuple destructuring, spread it\n            if (kind === 'arith' || kind === 'pair' || (ast && (ast.type === 'list' || ast.type === 'listPattern' || ast.type === 'tuplePattern'))) {\n              place.valueTokens.push(v); // Push list as single token\n            } else {\n              place.valueTokens.push(...v); // Spread tuple elements\n            }\n          }\n        } catch (e) {\n          // Skip invalid bindings\n        }\n      }\n    } else if (arc.weight && (arc.weight | 0) > 0) {\n      const n = arc.weight | 0;\n      for (let i = 0; i < n; i++) {\n        const vals = Object.values(env || {});\n        if (Array.isArray(place.valueTokens)) {\n          const first = vals[0];\n          place.valueTokens.push(typeof first === 'boolean' ? !!first : (Number.isFinite(first) ? (first | 0) : 1));\n        } else {\n          place.tokens = (Number(place.tokens || 0) + 1) | 0;\n        }\n      }\n    } else {\n      if (Array.isArray(place.valueTokens)) {\n        place.valueTokens.push(1);\n      } else {\n        place.tokens = (Number(place.tokens || 0) + 1) | 0;\n      }\n    }\n    if (Array.isArray(place.valueTokens)) {\n      place.tokens = place.valueTokens.length;\n    }\n  }\n}\n\nfunction isPair(v) {\n  return !!(v && typeof v === 'object' && v.__pair__ === true && 'fst' in v && 'snd' in v);\n}\n\n\n","const LEVEL_ORDER = {\n  silent: 0,\n  error: 1,\n  warn: 2,\n  info: 3,\n  debug: 4,\n};\n\nconst DEFAULT_ENV_LEVEL = (() => {\n  const globalLevel = typeof globalThis !== 'undefined' ? globalThis.__PETRI_NET_LOG_LEVEL__ : undefined;\n  const nodeLevel = typeof process !== 'undefined'\n    ? (process.env?.VITE_LOG_LEVEL || process.env?.LOG_LEVEL)\n    : undefined;\n  const fallback = (typeof process !== 'undefined' && process.env?.NODE_ENV === 'production') ? 'warn' : 'debug';\n  return (globalLevel || nodeLevel || fallback || 'warn').toLowerCase();\n})();\n\nfunction resolveLevel(level) {\n  if (!level) return 'warn';\n  const key = String(level).toLowerCase();\n  return LEVEL_ORDER[key] !== undefined ? key : 'warn';\n}\n\nlet currentLevel = resolveLevel(DEFAULT_ENV_LEVEL);\n\nexport const DEFAULT_LOG_LEVEL = currentLevel;\n\nexport function setLogLevel(level) {\n  currentLevel = resolveLevel(level);\n}\n\nexport function getLogLevel() {\n  return currentLevel;\n}\n\nexport function shouldLog(level) {\n  const resolved = resolveLevel(level);\n  return LEVEL_ORDER[resolved] <= LEVEL_ORDER[currentLevel];\n}\n\nexport const loggingLevels = Object.freeze({ ...LEVEL_ORDER });\n\n","import { DEFAULT_LOG_LEVEL, getLogLevel, setLogLevel as setConfigLevel, shouldLog } from '../config/logging';\n\nexport function setLogLevel(level) {\n  setConfigLevel(level);\n}\n\nexport function setDebug(enabled) {\n  setConfigLevel(enabled ? 'debug' : DEFAULT_LOG_LEVEL);\n}\n\nexport { getLogLevel };\n\nexport const logger = {\n  debug: (...args) => {\n    if (shouldLog('debug')) {\n      // eslint-disable-next-line no-console\n      console.debug(...args);\n    }\n  },\n  info: (...args) => {\n    if (shouldLog('info')) {\n      // eslint-disable-next-line no-console\n      console.info(...args);\n    }\n  },\n  warn: (...args) => {\n    if (shouldLog('warn')) {\n      // eslint-disable-next-line no-console\n      console.warn(...args);\n    }\n  },\n  error: (...args) => {\n    if (shouldLog('error')) {\n      // eslint-disable-next-line no-console\n      console.error(...args);\n    }\n  },\n};\n\n","/**\n * Pure JavaScript P/T (Place/Transition) Petri Net Simulator\n * Replaces the Pyodide-based simulator with native JavaScript implementation\n */\nimport { BaseSimulator } from './BaseSimulator.js';\nimport { getSimulationStats } from './simulation-utils.js';\nimport { consumeTokens, produceTokens } from './token-io.js';\nimport { logger } from '../../utils/logger.js';\n\nexport class PTSimulator extends BaseSimulator {\n  constructor() {\n    super();\n    this.maxTokens = Infinity;\n  }\n\n  /**\n   * Get simulator type\n   */\n  getType() {\n    return 'pt';\n  }\n\n  /**\n   * Initialize the P/T simulator\n   */\n  async initializeSpecific(petriNet, options = {}) {\n    const optMax = Number(options.maxTokens);\n    this.maxTokens = Number.isFinite(optMax) && optMax >= 0 ? optMax : Infinity;\n    \n    // Validate that this is a P/T net (no algebraic expressions)\n    this.validatePTNet(petriNet);\n    \n    // Initialize place tokens if not present\n    this.initializeTokens(petriNet);\n    \n    logger.debug('P/T Simulator initialized with', petriNet.places.length, 'places and', petriNet.transitions.length, 'transitions');\n  }\n\n  /**\n   * Update the Petri net structure\n   */\n  async updateSpecific(petriNet) {\n    // Ensure tokens are properly initialized\n    this.initializeTokens(petriNet);\n    \n    // Emit transition state change event using base helper\n    const enabled = await this.getEnabledTransitionsSpecific();\n    this.emitTransitionsChanged({ enabled });\n  }\n\n  /**\n   * Get enabled transitions for P/T nets\n   */\n  async getEnabledTransitionsSpecific() {\n    if (!this.petriNet) return [];\n    \n    const { places, transitions, arcs } = this.petriNet;\n    const enabled = [];\n    \n    for (const transition of transitions) {\n      if (this.isTransitionEnabled(transition, places, arcs)) {\n        enabled.push(transition.id);\n      }\n    }\n    \n    return enabled;\n  }\n\n  /**\n   * Check if a transition is enabled\n   */\n  isTransitionEnabled(transition, places, arcs) {\n    // Get input arcs for this transition\n    const inputArcs = arcs.filter(arc => \n      arc.target === transition.id && arc.source !== transition.id\n    );\n    \n    // Check if all input places have sufficient tokens\n    for (const arc of inputArcs) {\n      const place = places.find(p => p.id === arc.source);\n      if (!place) continue;\n      \n      const requiredTokens = arc.weight || 1;\n      const availableTokens = place.tokens || 0;\n      \n      if (availableTokens < requiredTokens) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Fire a specific transition\n   */\n  async fireTransitionSpecific(transitionId, options = {}) {\n    const { places, transitions, arcs } = this.petriNet;\n    // Skip expensive enabled checks if firing in batch mode (caller guarantees transitions are enabled)\n    const skipEnabledCheck = options.skipEnabledCheck || false;\n    // Capture previous enabled transitions for parity event emission\n    const previouslyEnabled = skipEnabledCheck ? [] : await this.getEnabledTransitionsSpecific();\n    const transition = transitions.find(t => t.id === transitionId);\n    \n    if (!transition) {\n      throw new Error(`Transition ${transitionId} not found`);\n    }\n    \n    // Create a deep copy of the Petri net\n    const newPetriNet = JSON.parse(JSON.stringify(this.petriNet));\n    const newPlaces = newPetriNet.places;\n    \n    // Get input and output arcs\n    const inputArcs = arcs.filter(arc => \n      arc.target === transitionId && arc.source !== transitionId\n    );\n    const outputArcs = arcs.filter(arc => \n      arc.source === transitionId && arc.target !== transitionId\n    );\n    \n    // Use shared token I/O to keep semantics consistent with APN path\n    // Build picks for PT: each input arc consumes 'weight' anonymous tokens\n    const picks = [];\n    for (const arc of inputArcs) {\n      const n = (arc.weight || 1) | 0;\n      for (let i = 0; i < n; i++) {\n        picks.push({ srcId: arc.source, countFallback: true });\n      }\n    }\n\n    const placesById = Object.fromEntries(newPlaces.map(p => [p.id, p]));\n    consumeTokens(picks, placesById);\n\n    // For PT, outputArcs do not use algebraic bindings; produce count-only tokens\n    const outputArcsNormalized = outputArcs.map(a => ({\n      id: a.id,\n      sourceId: a.source,\n      targetId: a.target,\n      weight: a.weight || 1,\n    }));\n    for (const arc of outputArcsNormalized) {\n      const place = placesById[arc.targetId];\n      if (!place) continue;\n      // Ensure we are operating in PT mode: no valueTokens array\n      if (Array.isArray(place.valueTokens)) {\n        delete place.valueTokens;\n      }\n      const n = (arc.weight || 1) | 0;\n      place.tokens = ((Number(place.tokens || 0) + n) | 0);\n    }\n\n    // Cap tokens by PT maxTokens per place (PT has scalar tokens)\n    for (const p of newPlaces) {\n      if (!Array.isArray(p.valueTokens)) {\n        p.tokens = Math.min(this.maxTokens, (p.tokens || 0));\n      } else {\n        // If valueTokens accidentally exists, normalize back to PT counts\n        p.tokens = Math.min(this.maxTokens, Array.isArray(p.valueTokens) ? p.valueTokens.length : (p.tokens || 0));\n        delete p.valueTokens;\n      }\n    }\n    \n    // Update the Petri net\n    this.petriNet = newPetriNet;\n\n    // Skip expensive checks and event emissions if firing in batch mode (caller will handle after all fires complete)\n    if (!skipEnabledCheck) {\n      // Emit transition fired event using base helper\n      this.emitTransitionFired({ transitionId, newPetriNet });\n\n      // Emit transitionsChanged with parity payload\n      const enabledAfter = await this.getEnabledTransitionsSpecific();\n      this.emitTransitionsChanged({ enabled: enabledAfter, previouslyEnabled });\n    }\n\n    return newPetriNet;\n  }\n\n  /**\n   * Execute one simulation step\n   */\n  async stepSimulationSpecific() {\n    // Step semantics are centralized in useSimulationManager.\n    return this.petriNet;\n  }\n\n  /**\n   * Reset the simulator\n   */\n  resetSpecific() {\n    // Reset any P/T-specific state\n    this.maxTokens = Infinity;\n  }\n\n  /**\n   * Validate that this is a P/T net (no algebraic expressions)\n   */\n  validatePTNet(petriNet) {\n    const { transitions } = petriNet;\n    \n    for (const transition of transitions) {\n      // Check for algebraic expressions in guards\n      if (transition.guard && typeof transition.guard === 'string' && \n          (transition.guard.includes('+') || transition.guard.includes('-') || \n           transition.guard.includes('*') || transition.guard.includes('/') ||\n           transition.guard.includes('=') || transition.guard.includes('<') ||\n           transition.guard.includes('>') || transition.guard.includes('!='))) {\n        throw new Error('P/T simulator cannot handle algebraic expressions. Use algebraic simulator instead.');\n      }\n      \n      // Check for algebraic expressions in actions\n      if (transition.action && typeof transition.action === 'string' && \n          (transition.action.includes('+') || transition.action.includes('-') || \n           transition.action.includes('*') || transition.action.includes('/') ||\n           transition.action.includes('='))) {\n        throw new Error('P/T simulator cannot handle algebraic expressions. Use algebraic simulator instead.');\n      }\n    }\n  }\n\n  /**\n   * Initialize tokens in places if not present\n   */\n  initializeTokens(petriNet) {\n    const { places } = petriNet;\n    \n    for (const place of places) {\n      if (place.tokens === undefined || place.tokens === null) {\n        place.tokens = 0;\n      }\n      // Ensure tokens don't exceed maximum\n      place.tokens = Math.min(this.maxTokens, Math.max(0, place.tokens));\n    }\n  }\n\n  /**\n   * Get simulation statistics\n   */\n  getSimulationStats() {\n    if (!this.isInitialized) {\n      return { enabledTransitions: [], totalTokens: 0, totalPlaces: 0, totalTransitions: 0 };\n    }\n    \n    const { places, transitions } = this.petriNet;\n    const totalTokens = places.reduce((sum, place) => sum + (place.tokens || 0), 0);\n    \n    // Get enabled transitions synchronously for stats\n    const enabled = this.getEnabledTransitionsSync();\n    \n    return {\n      enabledTransitions: enabled,\n      totalTokens,\n      totalPlaces: places.length,\n      totalTransitions: transitions.length\n    };\n  }\n\n  /**\n   * Synchronous version of getEnabledTransitions for stats\n   */\n  getEnabledTransitionsSync() {\n    if (!this.petriNet) return [];\n    \n    const { places, transitions, arcs } = this.petriNet;\n    const enabled = [];\n    \n    for (const transition of transitions) {\n      if (this.isTransitionEnabled(transition, places, arcs)) {\n        enabled.push(transition.id);\n      }\n    }\n    \n    return enabled;\n  }\n}\n","// Implementation moved from utils/arith-parser.js\n\nexport function parseArithmetic(input) {\n  if (typeof input !== 'string') throw new Error('Expression must be a string');\n  const src = input.trim();\n  let i = 0;\n\n  function isDigit(ch) { return ch >= '0' && ch <= '9'; }\n  function skipWs() { while (i < src.length && /\\s/.test(src[i])) i++; }\n\n  function parseIntLiteral() {\n    skipWs();\n    let start = i;\n    while (i < src.length && isDigit(src[i])) i++;\n    if (start === i) throw new Error(`Expected int at position ${i}`);\n    const text = src.slice(start, i);\n    return { type: 'int', value: parseInt(text, 10) };\n  }\n\n  function isIdentStart(ch) { return /[A-Za-z_]/.test(ch); }\n  function isIdentPart(ch) { return /[A-Za-z0-9_]/.test(ch); }\n\n  function parseStringLiteral() {\n    skipWs();\n    if (src[i] !== \"'\") throw new Error(`Expected string literal at position ${i}`);\n    i++; // skip opening quote\n    let value = '';\n    while (i < src.length && src[i] !== \"'\") {\n      if (src[i] === '\\\\' && i + 1 < src.length) {\n        i++; // skip backslash\n        const next = src[i];\n        if (next === 'n') value += '\\n';\n        else if (next === 't') value += '\\t';\n        else if (next === 'r') value += '\\r';\n        else if (next === '\\\\') value += '\\\\';\n        else if (next === \"'\") value += \"'\";\n        else value += next;\n      } else {\n        value += src[i];\n      }\n      i++;\n    }\n    if (i >= src.length) throw new Error(`Unterminated string literal`);\n    i++; // skip closing quote\n    return { type: 'string', value };\n  }\n\n  function parseIdent() {\n    skipWs();\n    let start = i;\n    if (!isIdentStart(src[i])) throw new Error(`Expected identifier at position ${i}`);\n    i++;\n    while (i < src.length && isIdentPart(src[i])) i++;\n    const name = src.slice(start, i);\n\n    // Validate variable names start with lowercase to avoid T/F ambiguity\n    if (name && /^[A-Z]/.test(name)) {\n      throw new Error(`Variable names must start with lowercase letter, got '${name}' (use 't' instead of 'T', 'f' instead of 'F')`);\n    }\n\n    // Check for function call: name(args)\n    skipWs();\n    if (src[i] === '(') {\n      i++; // consume '('\n      const args = [];\n      skipWs();\n      if (src[i] !== ')') {\n        // Parse comma-separated arguments\n        do {\n          skipWs();\n          args.push(parseExpr());\n          skipWs();\n          if (src[i] === ',') {\n            i++; // consume comma\n          } else {\n            break;\n          }\n        } while (i < src.length);\n      }\n      skipWs();\n      if (src[i] !== ')') throw new Error(`Expected ')' after function arguments at position ${i}`);\n      i++; // consume ')'\n      return { type: 'funcall', name, args };\n    }\n\n    // Optional type annotation: \": int|bool|pair|string|list\"\n    const save = i;\n    skipWs();\n    if (src[i] === ':') {\n      i++;\n      skipWs();\n      const tStart = i;\n      while (i < src.length && /[A-Za-z]/.test(src[i])) i++;\n      const tWord = src.slice(tStart, i).toLowerCase();\n      if (tWord === 'int' || tWord === 'bool' || tWord === 'pair' || tWord === 'string' || tWord === 'list') {\n        return { type: 'var', name, varType: tWord };\n      } else {\n        i = save; // rollback\n        return { type: 'var', name };\n      }\n    }\n    return { type: 'var', name };\n  }\n\n  function parseListLiteral() {\n    skipWs();\n    if (src[i] !== '[') throw new Error(`Expected '[' at position ${i}`);\n    i++; // skip opening bracket\n    const elements = [];\n    skipWs();\n\n    if (src[i] === ']') {\n      i++; // empty list\n      return { type: 'list', elements: [] };\n    }\n\n    while (i < src.length) {\n      skipWs();\n      elements.push(parseExpr());\n      skipWs();\n\n      if (src[i] === ']') {\n        i++; // closing bracket\n        return { type: 'list', elements };\n      }\n\n      if (src[i] === ',') {\n        i++; // consume comma\n        continue;\n      }\n\n      throw new Error(`Expected ',' or ']' at position ${i}`);\n    }\n\n    throw new Error(`Unterminated list literal`);\n  }\n\n  function parseFactor() {\n    skipWs();\n    if (i >= src.length) throw new Error(`Unexpected end of input at position ${i}`);\n\n    if (src[i] === '(') {\n      i++; // consume '('\n      skipWs();\n      // Parse first expression inside parens\n      const first = parseExpr();\n      skipWs();\n      if (src[i] === ',') {\n        // Pair literal: (a, b)\n        i++; // consume comma\n        const second = parseExpr();\n        skipWs();\n        if (i >= src.length || src[i] !== ')') throw new Error(`Expected ')' at position ${i}`);\n        i++; // consume ')'\n        return { type: 'pair', fst: first, snd: second };\n      }\n      // Grouping\n      if (i >= src.length || src[i] !== ')') throw new Error(`Expected ')' at position ${i}`);\n      i++; // consume ')'\n      return first;\n    }\n\n    if (src[i] === '[') return parseListLiteral();\n    if (src[i] === \"'\") return parseStringLiteral();\n    if (isDigit(src[i])) return parseIntLiteral();\n    if (/[A-Za-z_]/.test(src[i])) return parseIdent();\n\n    throw new Error(`Unexpected character '${src[i]}' at position ${i}`);\n  }\n\n  function parseTerm() {\n    let left = parseFactor();\n    skipWs();\n    while (i < src.length && (src[i] === '*' || src[i] === '/')) {\n      const op = src[i++];\n      const right = parseFactor();\n      left = { type: 'binop', op, left, right };\n      skipWs();\n    }\n    return left;\n  }\n\n  function parseExpr() {\n    let left = parseTerm();\n    skipWs();\n    while (i < src.length && (src[i] === '+' || src[i] === '-')) {\n      const op = src[i++];\n      const right = parseTerm();\n      left = { type: 'binop', op, left, right };\n      skipWs();\n    }\n    return left;\n  }\n\n  let result = parseExpr();\n  skipWs();\n  if (i < src.length) throw new Error(`Unexpected character '${src[i]}' at position ${i}`);\n  function normalize(node) {\n    if (!node || typeof node !== 'object') return node;\n    if (node.type === 'bin') node.type = 'binop';\n    if (node.left) node.left = normalize(node.left);\n    if (node.right) node.right = normalize(node.right);\n    if (Array.isArray(node.args)) node.args = node.args.map(normalize);\n    if (Array.isArray(node.elements)) node.elements = node.elements.map(normalize);\n    return node;\n  }\n  result = normalize(result);\n  return result;\n}\n\nexport function stringifyArithmetic(ast) {\n  if (!ast) return '';\n\n  switch (ast.type) {\n    case 'int':\n      return String(ast.value);\n    case 'string':\n      return `'${ast.value.replace(/'/g, \"\\\\'\")}'`;\n    case 'list': {\n      const elements = (ast.elements || []).map(stringifyArithmetic).join(', ');\n      return `[${elements}]`;\n    }\n    case 'var':\n      return ast.varType ? `${ast.name}:${ast.varType}` : ast.name;\n    case 'binop': {\n      const left = stringifyArithmetic(ast.left);\n      const right = stringifyArithmetic(ast.right);\n      return `(${left} ${ast.op} ${right})`;\n    }\n    case 'funcall': {\n      const args = (ast.args || []).map(stringifyArithmetic).join(', ');\n      return `${ast.name}(${args})`;\n    }\n    default:\n      return '';\n  }\n}\n\n\n\n","// Implementation moved from utils/arith-parser.js\n\nexport function parsePattern(input) {\n  if (typeof input !== 'string') throw new Error('Pattern must be a string');\n  const src = input.trim();\n  let i = 0;\n\n  function skipWs() { while (i < src.length && /\\s/.test(src[i])) i++; }\n\n  function parsePatternElement() {\n    skipWs();\n    if (i >= src.length) throw new Error(`Unexpected end of input at position ${i}`);\n\n    // Booleans\n    if (src.slice(i, i + 1) === 'T') { i++; return { type: 'boolLit', value: true }; }\n    if (src.slice(i, i + 1) === 'F') { i++; return { type: 'boolLit', value: false }; }\n    if (src.slice(i, i + 4) === 'true') { i += 4; return { type: 'boolLit', value: true }; }\n    if (src.slice(i, i + 5) === 'false') { i += 5; return { type: 'boolLit', value: false }; }\n\n    // Integers\n    if (/[0-9]/.test(src[i])) {\n      let start = i;\n      while (i < src.length && /[0-9]/.test(src[i])) i++;\n      const value = parseInt(src.slice(start, i), 10);\n      return { type: 'int', value };\n    }\n\n    // List pattern\n    if (src[i] === '[') {\n      i++; // '['\n      skipWs();\n      const elements = [];\n      while (i < src.length && src[i] !== ']') {\n        elements.push(parsePatternElement());\n        skipWs();\n        if (src[i] === ',') { i++; skipWs(); }\n      }\n      if (i >= src.length || src[i] !== ']') throw new Error(`Expected ']' at position ${i}`);\n      i++; // ']'\n      return { type: 'listPattern', elements };\n    }\n\n    // Variable or typed var\n    if (/[a-zA-Z_]/.test(src[i])) {\n      let start = i;\n      while (i < src.length && /[a-zA-Z0-9_]/.test(src[i])) i++;\n      const name = src.slice(start, i);\n\n      // Type annotation\n      skipWs();\n      if (src[i] === ':') {\n        i++;\n        skipWs();\n        let tStart = i;\n        while (i < src.length && /[a-zA-Z]/.test(src[i])) i++;\n        const varType = src.slice(tStart, i).toLowerCase();\n        if (varType === 'int' || varType === 'bool' || varType === 'pair' || varType === 'string' || varType === 'list') {\n          return { type: 'var', name, varType };\n        } else {\n          throw new Error(`Unknown type '${varType}' at position ${tStart}`);\n        }\n      }\n\n      return { type: 'var', name };\n    }\n\n    // Pair/tuple pattern\n    if (src[i] === '(') {\n      i++; // '('\n      skipWs();\n\n      const elements = [];\n      while (i < src.length && src[i] !== ')') {\n        elements.push(parsePatternElement());\n        skipWs();\n        if (i < src.length && src[i] === ',') {\n          i++; // ','\n          skipWs();\n        }\n      }\n\n      if (i >= src.length || src[i] !== ')') {\n        throw new Error(`Expected ')' at position ${i}`);\n      }\n      i++; // ')'\n\n      if (elements.length === 2) {\n        return { type: 'pairPattern', fst: elements[0], snd: elements[1] };\n      } else {\n        return { type: 'tuplePattern', elements };\n      }\n    }\n\n    throw new Error(`Unexpected character '${src[i]}' at position ${i}`);\n  }\n\n  const result = parsePatternElement();\n  skipWs();\n  if (i < src.length) throw new Error(`Unexpected character '${src[i]}' at position ${i}`);\n  return result;\n}\n\nexport function matchPattern(pattern, value) {\n  const bindings = new Map();\n\n  function matchElement(pat, val) {\n    switch (pat.type) {\n      case 'int':\n        if (typeof val !== 'number' || val !== pat.value) return false;\n        return true;\n\n      case 'boolLit':\n        if (typeof val !== 'boolean' || val !== pat.value) return false;\n        return true;\n\n      case 'var':\n        if (pat.varType) {\n          const expectedType = pat.varType;\n          if (expectedType === 'int' && typeof val !== 'number') return false;\n          if (expectedType === 'bool' && typeof val !== 'boolean') return false;\n          if (expectedType === 'string' && typeof val !== 'string') return false;\n          if (expectedType === 'list' && !Array.isArray(val)) return false;\n          if (expectedType === 'pair' && (!val || typeof val !== 'object' || !val.__pair__)) return false;\n        }\n        if (bindings.has(pat.name)) {\n          const boundValue = bindings.get(pat.name);\n          if (boundValue !== val) return false;\n        } else {\n          bindings.set(pat.name, val);\n        }\n        return true;\n\n      case 'pairPattern':\n        if (!val || typeof val !== 'object' || !val.__pair__) return false;\n        if (!matchElement(pat.fst, val.fst) || !matchElement(pat.snd, val.snd)) return false;\n        return true;\n\n      case 'tuplePattern':\n        if (!Array.isArray(val) || val.length !== pat.elements.length) return false;\n        for (let index = 0; index < pat.elements.length; index++) {\n          if (!matchElement(pat.elements[index], val[index])) return false;\n        }\n        return true;\n\n      case 'listPattern':\n        if (!Array.isArray(val) || val.length !== pat.elements.length) return false;\n        for (let i = 0; i < pat.elements.length; i++) {\n          if (!matchElement(pat.elements[i], val[i])) return false;\n        }\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  const success = matchElement(pattern, value);\n  return success ? Object.fromEntries(bindings) : null;\n}\n\nexport function validatePatternTyping(pattern) {\n  function validateComponent(pat) {\n    switch (pat.type) {\n      case 'var':\n        if (!pat.varType) {\n          return `Variable '${pat.name}' must be typed (e.g., ${pat.name}:int, ${pat.name}:bool, ${pat.name}:pair)`;\n        }\n        return null;\n      case 'pairPattern':\n      case 'tuplePattern': {\n        const elements = pat.type === 'pairPattern' ? [pat.fst, pat.snd] : pat.elements;\n        for (const elem of elements) {\n          const error = validateComponent(elem);\n          if (error) return error;\n        }\n        return null;\n      }\n      default:\n        return null;\n    }\n  }\n\n  return validateComponent(pattern);\n}\n\nexport function addTypeAnnotations(pattern, defaultType = 'Int') {\n  function addTypes(pat) {\n    switch (pat.type) {\n      case 'var':\n        if (!pat.varType) {\n          return { ...pat, varType: defaultType.toLowerCase() };\n        }\n        return pat;\n      case 'pairPattern':\n        return { ...pat, fst: addTypes(pat.fst), snd: addTypes(pat.snd) };\n      case 'tuplePattern':\n        return { ...pat, elements: pat.elements.map(addTypes) };\n      default:\n        return pat;\n    }\n  }\n\n  return addTypes(pattern);\n}\n\nexport function stringifyPattern(pattern) {\n  function stringifyElement(elem) {\n    switch (elem.type) {\n      case 'int':\n        return String(elem.value);\n      case 'boolLit':\n        return elem.value ? 'T' : 'F';\n      case 'var':\n        return elem.varType\n          ? `${elem.name}:${elem.varType.charAt(0).toUpperCase() + elem.varType.slice(1)}`\n          : elem.name;\n      case 'pairPattern':\n        return `(${stringifyElement(elem.fst)}, ${stringifyElement(elem.snd)})`;\n      case 'tuplePattern':\n        return `(${elem.elements.map(stringifyElement).join(', ')})`;\n      default:\n        return '';\n    }\n  }\n\n  return stringifyElement(pattern);\n}\n\nexport function extractVariablesFromPattern(pattern) {\n  const variables = [];\n\n  function traverse(node) {\n    if (!node) return;\n\n    switch (node.type) {\n      case 'var':\n        variables.push(node.name);\n        break;\n      case 'pairPattern':\n        if (node.fst) traverse(node.fst);\n        if (node.snd) traverse(node.snd);\n        break;\n      case 'listPattern':\n        if (Array.isArray(node.elements)) node.elements.forEach(traverse);\n        break;\n      case 'tuplePattern':\n        if (node.elements) node.elements.forEach(traverse);\n        break;\n    }\n  }\n\n  traverse(pattern);\n  return variables;\n}\n\n\n\n","// Utilities for working with algebraic tokens\n\nexport function getTokensForPlace(place, cap = 20) {\n  if (!place) return [];\n  if (Array.isArray(place.valueTokens)) {\n    return place.valueTokens.slice(0, cap);\n  }\n  const n = Number(place.tokens || 0);\n  if (Number.isFinite(n) && n > 0) {\n    return Array.from({ length: Math.min(n, cap) }, () => 1);\n  }\n  return [];\n}\n\nexport function isPair(v) {\n  return !!(v && typeof v === 'object' && v.__pair__ === true && 'fst' in v && 'snd' in v);\n}\n\n\n","// Evaluate pattern-style literals to concrete JS values using an env\n// Supports pairPattern, tuplePattern, listPattern, boolLit, int, var/boolVar/pairVar\n\nexport function evaluatePatternLiteral(node, env) {\n  if (!node) return null;\n  switch (node.type) {\n    case 'pairLit':\n      return { __pair__: true, fst: evaluatePatternLiteral(node.fst, env), snd: evaluatePatternLiteral(node.snd, env) };\n    case 'list':\n      return (node.elements || []).map(n => evaluatePatternLiteral(n, env));\n    case 'pairPattern':\n      return { __pair__: true, fst: evaluatePatternLiteral(node.fst, env), snd: evaluatePatternLiteral(node.snd, env) };\n    case 'tuplePattern':\n      return (node.elements || node.components || []).map(n => evaluatePatternLiteral(n, env));\n    case 'listPattern':\n      return (node.elements || []).map(n => evaluatePatternLiteral(n, env));\n    case 'boolLit':\n      return !!node.value;\n    case 'int':\n      return (node.value | 0);\n    case 'var':\n    case 'boolVar':\n    case 'pairVar':\n      return (env || {})[node.name];\n    default:\n      return null;\n  }\n}\n\n\n","// Type compatibility checks for output bindings\n\nexport function ensureOutputBindingsTypeCompatible(petriNet, cache, transitionId, env) {\n  try {\n    const outputArcs = (petriNet.arcs || []).filter(a => a.sourceId === transitionId && (a.targetType === 'place' || !a.targetType));\n    for (const arc of outputArcs) {\n      const bindingAsts = cache?.bindingAstsByArc?.get(arc.id) || [];\n      for (const astObj of bindingAsts) {\n        const { ast } = astObj || {};\n        if (!ast) continue;\n        // Only check variables with type annotations; literals and untyped variables are fine\n        if (ast.type === 'var' || ast.type === 'boolVar' || ast.type === 'pairVar') {\n          const v = env ? env[ast.name] : undefined;\n          if (v === undefined) continue; // may be filled later by action/guard\n          const t = ast.varType;\n          if (t === 'int' && typeof v !== 'number') return false;\n          if (t === 'bool' && typeof v !== 'boolean') return false;\n          if (t === 'string' && typeof v !== 'string') return false;\n          if (t === 'pair' && !(v && typeof v === 'object' && v.__pair__ === true)) return false;\n          if (t === 'list' && !Array.isArray(v)) return false;\n        }\n      }\n    }\n    return true;\n  } catch (_) {\n    return false;\n  }\n}\n\n\n","// Registry of allowed function names that can appear in arithmetic/binding expressions\n\nconst defaultAllowedOps = [\n  'concat', 'substring', 'length',\n  'head', 'tail', 'append', 'sublist', 'isSublistOf',\n  'isSubstringOf',\n  'fst', 'snd'\n];\n\nexport const allowedOps = new Set(defaultAllowedOps);\n\n// Optionally allow registering new ops at runtime/tests in a controlled way\nexport function registerOp(name) {\n  if (typeof name === 'string' && name.trim()) {\n    allowedOps.add(name.trim());\n  }\n}\n\nexport function unregisterOp(name) {\n  if (typeof name === 'string' && name.trim()) {\n    allowedOps.delete(name.trim());\n  }\n}\n\n\n","// Cache builders for guards and bindings\n\nexport function buildGuardCache(petriNet, parseArithmetic, parseBooleanExpr, parsePredicate) {\n  const guardAstByTransition = new Map();\n  for (const t of (petriNet.transitions || [])) {\n    if (t.guard && typeof t.guard === 'string') {\n      try {\n        const ast = parseBooleanExpr(String(t.guard), parseArithmetic);\n        guardAstByTransition.set(t.id, ast);\n      } catch (_) {\n        try {\n          const ast = parsePredicate(String(t.guard), parseArithmetic);\n          guardAstByTransition.set(t.id, ast);\n        } catch (_) {\n          // ignore parse errors here; guard will simply be false if unparsable\n        }\n      }\n    }\n  }\n  return guardAstByTransition;\n}\n\nfunction containsOperationCall(text, ops) {\n  if (!text) return false;\n  const len = text.length;\n  for (let i = 0; i < len; i += 1) {\n    const ch = text[i];\n    if (!/[A-Za-z_]/.test(ch)) continue;\n    let j = i + 1;\n    while (j < len && /[A-Za-z0-9_]/.test(text[j])) j += 1;\n    const ident = text.slice(i, j);\n    if (ops.has(ident)) {\n      let k = j;\n      while (k < len && /\\s/.test(text[k])) k += 1;\n      if (k < len && text[k] === '(') {\n        return true;\n      }\n    }\n    i = j - 1;\n  }\n  return false;\n}\n\nexport function buildBindingCache(petriNet, parsePattern, parseArithmetic, parseBooleanExpr, allowedOps) {\n  const bindingAstsByArc = new Map();\n  for (const a of (petriNet.arcs || [])) {\n    const key = a.id;\n    const bindings = Array.isArray(a.bindings) ? a.bindings : (a.binding ? [a.binding] : []);\n    const asts = [];\n    for (const b of bindings) {\n      const text = String(b);\n\n      const trimmed = text.trim();\n      const preferArithmetic = containsOperationCall(trimmed, allowedOps);\n\n      const isAllowedFuncall = (node) => {\n        if (!node || typeof node !== 'object') return true;\n        switch (node.type) {\n          case 'funcall':\n            if (!allowedOps.has(node.name)) return false;\n            return (node.args || []).every(isAllowedFuncall);\n          case 'pair':\n            return isAllowedFuncall(node.fst) && isAllowedFuncall(node.snd);\n          case 'list':\n            return (node.elements || []).every(isAllowedFuncall);\n          case 'binop':\n            return isAllowedFuncall(node.left) && isAllowedFuncall(node.right);\n          default:\n            return true;\n        }\n      };\n\n      const tryArithmetic = () => {\n        let parsed = null;\n        try { parsed = parseArithmetic(text); } catch (_) { parsed = null; }\n        if (!parsed) return false;\n        if (!isAllowedFuncall(parsed)) return false;\n        if (parsed.type === 'var' && parsed.varType === 'bool') {\n          asts.push({ kind: 'bool', ast: { type: 'boolVar', name: parsed.name, varType: 'bool' } });\n        } else if (parsed.type === 'var' && parsed.varType === 'pair') {\n          asts.push({ kind: 'pair', ast: { type: 'pairVar', name: parsed.name, varType: 'pair' } });\n        } else {\n          asts.push({ kind: 'arith', ast: parsed });\n        }\n        return true;\n      };\n\n      const tryPattern = () => {\n        try {\n          const pattern = parsePattern(text);\n          asts.push({ kind: 'pattern', ast: pattern });\n          return true;\n        } catch (_) {\n          return false;\n        }\n      };\n\n      let handled = false;\n      if (preferArithmetic) {\n        handled = tryArithmetic();\n        if (!handled) handled = tryPattern();\n      } else {\n        handled = tryPattern();\n        if (!handled) handled = tryArithmetic();\n      }\n\n      if (handled) continue;\n\n      // Prefer arithmetic, but if variable annotated as bool, store as bool kind\n      const tf = (text === 'T') ? true : (text === 'F') ? false : null;\n      if (tf !== null) { asts.push({ kind: 'bool', ast: { type: 'boolLit', value: tf } }); continue; }\n      try { asts.push({ kind: 'bool', ast: parseBooleanExpr(text, parseArithmetic) }); continue; } catch (_) {}\n      // Skip invalid\n    }\n    if (asts.length) bindingAstsByArc.set(key, asts);\n  }\n  return bindingAstsByArc;\n}\n\n\n","// Find a satisfying assignment of input tokens for a transition\n\nfunction isPair(v) {\n  return !!(v && typeof v === 'object' && v.__pair__ === true && 'fst' in v && 'snd' in v);\n}\n\nexport async function findSatisfyingAssignment({\n  transition,\n  inputArcs,\n  placesById,\n  bindingAstsByArc,\n  guardAst,\n  parseArithmetic,\n  evaluateBooleanPredicate,\n  matchPattern,\n  getTokensForPlace,\n  evaluateArithmeticWithBindings,\n  evaluateBooleanWithBindings,\n  evaluatePatternLiteral,\n  maxTokensPerPlace = 20,\n}) {\n  const picks = [];\n\n  const tryArc = async (arcIndex, env) => {\n    if (arcIndex >= inputArcs.length) {\n      if (!guardAst) return { env, picks };\n      // Prefer pure boolean evaluation when possible (Jest/node friendly),\n      // fallback to Z3 SAT if pure evaluation fails or throws\n      try {\n        const pureOk = evaluateBooleanWithBindings(guardAst, env || {}, parseArithmetic);\n        if (!pureOk) return null;\n        return { env, picks };\n      } catch (err) {\n        try {\n          const ok = await evaluateBooleanPredicate(guardAst, env || {}, parseArithmetic);\n          return ok ? { env, picks } : null;\n        } catch (_) {\n          return null;\n        }\n      }\n    }\n\n    const arc = inputArcs[arcIndex];\n    const arcId = arc.id;\n    const srcId = arc.sourceId || arc.source;\n    const place = placesById[srcId];\n    const tokens = getTokensForPlace(place, maxTokensPerPlace);\n    const bindingAsts = (bindingAstsByArc.get(arcId) || []);\n    const needed = bindingAsts.length || (arc.weight ? Math.max(1, arc.weight | 0) : 0);\n    if (needed === 0) return tryArc(arcIndex + 1, env);\n    if (tokens.length < needed) return null;\n\n    const used = new Array(tokens.length).fill(false);\n\n    const tryBind = async (k, localEnv) => {\n      if (k >= needed) return tryArc(arcIndex + 1, localEnv);\n      for (let i = 0; i < tokens.length; i++) {\n        if (used[i]) continue;\n        used[i] = true;\n        const tok = tokens[i];\n        let ok = true;\n        let nextEnv = localEnv;\n        const astObj = bindingAsts[k];\n        if (astObj) {\n          const { kind, ast } = astObj;\n          if (kind === 'pattern') {\n            const bindings = matchPattern(ast, tok);\n            if (bindings === null) {\n              ok = false;\n            } else {\n              for (const [varName, varValue] of Object.entries(bindings)) {\n                if (nextEnv && Object.prototype.hasOwnProperty.call(nextEnv, varName) && nextEnv[varName] !== varValue) {\n                  ok = false; break;\n                }\n              }\n              if (ok) nextEnv = { ...(nextEnv || {}), ...bindings };\n            }\n          } else if (ast && (ast.type === 'var' || ast.type === 'boolVar' || ast.type === 'pairVar')) {\n            if (nextEnv && Object.prototype.hasOwnProperty.call(nextEnv, ast.name) && nextEnv[ast.name] !== tok) {\n              ok = false;\n            } else {\n              if (typeof tok === 'boolean' && ast.varType && ast.varType !== 'bool') ok = false;\n              if (typeof tok === 'number' && ast.varType && ast.varType !== 'int') ok = false;\n              if (typeof tok === 'string' && ast.varType && ast.varType !== 'string') ok = false;\n              if (Array.isArray(tok) && ast.varType && ast.varType !== 'list') ok = false;\n              if (isPair(tok) && ast.varType && ast.varType !== 'pair') ok = false;\n              if (ok) nextEnv = { ...(nextEnv || {}), [ast.name]: tok };\n            }\n          } else if (kind === 'arith') {\n            try {\n              const val = evaluateArithmeticWithBindings(ast, localEnv || {});\n              if (typeof tok !== 'number' || val !== (tok | 0)) ok = false;\n            } catch (_) { ok = false; }\n          } else if (kind === 'bool') {\n            try {\n              const val = evaluateBooleanWithBindings(ast, localEnv || {}, parseArithmetic);\n              if (typeof tok !== 'bool' || val !== tok) ok = false;\n            } catch (_) { ok = false; }\n          } else if (kind === 'pair') {\n            try {\n              if (ast.type === 'pairLit') {\n                const v = evaluatePatternLiteral(ast, localEnv || {});\n                if (!isPair(tok) || JSON.stringify(v) !== JSON.stringify(tok)) ok = false;\n              }\n            } catch (_) { ok = false; }\n          }\n        }\n        if (ok) {\n          picks.push({ arcId: arc.id, srcId, tokenIndex: i, value: tok, countFallback: !Array.isArray(place?.valueTokens) });\n          const res = await tryBind(k + 1, nextEnv);\n          if (res) return res;\n          picks.pop();\n        }\n        used[i] = false;\n      }\n      return null;\n    };\n\n    return tryBind(0, env || {});\n  };\n\n  return tryArc(0, {});\n}\n\n\n","// Utilities for guard and binding variable analysis in the algebraic simulator\n\nexport function extractVariablesFromPattern(ast) {\n  const variables = new Set();\n\n  function traverse(node) {\n    if (!node) return;\n\n    switch (node.type) {\n      case 'var':\n        variables.add(node.name);\n        break;\n      case 'pairPattern':\n        traverse(node.fst);\n        traverse(node.snd);\n        break;\n      case 'listPattern':\n        if (Array.isArray(node.elements)) {\n          node.elements.forEach(traverse);\n        }\n        break;\n      case 'tuplePattern':\n        if (node.elements) {\n          node.elements.forEach(traverse);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  traverse(ast);\n  return Array.from(variables);\n}\n\nexport function extractVariablesFromExpression(ast) {\n  const variables = new Set();\n\n  function traverse(node) {\n    if (!node) return;\n\n    switch (node.type) {\n      case 'var':\n      case 'boolVar':\n      case 'pairVar':\n        variables.add(node.name);\n        break;\n      case 'binop':\n      case 'cmp':\n        traverse(node.left);\n        traverse(node.right);\n        break;\n      case 'unop':\n        traverse(node.operand);\n        break;\n      case 'call':\n        if (node.args) {\n          node.args.forEach(traverse);\n        }\n        break;\n      case 'pairPattern':\n        traverse(node.fst);\n        traverse(node.snd);\n        break;\n      case 'tuplePattern':\n        if (node.elements) {\n          node.elements.forEach(traverse);\n        }\n        break;\n      case 'pairLit':\n        traverse(node.fst);\n        traverse(node.snd);\n        break;\n      default:\n        break;\n    }\n  }\n\n  traverse(ast);\n  return Array.from(variables);\n}\n\n// Returns true when unbound variables are detected (transition should be disabled)\nexport function checkForUnboundVariables(petriNet, bindingAstsByArc, guardAstByTransition, transitionId, inputArcs) {\n  // Get all variables that can be bound from input arcs\n  const boundVariables = new Set();\n\n  // Collect variables from input arc bindings (including nested variables in patterns)\n  for (const arc of inputArcs) {\n    const bindingAsts = (bindingAstsByArc.get(arc.id) || []);\n    for (const astObj of bindingAsts) {\n      const { kind, ast } = astObj || {};\n      if (kind === 'pattern') {\n        const variables = extractVariablesFromPattern(ast);\n        variables.forEach(varName => boundVariables.add(varName));\n      }\n    }\n  }\n\n  // Check guard for unbound variables\n  const guardAst = guardAstByTransition.get(transitionId);\n  if (guardAst) {\n    const guardVars = extractVariablesFromExpression(guardAst);\n    for (const varName of guardVars) {\n      if (!boundVariables.has(varName)) {\n        return true; // Has unbound variables\n      }\n    }\n  }\n\n  // Check output arcs for unbound variables and empty bindings\n  const outputArcs = (petriNet.arcs || []).filter(a => a.sourceId === transitionId && (a.targetType === 'place' || !a.targetType));\n  for (const arc of outputArcs) {\n    const bindingAsts = bindingAstsByArc.get(arc.id) || [];\n    // If output arc has no bindings at all, disable transition (no token can be produced)\n    if (bindingAsts.length === 0) {\n      return true; // Disable transition\n    }\n    for (const astObj of bindingAsts) {\n      const { kind, ast } = astObj || {};\n      if (kind === 'pattern' && ast.type === 'var') {\n        // Only check variables - literals like 'int', 'boolLit', 'pairPattern' are always valid\n        if (!boundVariables.has(ast.name)) {\n          return true; // Has unbound variables\n        }\n      }\n    }\n  }\n\n  return false; // No unbound variables and all output arcs have bindings\n}\n\n\n","// Normalize Petri net state to a consistent shape across simulators\n\nexport function getCurrentStateNormalized(petriNet) {\n  const places = (petriNet.places || []).map(p => ({\n    id: p.id,\n    label: p.label || '',\n    tokens: Number(Array.isArray(p.valueTokens) ? p.valueTokens.length : (p.tokens || 0)),\n    x: Number(p.x || 0),\n    y: Number(p.y || 0),\n    name: p.name || '',\n    type: 'place',\n    valueTokens: Array.isArray(p.valueTokens) ? [...p.valueTokens] : undefined,\n  }));\n  const transitions = (petriNet.transitions || []).map(t => ({\n    id: t.id,\n    label: t.label || '',\n    x: Number(t.x || 0),\n    y: Number(t.y || 0),\n    name: t.name || '',\n    type: 'transition',\n    guard: t.guard,\n    action: t.action,\n  }));\n  const placeIds = new Set(places.map(p => p.id));\n  const transitionIds = new Set(transitions.map(t => t.id));\n  const arcs = (petriNet.arcs || []).map(a => {\n    const s = a.sourceId || a.source;\n    const t = a.targetId || a.target;\n    const inferredSourceType = placeIds.has(s) ? 'place' : (transitionIds.has(s) ? 'transition' : (a.sourceType || 'place'));\n    const inferredTargetType = placeIds.has(t) ? 'place' : (transitionIds.has(t) ? 'transition' : (a.targetType || 'transition'));\n    const type = a.type || `${inferredSourceType}-to-${inferredTargetType}`;\n    return {\n      id: a.id,\n      sourceId: s,\n      targetId: t,\n      source: s,\n      target: t,\n      weight: Number(a.weight || 1),\n      sourceType: inferredSourceType,\n      targetType: inferredTargetType,\n      type,\n      bindings: Array.isArray(a.bindings) ? [...a.bindings] : (a.binding ? [a.binding] : []),\n    };\n  });\n  return { places, transitions, arcs };\n}\n\n\n","import { logger } from '../logger.js';\n\nlet z3InitPromise = null;\n\nasync function ensureZ3Available() {\n  const isNodeJSTest = typeof process !== 'undefined' && process.env && process.env.JEST_WORKER_ID;\n  if (isNodeJSTest) {\n    logger.debug('Jest worker detected, skipping Z3 asset fetch');\n    return;\n  }\n    // Worker context (no DOM): fetch and evaluate z3-built.js with embedded WASM\n    if (typeof document === 'undefined') {\n      if (typeof globalThis.initZ3 === 'function') return;\n      const originalModule = globalThis.Module;\n      try {\n        const deriveBaseUrl = () => {\n          try {\n            const { origin, pathname } = self.location || {};\n            if (!origin) return '';\n            if (typeof pathname === 'string') {\n              const assetsIdx = pathname.indexOf('/assets/');\n              if (assetsIdx !== -1) {\n                return `${origin}${pathname.slice(0, assetsIdx + 1)}`;\n              }\n              // Fallback to directory of current path\n              const lastSlash = pathname.lastIndexOf('/');\n              const dir = lastSlash >= 0 ? pathname.slice(0, lastSlash + 1) : '/';\n              return `${origin}${dir}`;\n            }\n            return `${origin}/`;\n          } catch (_) {\n            return '';\n          }\n        };\n\n        const baseUrl = deriveBaseUrl();\n        const buildAssetUrl = (assetPath) => {\n          const cleanPath = assetPath.startsWith('/') ? assetPath.slice(1) : assetPath;\n          if (!baseUrl) {\n            return `/${cleanPath}`;\n          }\n          return `${baseUrl}${cleanPath}`;\n        };\n\n        // First load the WASM file as base64\n        const wasmPath = buildAssetUrl('z3-built.wasm.base64');\n        logger.debug('[Z3 worker] fetching WASM base64 from', wasmPath);\n        const wasmResponse = await fetch(wasmPath);\n        if (!wasmResponse.ok) throw new Error(`Failed to fetch WASM base64 from ${wasmPath}: ${wasmResponse.status}`);\n        const wasmBase64 = await wasmResponse.text();\n\n        // Create data URL for WASM\n        const wasmDataUrl = `data:application/wasm;base64,${wasmBase64}`;\n\n        const patchedModule = {\n          ...(typeof originalModule === 'object' ? originalModule : {}),\n          locateFile: (path) => {\n            if (path.endsWith('.wasm')) {\n              logger.debug('[Z3 worker] locateFile', path, '->', `${wasmDataUrl.substring(0, 50)}...`);\n              return wasmDataUrl;\n            }\n            const resolved = buildAssetUrl(path);\n            logger.debug('[Z3 worker] locateFile', path, '->', resolved);\n            return resolved;\n          }\n        };\n        globalThis.Module = patchedModule;\n\n        const jsPath = buildAssetUrl('z3-built.js');\n        const response = await fetch(jsPath);\n        if (!response.ok) throw new Error(`Failed to fetch z3-built.js from ${jsPath}: ${response.status}`);\n        const z3Script = await response.text();\n        // Evaluate in worker global scope\n        (0, eval)(z3Script);\n        await new Promise(resolve => setTimeout(resolve, 20));\n        if (typeof globalThis.initZ3 !== 'function') throw new Error('initZ3 not defined after eval');\n        return;\n      } catch (error) {\n        throw new Error(`Failed to load Z3 in worker: ${error.message}`);\n      } finally {\n      if (typeof originalModule === 'object') {\n        globalThis.Module = originalModule;\n      } else {\n        delete globalThis.Module;\n      }\n    }\n  }\n\n  // Main thread (DOM available)\n  if (typeof globalThis.initZ3 === 'function') return;\n  logger.debug('initZ3 not found, loading Z3 built assets...');\n  await new Promise((resolve, reject) => {\n    const scriptElement = document.createElement('script');\n    scriptElement.src = '/z3-built.js';\n    scriptElement.async = true;\n    scriptElement.addEventListener('load', () => {\n      if (typeof globalThis.initZ3 === 'function') {\n        logger.debug('Z3 built assets loaded successfully');\n        resolve();\n      } else {\n        reject(new Error('initZ3 function not found after loading z3-built.js'));\n      }\n    });\n    scriptElement.addEventListener('error', (err) => {\n      reject(new Error(`Failed to load z3-built.js: ${err?.message || err}`));\n    });\n    document.head.appendChild(scriptElement);\n  });\n}\n\nexport async function getContext() {\n  if (!z3InitPromise) {\n    z3InitPromise = (async () => {\n      try {\n        logger.debug('Initializing Z3 context...');\n        // Always ensure Z3 assets are loaded first (skip direct WASM init that fails)\n        await ensureZ3Available();\n\n        const { init } = await import('z3-solver');\n        if (!init) {\n          throw new Error('Z3 init function not found. Z3-solver package may not be properly installed.');\n        }\n\n        logger.debug('Calling Z3 init...');\n        const z3 = await init();\n        if (!z3) {\n          throw new Error('Z3 initialization failed. Check browser console for WASM loading errors.');\n        }\n\n        logger.debug('Creating Z3 context...');\n        // Use a general-purpose context so both arithmetic and string theories are available\n        const ctx = new z3.Context('main');\n        if (!ctx) {\n          throw new Error('Failed to create Z3 context.');\n        }\n\n        logger.debug('Z3 context initialized successfully');\n        return { z3, ctx };\n      } catch (error) {\n        logger.error('Z3 initialization error:', error);\n\n        // For browser (not test environment), try asset loading fallback\n        const isNodeJSTest = typeof process !== 'undefined' && process.env && process.env.JEST_WORKER_ID;\n        if (typeof document !== 'undefined' && !isNodeJSTest) {\n          logger.debug('Retrying Z3 initialization with asset loading...');\n          try {\n            // Force asset loading\n            if (typeof globalThis.initZ3 !== 'function') {\n              logger.debug('initZ3 not found, loading Z3 built assets...');\n              await new Promise((resolve, reject) => {\n                const scriptElement = document.createElement('script');\n                scriptElement.src = '/z3-built.js';\n                scriptElement.async = true;\n                scriptElement.addEventListener('load', () => {\n                  if (typeof globalThis.initZ3 === 'function') {\n                    logger.debug('Z3 built assets loaded successfully');\n                    resolve();\n                  } else {\n                    reject(new Error('initZ3 function not found after loading z3-built.js'));\n                  }\n                });\n                scriptElement.addEventListener('error', (err) => {\n                  reject(new Error(`Failed to load z3-built.js: ${err?.message || err}`));\n                });\n                document.head.appendChild(scriptElement);\n              });\n            }\n\n            const { init } = await import('z3-solver');\n            const z3 = await init();\n            const ctx = new z3.Context('main');\n            logger.debug('Z3 context initialized successfully (fallback)');\n            return { z3, ctx };\n          } catch (fallbackError) {\n            logger.error('Fallback Z3 initialization also failed:', fallbackError);\n          }\n        }\n\n        // For Node.js (tests), try direct import without asset loading\n        if (isNodeJSTest || typeof document === 'undefined') {\n          logger.debug('Retrying Z3 initialization for Node.js...');\n          try {\n            const { init } = await import('z3-solver');\n            const z3 = await init();\n            const ctx = new z3.Context('main');\n            logger.debug('Z3 context initialized successfully (Node.js)');\n            return { z3, ctx };\n          } catch (nodeError) {\n            logger.error('Node.js Z3 initialization also failed:', nodeError);\n          }\n        }\n\n        throw new Error(`initZ3 was not imported correctly. Please consult documentation on how to load Z3 in browser. Details: ${error.message}`);\n      }\n    })();\n  }\n  return z3InitPromise;\n}\n\n\n","export function collectVariables(ast, acc = new Set()) {\n  if (!ast) return acc;\n  if (ast.type === 'var') acc.add(ast.name);\n  if (ast.type === 'pair') {\n    collectVariables(ast.fst, acc);\n    collectVariables(ast.snd, acc);\n  }\n  if (ast.type === 'binop') {\n    collectVariables(ast.left, acc);\n    collectVariables(ast.right, acc);\n  }\n  if (ast.type === 'funcall' && ast.args) {\n    ast.args.forEach(arg => collectVariables(arg, acc));\n  }\n  return acc;\n}\n\nexport function buildZ3Expr(ctx, ast, sym) {\n  const { Int, String: Z3String } = ctx;\n  switch (ast.type) {\n    case 'int':\n      return Int.val(ast.value);\n    case 'string':\n      return Z3String.val(ast.value);\n    case 'pair':\n      // Represent pair as concatenated string for now, sufficient for evaluation context\n      const left = buildZ3Expr(ctx, ast.fst, sym);\n      const right = buildZ3Expr(ctx, ast.snd, sym);\n      return left.concat(Z3String.val(',')).concat(right);\n    case 'var':\n      return sym(ast.name);\n    case 'funcall': {\n      // Fast-path: length over a string literal without requiring String theory\n      if (ast.name === 'length' && ast.args && ast.args.length === 1 && ast.args[0]?.type === 'string') {\n        return Int.val((ast.args[0].value || '').length);\n      }\n      if (ast.name === 'concat' && ast.args && ast.args.length === 2) {\n        const arg1 = buildZ3Expr(ctx, ast.args[0], sym);\n        const arg2 = buildZ3Expr(ctx, ast.args[1], sym);\n        return arg1.concat(arg2);\n      }\n      if (ast.name === 'substring' && ast.args && ast.args.length === 3) {\n        const str = buildZ3Expr(ctx, ast.args[0], sym);\n        const start = buildZ3Expr(ctx, ast.args[1], sym);\n        const len = buildZ3Expr(ctx, ast.args[2], sym);\n        return str.substr(start, len);\n      }\n      if (ast.name === 'length' && ast.args && ast.args.length === 1) {\n        const str = buildZ3Expr(ctx, ast.args[0], sym);\n        return str.length();\n      }\n      throw new Error(`Unknown function '${ast.name}'`);\n    }\n    case 'binop': {\n      const l = buildZ3Expr(ctx, ast.left, sym);\n      const r = buildZ3Expr(ctx, ast.right, sym);\n      switch (ast.op) {\n        case '+': return l.add(r);\n        case '-': return l.sub(r);\n        case '*': return l.mul(r);\n        case '/': return l.div(r);\n        default: throw new Error(`Unknown operator '${ast.op}'`);\n      }\n    }\n    default:\n      throw new Error(`Unknown AST node '${ast.type}'`);\n  }\n}\n\n\n","import { getContext } from './context';\nimport { buildZ3Expr, collectVariables } from './builders';\n\nfunction evalPure(node) {\n  if (node.type === 'int') return node.value | 0;\n  const a = evalPure(node.left);\n  const b = evalPure(node.right);\n  switch (node.op) {\n    case '+': return (a + b) | 0;\n    case '-': return (a - b) | 0;\n    case '*': return (a * b) | 0;\n    case '/': {\n      if (b === 0) throw new Error('Division by zero');\n      return Math.trunc(a / b) | 0;\n    }\n    default: throw new Error(`Unknown operator '${node.op}'`);\n  }\n}\n\nexport async function evaluateArithmetic(ast) {\n  const pure = evalPure(ast);\n  const { ctx } = await getContext();\n  const { Int, Solver } = ctx;\n  function build(node) {\n    if (node.type === 'int') return Int.val(node.value);\n    const l = build(node.left);\n    const r = build(node.right);\n    switch (node.op) {\n      case '+': return l.add(r);\n      case '-': return l.sub(r);\n      case '*': return l.mul(r);\n      case '/': return l.div(r);\n      default: throw new Error(`Unknown operator '${node.op}'`);\n    }\n  }\n  const term = build(ast);\n  const resultSym = Int.const('result');\n  const s = new Solver();\n  s.add(resultSym.eq(term));\n  const status = await s.check();\n  if (String(status) !== 'sat') throw new Error('Expression is not satisfiable');\n  const m = s.model();\n  const z3Res = m.eval(resultSym);\n  const txt = z3Res.toString();\n  const asInt = Number.parseInt(txt, 10);\n  if (!Number.isNaN(asInt)) return asInt;\n  return pure;\n}\n\nexport function evaluateArithmeticWithBindings(ast, bindings) {\n  function evalNode(node) {\n    if (node.type === 'int') return node.value | 0;\n    if (node.type === 'string') return node.value;\n    if (node.type === 'list') return (node.elements || []).map(evalNode);\n    if (node.type === 'pair') return { __pair__: true, fst: evalNode(node.fst), snd: evalNode(node.snd) };\n    if (node.type === 'var') {\n      const v = bindings?.[node.name];\n      if (v === undefined) throw new Error(`Unbound variable '${node.name}'`);\n      return v;\n    }\n    if (node.type === 'funcall') {\n      if (node.name === 'concat' && node.args && node.args.length === 2) {\n        const a1 = evalNode(node.args[0]); const a2 = evalNode(node.args[1]);\n        if (typeof a1 === 'string' && typeof a2 === 'string') return a1 + a2;\n        if (Array.isArray(a1) && Array.isArray(a2)) return [...a1, ...a2];\n        throw new Error('concat requires two strings or two lists');\n      }\n      if (node.name === 'substring' && node.args && node.args.length === 3) {\n        const s = evalNode(node.args[0]); const st = evalNode(node.args[1]); const ln = evalNode(node.args[2]);\n        if (typeof s !== 'string' || typeof st !== 'number' || typeof ln !== 'number') throw new Error('substring requires string, int, int');\n        return s.substr(st, ln);\n      }\n      if (node.name === 'length' && node.args && node.args.length === 1) {\n        const arg = evalNode(node.args[0]);\n        if (typeof arg === 'string' || Array.isArray(arg)) return arg.length;\n        throw new Error('length requires string or list');\n      }\n      if (node.name === 'isSubstringOf' && node.args && node.args.length === 2) {\n        const sub = evalNode(node.args[0]); const str = evalNode(node.args[1]);\n        if (typeof sub !== 'string' || typeof str !== 'string') throw new Error('isSubstringOf requires two strings');\n        return str.includes(sub);\n      }\n      if (node.name === 'head' && node.args && node.args.length === 1) {\n        const list = evalNode(node.args[0]); if (!Array.isArray(list) || list.length === 0) throw new Error('head requires non-empty list');\n        return list[0];\n      }\n      if (node.name === 'tail' && node.args && node.args.length === 1) {\n        const list = evalNode(node.args[0]); if (!Array.isArray(list)) throw new Error('tail requires list');\n        return list.length === 0 ? [] : list.slice(1);\n      }\n      if (node.name === 'append' && node.args && node.args.length === 2) {\n        const list = evalNode(node.args[0]); const element = evalNode(node.args[1]); if (!Array.isArray(list)) throw new Error('append requires list');\n        return [...list, element];\n      }\n      if (node.name === 'sublist' && node.args && node.args.length === 3) {\n        const list = evalNode(node.args[0]); const st = evalNode(node.args[1]); const ln = evalNode(node.args[2]);\n        if (!Array.isArray(list) || typeof st !== 'number' || typeof ln !== 'number') throw new Error('sublist requires list, int, int');\n        return list.slice(st, st + ln);\n      }\n      if (node.name === 'isSublistOf' && node.args && node.args.length === 2) {\n        const sub = evalNode(node.args[0]); const list = evalNode(node.args[1]);\n        if (!Array.isArray(sub) || !Array.isArray(list)) throw new Error('isSublistOf requires two lists');\n        const n = sub.length; if (n === 0) return true;\n        for (let i = 0; i <= list.length - n; i++) {\n          let ok = true; for (let j = 0; j < n; j++) { if (list[i + j] !== sub[j]) { ok = false; break; } }\n          if (ok) return true;\n        }\n        return false;\n      }\n      if (node.name === 'fst' && node.args && node.args.length === 1) {\n        const arg = evalNode(node.args[0]);\n        if (!arg || typeof arg !== 'object' || arg.__pair__ !== true) throw new Error('fst requires pair');\n        return arg.fst;\n      }\n      if (node.name === 'snd' && node.args && node.args.length === 1) {\n        const arg = evalNode(node.args[0]);\n        if (!arg || typeof arg !== 'object' || arg.__pair__ !== true) throw new Error('snd requires pair');\n        return arg.snd;\n      }\n      throw new Error(`Unknown function '${node.name}'`);\n    }\n    if (node.type === 'binop') {\n      const a = evalNode(node.left); const b = evalNode(node.right);\n      if (typeof a !== 'number' || typeof b !== 'number') throw new Error('Arithmetic operands must be numbers');\n      switch (node.op) {\n        case '+': return (a + b) | 0;\n        case '-': return (a - b) | 0;\n        case '*': return (a * b) | 0;\n        case '/': if (b === 0) throw new Error('Division by zero'); return Math.trunc(a / b) | 0;\n        default: throw new Error(`Unknown operator '${node.op}'`);\n      }\n    }\n    throw new Error(`Unknown node type '${node.type}'`);\n  }\n  return evalNode(ast);\n}\n\nexport async function evaluateTermWithBindings(ast, bindings) {\n  // Mitigation 1: try JS reduction first for fully-ground terms\n  try {\n    const val = evaluateArithmeticWithBindings(ast, bindings || {});\n    if (typeof val === 'number') return val | 0;\n  } catch (_) {}\n\n  const { ctx } = await getContext();\n  const { Int, Solver, And, String: Z3String } = ctx;\n\n  // Infer string variables from usage contexts\n  const stringVars = new Set();\n  (function markStringVars(node) {\n    if (!node || typeof node !== 'object') return;\n    if (node.type === 'funcall') {\n      const name = node.name;\n      const args = Array.isArray(node.args) ? node.args : [];\n      if (name === 'concat') {\n        args.forEach(a => {\n          if (a && a.type === 'var') stringVars.add(a.name);\n          markStringVars(a);\n        });\n      } else if (name === 'substring' || name === 'length') {\n        const a0 = args[0];\n        if (a0 && a0.type === 'var') stringVars.add(a0.name);\n        args.forEach(a => markStringVars(a));\n      } else {\n        args.forEach(a => markStringVars(a));\n      }\n      return;\n    }\n    if (node.type === 'binop') { markStringVars(node.left); markStringVars(node.right); return; }\n    if (node.type === 'pair') { markStringVars(node.fst); markStringVars(node.snd); return; }\n  })(ast);\n\n  const allVars = Array.from(new Set(Array.from(collectVariables(ast))));\n  const intVars = allVars.filter(v => !stringVars.has(v));\n  const intSym = new Map(intVars.map((v) => [v, Int.const(v)]));\n  const strSym = new Map(stringVars.map((v) => [v, Z3String?.const ? Z3String.const(v) : null]));\n  const sym = (name) => (stringVars.has(name) ? strSym.get(name) : intSym.get(name));\n\n  const expr = buildZ3Expr(ctx, ast, sym);\n  const res = Int.const('result');\n  const s = new Solver();\n  try { s.set('timeout', 10000); } catch (_) {}\n  s.add(res.eq(expr));\n  if (bindings && typeof bindings === 'object') {\n    const eqs = [];\n    for (const [name, value] of Object.entries(bindings)) {\n      if (typeof value === 'number' && intSym.has(name)) eqs.push(intSym.get(name).eq(Int.val(value | 0)));\n      else if (typeof value === 'string' && strSym.has(name) && Z3String?.val) eqs.push(strSym.get(name).eq(Z3String.val(value)));\n    }\n    if (eqs.length) s.add(And(...eqs));\n  }\n  const status = await s.check();\n  if (String(status) !== 'sat') throw new Error('Unsatisfiable under bindings');\n  const m = s.model();\n  const v = m.eval(res, true);\n  const n = Number.parseInt(v.asString?.() ?? String(v), 10);\n  if (!Number.isNaN(n)) return n;\n  return Number.parseInt(String(v), 10);\n}\n\n\n","export function parsePredicate(expr, parseArithmetic) {\n  if (typeof expr !== 'string') throw new Error('Predicate must be a string');\n  const src = expr.trim();\n  const ops = ['>=', '<=', '==', '!=', '>', '<'];\n  let depth = 0;\n  let opIndex = -1;\n  let foundOp = null;\n\n  for (let i = 0; i < src.length; i++) {\n    const ch = src[i];\n    if (ch === '(') depth++;\n    else if (ch === ')') depth = Math.max(0, depth - 1);\n    if (depth !== 0) continue;\n    const two = src.slice(i, i + 2);\n    if (ops.includes(two)) {\n      foundOp = two;\n      opIndex = i;\n      break;\n    }\n    if (ops.includes(ch)) {\n      foundOp = ch;\n      opIndex = i;\n      break;\n    }\n  }\n\n  if (!foundOp || opIndex < 0) {\n    throw new Error('Predicate must contain a comparison operator');\n  }\n\n  const leftStr = src.slice(0, opIndex).trim();\n  const rightStr = src.slice(opIndex + foundOp.length).trim();\n  const leftAst = parseArithmetic(leftStr);\n  const rightAst = parseArithmetic(rightStr);\n  return { type: 'cmp', op: foundOp, left: leftAst, right: rightAst };\n}\n\nexport function parseBooleanExpr(input, parseArithmetic) {\n  if (typeof input !== 'string') {\n    throw new Error('Boolean expression must be a string');\n  }\n\n  const src = input.trim();\n  let i = 0;\n\n  const skipWs = () => {\n    while (i < src.length && /\\s/.test(src[i])) i++;\n  };\n\n  const isWordBoundaryAt = (pos, len) =>\n    (pos === 0 || /[^A-Za-z0-9_]/.test(src[pos - 1] || '')) &&\n    (pos + len === src.length || /[^A-Za-z0-9_]/.test(src[pos + len] || ''));\n\n  const startsWithWord = (word) => {\n    skipWs();\n    return (\n      src.slice(i, i + word.length).toLowerCase() === word &&\n      isWordBoundaryAt(i, word.length)\n    );\n  };\n\n  const parseIdentWithOptionalType = () => {\n    skipWs();\n    const start = i;\n    if (!/[A-Za-z_]/.test(src[i] || '')) {\n      throw new Error(`Expected identifier at position ${i}`);\n    }\n    i++;\n    while (i < src.length && /[A-Za-z0-9_]/.test(src[i])) i++;\n    const name = src.slice(start, i);\n    if (name && /^[A-Z]/.test(name)) {\n      throw new Error(`Variable names must start with lowercase letter, got '${name}'`);\n    }\n    const save = i;\n    skipWs();\n    if (src[i] === ':') {\n      i++;\n      skipWs();\n      const tStart = i;\n      while (i < src.length && /[A-Za-z]/.test(src[i])) i++;\n      const tWord = src.slice(tStart, i).toLowerCase();\n      if (tWord === 'int' || tWord === 'bool' || tWord === 'pair') {\n        return { name, varType: tWord };\n      }\n      i = save;\n      return { name };\n    }\n    return { name };\n  };\n\n  const parseAnyTermString = (s) => {\n    const term = String(s || '').trim();\n    if (/^true$/i.test(term) || term === 'T') return { type: 'boolLit', value: true };\n    if (/^false$/i.test(term) || term === 'F') return { type: 'boolLit', value: false };\n    if (/^-?\\d+$/.test(term)) return { type: 'int', value: parseInt(term, 10) };\n\n    if (term.startsWith('(') && term.endsWith(')')) {\n      const inner = term.slice(1, -1).trim();\n      let depth = 0;\n      let splitAt = -1;\n      for (let k = 0; k < inner.length; k++) {\n        const ch = inner[k];\n        if (ch === '(') depth++;\n        else if (ch === ')') depth = Math.max(0, depth - 1);\n        else if (ch === ',' && depth === 0) {\n          splitAt = k;\n          break;\n        }\n      }\n      if (splitAt >= 0) {\n        const leftStr = inner.slice(0, splitAt).trim();\n        const rightStr = inner.slice(splitAt + 1).trim();\n        if (leftStr.length && rightStr.length) {\n          return {\n            type: 'pairLit',\n            fst: parseAnyTermString(leftStr),\n            snd: parseAnyTermString(rightStr),\n          };\n        }\n      }\n    }\n\n    try {\n      if (typeof parseArithmetic === 'function') {\n        return parseArithmetic(term);\n      }\n    } catch (_) {}\n\n    const m = term.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([A-Za-z]+))?$/);\n    if (!m) throw new Error(`Unrecognized term '${term}'`);\n    const name = m[1];\n    if (name && /^[A-Z]/.test(name)) {\n      throw new Error(`Variable names must start with lowercase letter, got '${name}'`);\n    }\n    const tWord = (m[2] || '').toLowerCase();\n    if (tWord === 'bool') return { type: 'boolVar', name, varType: 'bool' };\n    if (tWord === 'pair') return { type: 'pairVar', name, varType: 'pair' };\n    return { type: 'var', name };\n  };\n\n  const parseBoolPrimary = () => {\n    skipWs();\n    if (i >= src.length) throw new Error('Unexpected end');\n\n    if (src[i] === 'T' && isWordBoundaryAt(i, 1)) {\n      i += 1;\n      return { type: 'boolLit', value: true };\n    }\n    if (src[i] === 'F' && isWordBoundaryAt(i, 1)) {\n      i += 1;\n      return { type: 'boolLit', value: false };\n    }\n    if (startsWithWord('true')) {\n      i += 4;\n      return { type: 'boolLit', value: true };\n    }\n    if (startsWithWord('false')) {\n      i += 5;\n      return { type: 'boolLit', value: false };\n    }\n\n    if (src.slice(i).startsWith('isSubstringOf')) {\n      i += 'isSubstringOf'.length;\n      skipWs();\n      if (src[i] !== '(') throw new Error(`Expected '('`);\n      let startArgs = i + 1;\n      let d = 1;\n      i++;\n      for (; i < src.length && d > 0; i++) {\n        const ch = src[i];\n        if (ch === '(') d++;\n        else if (ch === ')') d--;\n      }\n      if (d !== 0) throw new Error('Unterminated isSubstringOf arguments');\n      const inside = src.slice(startArgs, i - 1).trim();\n      let depth = 0;\n      let cur = '';\n      const parts = [];\n      for (let k = 0; k < inside.length; k++) {\n        const ch = inside[k];\n        if (ch === '(') {\n          depth++;\n          cur += ch;\n          continue;\n        }\n        if (ch === ')') {\n          depth = Math.max(0, depth - 1);\n          cur += ch;\n          continue;\n        }\n        if (ch === ',' && depth === 0) {\n          parts.push(cur.trim());\n          cur = '';\n          continue;\n        }\n        cur += ch;\n      }\n      if (cur.trim().length) parts.push(cur.trim());\n      if (parts.length !== 2) throw new Error('isSubstringOf expects two arguments');\n      const a0 = parseArithmetic(parts[0]);\n      const a1 = parseArithmetic(parts[1]);\n      return { type: 'boolFuncall', name: 'isSubstringOf', args: [a0, a1] };\n    }\n\n    const ops = ['>=', '<=', '==', '!=', '>', '<'];\n    let depth = 0;\n    let opIndex = -1;\n    let foundOp = null;\n\n    for (let j = i; j < src.length; j++) {\n      const ch = src[j];\n      if (ch === '(') depth++;\n      else if (ch === ')') depth = Math.max(0, depth - 1);\n      if (depth !== 0) continue;\n\n      if (src.slice(j, j + 3) === '<->') {\n        j += 2;\n        continue;\n      }\n      if (src.slice(j, j + 2) === '->') {\n        j += 1;\n        continue;\n      }\n\n      const two = src.slice(j, j + 2);\n      if (ops.includes(two)) {\n        foundOp = two;\n        opIndex = j;\n        break;\n      }\n      if (ops.includes(ch)) {\n        foundOp = ch;\n        opIndex = j;\n        break;\n      }\n    }\n\n    if (foundOp && opIndex >= 0) {\n      const leftStr = src.slice(i, opIndex).trim();\n      const afterOp = opIndex + foundOp.length;\n      let end = src.length;\n      depth = 0;\n\n      const wordBoundary = (pos, len) =>\n        (pos === 0 || /[^A-Za-z0-9_]/.test(src[pos - 1] || '')) &&\n        (pos + len === src.length || /[^A-Za-z0-9_]/.test(src[pos + len] || ''));\n\n      const isTopLevelLogicAt = (pos) => {\n        const rest = src.slice(pos);\n        const LOGIC_SYMS = ['&&', '||', '^', '->', '<->'];\n        const LOGIC_WORDS = ['and', 'or', 'xor', 'implies', 'iff'];\n        for (const sym of LOGIC_SYMS) {\n          if (rest.startsWith(sym)) return true;\n        }\n        for (const word of LOGIC_WORDS) {\n          if (rest.toLowerCase().startsWith(word) && wordBoundary(pos, word.length)) {\n            return true;\n          }\n        }\n        return false;\n      };\n\n      for (let k = afterOp; k < src.length; k++) {\n        const ch2 = src[k];\n        if (ch2 === '(') {\n          depth++;\n          continue;\n        }\n        if (ch2 === ')') {\n          if (depth === 0) {\n            end = k;\n            break;\n          }\n          depth = Math.max(0, depth - 1);\n          continue;\n        }\n        if (depth !== 0) continue;\n        if (isTopLevelLogicAt(k)) {\n          end = k;\n          break;\n        }\n      }\n\n      const rightStr = src.slice(afterOp, end).trim();\n      const leftAst = parseAnyTermString(leftStr);\n      const rightAst = parseAnyTermString(rightStr);\n      i = end;\n      return { type: 'cmp', op: foundOp, left: leftAst, right: rightAst };\n    }\n\n    if (src[i] === '(') {\n      i++;\n      const node = parseIff();\n      skipWs();\n      if (src[i] !== ')') throw new Error(`Expected ')' at ${i}`);\n      i++;\n      return node;\n    }\n\n    const { name, varType } = parseIdentWithOptionalType();\n    return varType ? { type: 'boolVar', name, varType } : { type: 'boolVar', name };\n  };\n\n  const OP_WORDS = {\n    not: ['not'],\n    and: ['and'],\n    xor: ['xor'],\n    or: ['or'],\n    implies: ['implies'],\n    iff: ['iff'],\n  };\n  const OP_SYMS = {\n    not: ['!'],\n    and: ['&&'],\n    xor: ['^'],\n    or: ['||'],\n    implies: ['->'],\n    iff: ['<->'],\n  };\n\n  const tryConsumeSymbolOrWord = (symbols, words) => {\n    skipWs();\n    for (const s of symbols) {\n      if (src.slice(i, i + s.length) === s) {\n        i += s.length;\n        return true;\n      }\n    }\n    for (const w of words) {\n      if (src.slice(i, i + w.length).toLowerCase() === w && isWordBoundaryAt(i, w.length)) {\n        i += w.length;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const parseNot = () => {\n    skipWs();\n    if (tryConsumeSymbolOrWord(OP_SYMS.not, OP_WORDS.not)) {\n      const expr = parseNot();\n      return { type: 'not', expr };\n    }\n    return parseBoolPrimary();\n  };\n\n  const parseAnd = () => {\n    let node = parseNot();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.and, OP_WORDS.and)) {\n        const right = parseNot();\n        node = { type: 'and', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseXor = () => {\n    let node = parseAnd();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.xor, OP_WORDS.xor)) {\n        const right = parseAnd();\n        node = { type: 'xor', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseOr = () => {\n    let node = parseXor();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.or, OP_WORDS.or)) {\n        const right = parseXor();\n        node = { type: 'or', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseImplies = () => {\n    let node = parseOr();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.implies, OP_WORDS.implies)) {\n        const right = parseOr();\n        node = { type: 'implies', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseIff = () => {\n    let node = parseImplies();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.iff, OP_WORDS.iff)) {\n        const right = parseImplies();\n        node = { type: 'iff', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const ast = parseIff();\n  skipWs();\n  if (i !== src.length) {\n    throw new Error(`Unexpected token '${src[i]}' at position ${i}`);\n  }\n  return ast;\n}\n\n","import { evaluateArithmeticWithBindings } from './eval-arith';\n\nexport function evaluateBooleanWithBindings(ast, bindings, parseArithmetic) {\n  const toBool = (value) => {\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') return value !== 0;\n    if (value && typeof value === 'object' && value.__pair__) return true;\n    throw new Error('Non-bool binding in bool expression');\n  };\n\n  const tryEvalAnyTerm = (node) => {\n    if (!node) throw new Error('Invalid term');\n    if (node.type === 'int' || node.type === 'bin' || node.type === 'var') {\n      try {\n        return evaluateArithmeticWithBindings(node, bindings);\n      } catch (_) {}\n      if (node.type === 'var' && typeof bindings?.[node.name] !== 'undefined') {\n        return bindings[node.name];\n      }\n    }\n    if (node.type === 'boolLit') return !!node.value;\n    if (node.type === 'boolVar') return !!(bindings?.[node.name]);\n    if (node.type === 'pairVar') return bindings?.[node.name];\n    if (node.type === 'pairLit') {\n      return {\n        __pair__: true,\n        fst: tryEvalAnyTerm(node.fst),\n        snd: tryEvalAnyTerm(node.snd),\n      };\n    }\n    return evaluateArithmeticWithBindings(node, bindings);\n  };\n\n  const evalBool = (node) => {\n    switch (node.type) {\n      case 'boolLit':\n        return !!node.value;\n      case 'boolVar':\n        return toBool(bindings?.[node.name]);\n      case 'boolFuncall': {\n        if (node.name === 'isSubstringOf' && node.args && node.args.length === 2) {\n          const sub = evaluateArithmeticWithBindings(node.args[0], bindings || {});\n          const str = evaluateArithmeticWithBindings(node.args[1], bindings || {});\n          if (typeof sub !== 'string' || typeof str !== 'string') {\n            throw new Error('isSubstringOf requires two string arguments');\n          }\n          return str.includes(sub);\n        }\n        throw new Error(`Unknown boolean function '${node.name}'`);\n      }\n      case 'not':\n        return !evalBool(node.expr);\n      case 'and':\n        return evalBool(node.left) && evalBool(node.right);\n      case 'or':\n        return evalBool(node.left) || evalBool(node.right);\n      case 'xor': {\n        const left = evalBool(node.left);\n        const right = evalBool(node.right);\n        return (left && !right) || (!left && right);\n      }\n      case 'implies': {\n        const left = evalBool(node.left);\n        const right = evalBool(node.right);\n        return (!left) || right;\n      }\n      case 'iff': {\n        const left = evalBool(node.left);\n        const right = evalBool(node.right);\n        return left === right;\n      }\n      case 'cmp': {\n        const left = tryEvalAnyTerm(node.left);\n        const right = tryEvalAnyTerm(node.right);\n        const eq = (a, b) => {\n          if (\n            a &&\n            typeof a === 'object' &&\n            a.__pair__ &&\n            b &&\n            typeof b === 'object' &&\n            b.__pair__\n          ) {\n            return eq(a.fst, b.fst) && eq(a.snd, b.snd);\n          }\n          return a === b;\n        };\n        switch (node.op) {\n          case '==':\n            return eq(left, right);\n          case '!=':\n            return !eq(left, right);\n          case '<':\n            return left < right;\n          case '<=':\n            return left <= right;\n          case '>':\n            return left > right;\n          case '>=':\n            return left >= right;\n          default:\n            return false;\n        }\n      }\n      default:\n        throw new Error(`Unknown bool AST node '${node.type}'`);\n    }\n  };\n\n  return evalBool(ast);\n}\n\n","import { getContext } from './context';\nimport { buildZ3Expr, collectVariables } from './builders';\nimport { evaluateArithmeticWithBindings } from './eval-arith';\nimport { evaluateBooleanWithBindings } from './booleanEvaluator';\nimport { parseBooleanExpr } from './booleanParser';\n\nexport async function evaluateBooleanPredicate(\n  boolAstOrString,\n  bindings,\n  parseArithmetic\n) {\n  const { ctx } = await getContext();\n  const { Int, Bool, Solver, And, Not, Or } = ctx;\n  const ast =\n    typeof boolAstOrString === 'string'\n      ? parseBooleanExpr(boolAstOrString, parseArithmetic)\n      : boolAstOrString;\n\n  const intVars = new Set();\n  const boolVars = new Set();\n\n  const collect = (node) => {\n    if (!node) return;\n    switch (node.type) {\n      case 'boolVar':\n        boolVars.add(node.name);\n        break;\n      case 'and':\n      case 'or':\n        collect(node.left);\n        collect(node.right);\n        break;\n      case 'not':\n        collect(node.expr);\n        break;\n      case 'cmp': {\n        const addArith = (t) => {\n          if (!t) return;\n          if (t.type === 'var') intVars.add(t.name);\n          if (t.type === 'bin') {\n            addArith(t.left);\n            addArith(t.right);\n          }\n        };\n        addArith(node.left);\n        addArith(node.right);\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  collect(ast);\n\n  const intSym = new Map(Array.from(intVars).map((v) => [v, Int.const(v)]));\n  const boolSym = new Map(Array.from(boolVars).map((v) => [v, Bool.const(v)]));\n\n  const buildBool = (node) => {\n    switch (node.type) {\n      case 'boolLit':\n        return node.value ? Bool.val(true) : Bool.val(false);\n      case 'boolVar':\n        return boolSym.get(node.name);\n      case 'boolFuncall': {\n        if (node.name === 'isSubstringOf' && node.args && node.args.length === 2) {\n          try {\n            const sub = evaluateArithmeticWithBindings(node.args[0], bindings || {});\n            const str = evaluateArithmeticWithBindings(node.args[1], bindings || {});\n            if (typeof sub !== 'string' || typeof str !== 'string') {\n              throw new Error('isSubstringOf requires two string arguments');\n            }\n            return str.includes(sub) ? Bool.val(true) : Bool.val(false);\n          } catch (_) {\n            try {\n              const str1 = buildZ3Expr(ctx, node.args[1], (n) => intSym.get(n));\n              const sub = buildZ3Expr(ctx, node.args[0], (n) => intSym.get(n));\n              return str1.contains(sub);\n            } catch (error) {\n              return Bool.val(false);\n            }\n          }\n        }\n        throw new Error(`Unknown boolean function '${node.name}'`);\n      }\n      case 'not':\n        return Not(buildBool(node.expr));\n      case 'and':\n        return And(buildBool(node.left), buildBool(node.right));\n      case 'or':\n        return Or(buildBool(node.left), buildBool(node.right));\n      case 'cmp': {\n        const canBuildIntTerm = (t) =>\n          t && (t.type === 'int' || t.type === 'var' || t.type === 'bin' || t.type === 'binop');\n        if (canBuildIntTerm(node.left) && canBuildIntTerm(node.right)) {\n          const buildArith = (term) => {\n            if (term.type === 'int') return Int.val(term.value);\n            if (term.type === 'var') return intSym.get(term.name);\n            if (term.type === 'bin' || term.type === 'binop') {\n              const left = buildArith(term.left);\n              const right = buildArith(term.right);\n              switch (term.op) {\n                case '+':\n                  return left.add(right);\n                case '-':\n                  return left.sub(right);\n                case '*':\n                  return left.mul(right);\n                case '/':\n                  return left.div(right);\n                default:\n                  throw new Error('Unknown arithmetic operator');\n              }\n            }\n            throw new Error('Unknown arithmetic AST in bool comparison');\n          };\n          const left = buildArith(node.left);\n          const right = buildArith(node.right);\n          switch (node.op) {\n            case '==':\n              return left.eq(right);\n            case '!=':\n              return Not(left.eq(right));\n            case '<':\n              return left.lt(right);\n            case '<=':\n              return left.le(right);\n            case '>':\n              return left.gt(right);\n            case '>=':\n              return left.ge(right);\n            default:\n              throw new Error(`Unsupported predicate operator '${node.op}'`);\n          }\n        }\n        const pure = evaluateBooleanWithBindings(\n          { type: 'cmp', op: node.op, left: node.left, right: node.right },\n          bindings || {},\n          parseArithmetic\n        );\n        return pure ? Bool.val(true) : Bool.val(false);\n      }\n      default:\n        throw new Error(`Unknown bool AST node '${node.type}'`);\n    }\n  };\n\n  const solver = new Solver();\n  try {\n    let timeout = 10000;\n    try {\n      if (\n        typeof window !== 'undefined' &&\n        window.__Z3_SETTINGS__ &&\n        typeof window.__Z3_SETTINGS__.solverTimeoutMs === 'number'\n      ) {\n        timeout = window.__Z3_SETTINGS__.solverTimeoutMs | 0;\n      }\n    } catch (_) {}\n    solver.set('timeout', timeout);\n  } catch (_) {}\n\n  if (bindings && typeof bindings === 'object') {\n    const equalities = [];\n    for (const [name, value] of Object.entries(bindings)) {\n      if (intSym.has(name) && typeof value === 'number') {\n        equalities.push(intSym.get(name).eq(Int.val(value | 0)));\n      } else if (boolSym.has(name) && typeof value === 'boolean') {\n        equalities.push(boolSym.get(name).eq(value ? Bool.val(true) : Bool.val(false)));\n      }\n    }\n    if (equalities.length) {\n      solver.add(And(...equalities));\n    }\n  }\n\n  solver.add(buildBool(ast));\n  const result = await solver.check();\n  return String(result) === 'sat';\n}\n\n","export { getContext } from './z3/context.js';\nexport { buildZ3Expr, collectVariables } from './z3/builders.js';\nexport { evaluateArithmetic, evaluateArithmeticWithBindings, evaluateTermWithBindings } from './z3/eval-arith.js';\nexport { parseBooleanExpr, evaluateBooleanWithBindings, evaluateBooleanPredicate, parsePredicate, solveInequality } from './z3/eval-bool.js';\n\n// Use direct Z3 import to avoid worker WASM loading issues\nexport async function solveEquation(lhs, rhs, maxModels = 5) {\n  const { solveEquation: directSolveEquation } = await import('./z3/eval-bool.js');\n  return await directSolveEquation(lhs, rhs, maxModels);\n}\n\n// Note: keep evaluateArithmeticWithBindings synchronous (re-exported above) to\n// match existing tests and code paths; ADT uses `await` safely on a sync value.\n\n// Keep evaluateAction available as a convenience export for callers that depend on it.\n// This uses the parseArithmetic from arith-parser and the shared arithmetic evaluator.\nimport { evaluateArithmeticWithBindings as _evalArithWithBindings } from './z3/eval-arith.js';\nimport { evaluateBooleanPredicate as _evaluateBooleanPredicate } from './z3/eval-bool.js';\nimport { parseArithmetic as _parseArithmetic } from './arith-parser';\n\nexport function evaluateAction(actionString, bindings, parseArithmetic = _parseArithmetic) {\n  if (!actionString || typeof actionString !== 'string') return {};\n  const result = {};\n  const parts = actionString.split(',');\n  for (const part of parts) {\n    const eqIdx = part.indexOf('=');\n    if (eqIdx === -1) continue;\n    const left = part.slice(0, eqIdx).trim();\n    const right = part.slice(eqIdx + 1).trim();\n    if (!left) continue;\n    const ast = parseArithmetic(right);\n    result[left] = _evalArithWithBindings(ast, bindings);\n  }\n  return result;\n}\n\n// Backwards-compatibility alias for callers still importing evaluatePredicate\nexport function evaluatePredicate(boolAstOrString, bindings, parseArithmetic = _parseArithmetic) {\n  return _evaluateBooleanPredicate(boolAstOrString, bindings, parseArithmetic);\n}\n","let workerPool = [];\nlet nextId = 1;\nconst pending = new Map();\nlet roundRobinIndex = 0;\nlet idleTimer = null;\n\nconst workerSupported = typeof Worker !== 'undefined';\n\n// Check if SharedArrayBuffer is available (required for Z3 workers)\nconst sharedArrayBufferSupported = typeof SharedArrayBuffer !== 'undefined';\n\nconst z3Config = {\n  poolSize: 0,\n  idleTimeoutMs: 300000,\n  prewarmOnAlgebraicMode: true,\n  solverTimeoutMs: 10000,\n};\n\nfunction publishConfig() {\n  try {\n    if (typeof globalThis !== 'undefined') {\n      const target = globalThis;\n      target.__Z3_SETTINGS__ = { ...(target.__Z3_SETTINGS__ || {}), ...z3Config };\n    }\n  } catch (_) {}\n}\n\nfunction normalizePoolSize(value) {\n  return Math.max(0, (Number.isFinite(value) ? value : 0) | 0);\n}\n\nexport function setZ3WorkerConfig(cfg = {}) {\n  if (typeof cfg.poolSize === 'number') z3Config.poolSize = normalizePoolSize(cfg.poolSize);\n  if (typeof cfg.idleTimeoutMs === 'number') z3Config.idleTimeoutMs = Math.max(1000, cfg.idleTimeoutMs | 0);\n  if (typeof cfg.prewarmOnAlgebraicMode === 'boolean') z3Config.prewarmOnAlgebraicMode = cfg.prewarmOnAlgebraicMode;\n  if (typeof cfg.solverTimeoutMs === 'number') z3Config.solverTimeoutMs = Math.max(0, cfg.solverTimeoutMs | 0);\n  ensurePoolCapacity();\n}\n\nfunction createWorker() {\n  if (!workerSupported) throw new Error('Z3 worker pool unavailable in this environment');\n  if (!sharedArrayBufferSupported) {\n    throw new Error('SharedArrayBuffer not available. COOP/COEP headers may not be set correctly.');\n  }\n  const w = new Worker(new URL('../workers/z3.worker.js', import.meta.url), { type: 'module' });\n  w.onerror = (err) => {\n    console.error('Z3 worker error:', err);\n  };\n  w.onmessage = ({ data }) => {\n    const { id, ok, result, error } = data || {};\n    const entry = pending.get(id);\n    if (!entry) return;\n    pending.delete(id);\n    ok ? entry.resolve(result) : entry.reject(new Error(error));\n    tickIdleTimer();\n  };\n  return w;\n}\n\nfunction ensurePoolCapacity() {\n  publishConfig();\n  if (!workerSupported) {\n    return;\n  }\n  const target = normalizePoolSize(z3Config.poolSize);\n  while (workerPool.length < target) {\n    workerPool.push(createWorker());\n  }\n  while (workerPool.length > target) {\n    const w = workerPool.pop();\n    try { w.terminate(); } catch (_) {}\n  }\n}\n\nfunction getWorker() {\n  if (!workerSupported) throw new Error('Z3 worker pool unavailable in this environment');\n  const target = normalizePoolSize(z3Config.poolSize);\n  if (target <= 0) throw new Error('Z3 worker pool disabled');\n  if (workerPool.length === 0) {\n    workerPool.push(createWorker());\n  }\n  const w = workerPool[roundRobinIndex % workerPool.length];\n  roundRobinIndex++;\n  return w;\n}\n\nfunction tickIdleTimer() {\n  if (!workerSupported) return;\n  if (z3Config.idleTimeoutMs <= 0) return;\n  if (idleTimer) clearTimeout(idleTimer);\n  idleTimer = setTimeout(() => {\n    const target = normalizePoolSize(z3Config.poolSize);\n    while (workerPool.length > target) {\n      const w = workerPool.pop();\n      try { w.terminate(); } catch (_) {}\n    }\n  }, z3Config.idleTimeoutMs);\n}\n\nfunction call(op, ...args) {\n  const w = getWorker();\n  const id = nextId++;\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => {\n      pending.delete(id);\n      reject(new Error(`Z3 worker operation \"${op}\" timed out after ${z3Config.solverTimeoutMs}ms`));\n    }, z3Config.solverTimeoutMs || 10000);\n    \n    pending.set(id, { \n      resolve: (result) => {\n        clearTimeout(timeout);\n        resolve(result);\n      }, \n      reject: (error) => {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n    \n    try {\n      w.postMessage({ id, op, args });\n    } catch (err) {\n      clearTimeout(timeout);\n      pending.delete(id);\n      reject(err);\n      return;\n    }\n    tickIdleTimer();\n  });\n}\n\nexport function getConfiguredPoolSize() {\n  return normalizePoolSize(z3Config.poolSize);\n}\n\nexport function isWorkerPoolEnabled() {\n  return workerSupported && sharedArrayBufferSupported && normalizePoolSize(z3Config.poolSize) > 0;\n}\n\nexport function isSharedArrayBufferAvailable() {\n  return sharedArrayBufferSupported;\n}\n\nexport const parseBooleanExpr = (s) => call('parseBooleanExpr', s);\nexport const evaluateBooleanPredicate = (astOrStr, env, _parseArithmeticIgnored) => call('evaluateBooleanPredicate', astOrStr, env);\nexport const evaluateArithmeticWithBindings = (astOrStr, env, _parseArithmeticIgnored) => call('evaluateArithmeticWithBindings', astOrStr, env);\nexport const evaluateAction = (text, env) => call('evaluateAction', text, env);\nexport const solveEquation = (l, r) => call('solveEquation', l, r);\nexport const solveInequality = (l, r, op) => call('solveInequality', l, r, op);\n\n\n","import * as z3Pool from '../../../utils/z3-remote.js';\nimport { evaluateBooleanPredicate as evaluateBooleanPredicateDirect } from '../../../utils/z3-arith.js';\n\nexport const evaluateBooleanPredicateWithPool = async (\n  guardAst,\n  env,\n  parseArithmeticFn\n) => {\n  try {\n    const poolEnabled = typeof z3Pool.isWorkerPoolEnabled === 'function'\n      ? z3Pool.isWorkerPoolEnabled()\n      : false;\n    if (poolEnabled && typeof z3Pool.evaluateBooleanPredicate === 'function') {\n      try {\n        return await z3Pool.evaluateBooleanPredicate(\n          guardAst,\n          env,\n          parseArithmeticFn\n        );\n      } catch (_) {\n        // fall through to inline evaluation\n      }\n    }\n  } catch (_) {}\n  return evaluateBooleanPredicateDirect(guardAst, env, parseArithmeticFn);\n};\n\nexport const deepCloneNet = (net) =>\n  JSON.parse(JSON.stringify(net || { places: [], transitions: [], arcs: [] }));\n\nexport const getUnboundBooleanGuardVars = (ast, env) => {\n  const names = new Set();\n\n  const collect = (node) => {\n    if (!node) return;\n    switch (node.type) {\n      case 'boolVar':\n      case 'pairVar':\n        names.add(node.name);\n        break;\n      case 'and':\n      case 'or':\n        collect(node.left);\n        collect(node.right);\n        break;\n      case 'not':\n        collect(node.expr);\n        break;\n      case 'cmp':\n        collectArith(node.left);\n        collectArith(node.right);\n        break;\n      default:\n        break;\n    }\n  };\n\n  const collectArith = (arithAst) => {\n    if (!arithAst) return;\n    if (arithAst.type === 'var' || arithAst.type === 'boolVar' || arithAst.type === 'pairVar') {\n      names.add(arithAst.name);\n    } else if (arithAst.type === 'bin') {\n      collectArith(arithAst.left);\n      collectArith(arithAst.right);\n    } else if (arithAst.type === 'pairLit') {\n      collectArith(arithAst.fst);\n      collectArith(arithAst.snd);\n    }\n  };\n\n  collect(ast);\n  const bound = new Set(Object.keys(env || {}));\n  return Array.from(names).filter((name) => !bound.has(name));\n};\n\nexport const computeCacheSignature = (net) => {\n  try {\n    const transitions = Array.isArray(net?.transitions) ? net.transitions.slice() : [];\n    const arcs = Array.isArray(net?.arcs) ? net.arcs.slice() : [];\n    transitions.sort((a, b) => String(a.id).localeCompare(String(b.id)));\n    arcs.sort((a, b) => String(a.id).localeCompare(String(b.id)));\n    const tSig = transitions\n      .map((t) => `${t.id}|g:${String(t.guard || '')}|a:${String(t.action || '')}`)\n      .join(';');\n    const aSig = arcs\n      .map((a) =>\n        `${a.id}|b:${\n          Array.isArray(a.bindings)\n            ? a.bindings.join(',')\n            : a.binding\n            ? String(a.binding)\n            : ''\n        }`\n      )\n      .join(';');\n    return `${tSig}||${aSig}`;\n  } catch (_) {\n    return String(Math.random());\n  }\n};\n\n","/**\n * Algebraic Petri Net Simulator (ints)\n * Pure JS implementation using Z3 for guards/bindings evaluation.\n * Extends BaseSimulator for consistent interface.\n */\n\nimport { BaseSimulator } from './BaseSimulator.js';\nimport { parseArithmetic, parsePattern, matchPattern } from '../../utils/arith-parser';\nimport { getTokensForPlace } from '../../utils/token-utils';\nimport { evaluatePatternLiteral } from '../../utils/ast-eval';\nimport { ensureOutputBindingsTypeCompatible } from './type-check';\nimport { allowedOps } from './ops/registry';\nimport { buildGuardCache, buildBindingCache } from './cache';\nimport { findSatisfyingAssignment } from './assignment';\nimport { consumeTokens, produceTokens } from './token-io';\nimport { extractVariablesFromPattern, extractVariablesFromExpression, checkForUnboundVariables as checkUnbound } from './guard-utils';\nimport { getCurrentStateNormalized } from './state-normalizer';\nimport {\n  evaluateAction,\n  evaluateArithmeticWithBindings,\n  evaluatePredicate,\n  solveEquation,\n  solveInequality,\n  parsePredicate,\n  // Boolean support\n  parseBooleanExpr,\n  evaluateBooleanWithBindings,\n} from '../../utils/z3-arith.js';\nimport * as z3Pool from '../../utils/z3-remote.js';\nimport {\n  computeCacheSignature,\n  deepCloneNet,\n  evaluateBooleanPredicateWithPool,\n  getUnboundBooleanGuardVars,\n} from './algebraic/algebraicHelpers.js';\nimport { logger } from '../../utils/logger.js';\n\nexport class AlgebraicSimulator extends BaseSimulator {\n  constructor() {\n    super();\n    this.lastEnabledTransitions = [];\n    this.cache = {\n      guardAstByTransition: new Map(),\n      bindingAstsByArc: new Map(),\n    };\n    this._cacheSignature = null;\n    this._config = { maxTokensPerPlace: Infinity };\n    this._enabledCache = new Map(); // transitionId -> boolean (enabled state)\n  }\n\n  /**\n   * Get simulator type\n   */\n  getType() {\n    return 'algebraic';\n  }\n\n  async initializeSpecific(petriNet, options = {}) {\n    // Clear all cached state on initialization\n    this.lastEnabledTransitions = [];\n    this._enabledCache.clear();\n    this._cacheSignature = null;\n    \n    this.petriNet = deepCloneNet(petriNet);\n    if (options && typeof options.maxTokensPerPlace === 'number' && options.maxTokensPerPlace >= 0) {\n      this._config.maxTokensPerPlace = options.maxTokensPerPlace | 0;\n    } else {\n      this._config.maxTokensPerPlace = Infinity;\n    }\n    await this.buildCaches();\n    await this.checkTransitionStateChanges();\n  }\n\n  async buildCaches() {\n    this.cache.guardAstByTransition.clear();\n    this.cache.bindingAstsByArc.clear();\n\n    this.cache.guardAstByTransition = buildGuardCache(\n      this.petriNet,\n      parseArithmetic,\n      parseBooleanExpr,\n      parsePredicate\n    );\n\n    this.cache.bindingAstsByArc = buildBindingCache(\n      this.petriNet,\n      parsePattern,\n      parseArithmetic,\n      parseBooleanExpr,\n      allowedOps\n    );\n\n    this._cacheSignature = computeCacheSignature(this.petriNet);\n  }\n\n  // Eventing is now handled via BaseSimulator helpers and shared SimulationEventBus\n\n  getStatus() {\n    return {\n      isInitialized: this.isInitialized,\n      hasPyodide: false,\n      hasSimulator: true,\n      hasPetriNet: !!this.petriNet,\n      simulationMode: this.simulationMode,\n      petriNetSize: this.petriNet ? {\n        places: this.petriNet.places?.length || 0,\n        transitions: this.petriNet.transitions?.length || 0,\n        arcs: this.petriNet.arcs?.length || 0,\n      } : null,\n    };\n  }\n\n  async setSimulationMode(mode) {\n    if (mode === 'single' || mode === 'maximal') {\n      this.simulationMode = mode;\n    } else {\n      throw new Error(\"Mode must be 'single' or 'maximal'\");\n    }\n  }\n\n  // Internal: verify that output arc bindings with explicit type annotations\n  // are compatible with the current environment of bound variables.\n  _outputBindingsTypeCompatible(transitionId, env) {\n    return ensureOutputBindingsTypeCompatible(this.petriNet, this.cache, transitionId, env);\n  }\n\n  /**\n   * Invalidate enabled cache for transitions connected to the given places.\n   * @param {Set<string>} changedPlaces - Set of place IDs that changed\n   */\n  _invalidateEnabledCache(changedPlaces) {\n    if (!changedPlaces || changedPlaces.size === 0) {\n      return;\n    }\n    const arcs = this.petriNet.arcs || [];\n    for (const arc of arcs) {\n      // Check if this arc comes from a changed place to a transition\n      const placeId = arc.sourceId || arc.source;\n      const isPlaceToTransition = (arc.type === 'place-to-transition') || (arc.sourceType === 'place');\n      if (isPlaceToTransition && changedPlaces.has(placeId)) {\n        const tId = String(arc.targetId || arc.target);\n        this._enabledCache.delete(tId);\n      }\n    }\n  }\n\n  /**\n   * Clear the entire enabled cache (e.g., on net update or reset).\n   */\n  _clearEnabledCache() {\n    this._enabledCache.clear();\n  }\n\n  async updateSpecific(petriNet) {\n    // Rebuild caches if guards or bindings changed\n    const incomingSignature = computeCacheSignature(petriNet);\n    const shouldRebuildCaches = incomingSignature !== this._cacheSignature;\n    this.petriNet = deepCloneNet(petriNet);\n    if (shouldRebuildCaches) {\n      await this.buildCaches();\n    }\n    // Clear enabled cache since net structure may have changed\n    this._clearEnabledCache();\n    await this.checkTransitionStateChanges();\n  }\n\n  async getEnabledTransitionsSpecific() {\n    const transitions = Array.isArray(this.petriNet.transitions) ? this.petriNet.transitions : [];\n    if (transitions.length === 0) return [];\n\n    // Separate cached and uncached transitions\n    const toCheck = [];\n    const toCheckIndices = [];\n    for (let i = 0; i < transitions.length; i++) {\n      const tId = String(transitions[i].id);\n      if (!this._enabledCache.has(tId)) {\n        toCheck.push(transitions[i]);\n        toCheckIndices.push(i);\n      }\n    }\n\n    // If we have transitions to check, evaluate them in parallel\n    if (toCheck.length > 0) {\n      const poolSize = (typeof z3Pool.getConfiguredPoolSize === 'function')\n        ? Number(z3Pool.getConfiguredPoolSize() || 0)\n        : 0;\n      const concurrency = Math.max(1, Math.min(toCheck.length, poolSize > 0 ? poolSize : 1));\n\n      if (concurrency <= 1) {\n        // Sequential evaluation for uncached transitions\n        for (const t of toCheck) {\n          try {\n            const ok = await this.isTransitionEnabled(t.id);\n            this._enabledCache.set(String(t.id), ok);\n          } catch (err) {\n            if (process.env.NODE_ENV !== 'production') {\n              console.warn('Failed to evaluate transition', t?.id, err);\n            }\n            this._enabledCache.set(String(t.id), false);\n          }\n        }\n      } else {\n        // Parallel evaluation for uncached transitions\n        const flags = new Array(toCheck.length).fill(false);\n        let nextIndex = 0;\n        const runSlot = async () => {\n          while (true) {\n            const idx = nextIndex++;\n            if (idx >= toCheck.length) break;\n            const t = toCheck[idx];\n            try {\n              const ok = await this.isTransitionEnabled(t.id);\n              flags[idx] = ok;\n            } catch (err) {\n              if (process.env.NODE_ENV !== 'production') {\n                console.warn('Failed to evaluate transition', t?.id, err);\n              }\n            }\n          }\n        };\n\n        const workers = Array.from({ length: concurrency }, () => runSlot());\n        await Promise.all(workers);\n\n        // Update cache with results\n        for (let i = 0; i < toCheck.length; i++) {\n          this._enabledCache.set(String(toCheck[i].id), flags[i]);\n        }\n      }\n    }\n\n    // Collect all enabled transitions from cache\n    const enabled = [];\n    for (const t of transitions) {\n      const tId = String(t.id);\n      if (this._enabledCache.get(tId) === true) {\n        enabled.push(tId);\n      }\n    }\n    return enabled;\n  }\n\n  async checkForUnboundVariables(transitionId, inputArcs) {\n    return checkUnbound(\n      this.petriNet,\n      this.cache.bindingAstsByArc,\n      this.cache.guardAstByTransition,\n      transitionId,\n      inputArcs\n    );\n  }\n\n  // Deprecated helpers retained for compatibility if referenced externally\n  extractVariablesFromPattern(ast) { return extractVariablesFromPattern(ast); }\n  extractVariablesFromExpression(ast) { return extractVariablesFromExpression(ast); }\n\n  async isTransitionEnabled(transitionId) {\n    if (!this.isInitialized) return false;\n    const t = (this.petriNet.transitions || []).find(x => x.id === transitionId);\n    if (!t) return false;\n\n    // Gather input arcs (place -> transition)\n    const inputArcs = (this.petriNet.arcs || []).filter(a => (a.targetId === transitionId || a.target === transitionId) && (a.sourceType === 'place' || !a.sourceType));\n    if (inputArcs.length === 0) return true; // degenerate: no inputs\n\n    // Check for unbound variables in guard and output arcs\n    const hasUnboundVariables = await this.checkForUnboundVariables(transitionId, inputArcs);\n    if (hasUnboundVariables) {\n      logger.debug('Transition disabled due to unbound variables:', transitionId);\n      return false;\n    }\n\n    const guardAst = this.cache.guardAstByTransition.get(transitionId);\n    const placesById = Object.fromEntries((this.petriNet.places || []).map(p => [p.id, p]));\n\n    const res = await findSatisfyingAssignment({\n      transition: t,\n      inputArcs,\n      placesById,\n      bindingAstsByArc: this.cache.bindingAstsByArc,\n      guardAst,\n      parseArithmetic,\n      evaluateBooleanPredicate: evaluateBooleanPredicateWithPool,\n      matchPattern,\n      getTokensForPlace,\n      evaluateArithmeticWithBindings,\n      evaluateBooleanWithBindings,\n      evaluatePatternLiteral,\n      maxTokensPerPlace: this._config.maxTokensPerPlace,\n    });\n    if (!res) return false;\n    return this._outputBindingsTypeCompatible(transitionId, res.env || {});\n  }\n\n  async stepSimulationSpecific() {\n    // Step semantics are centralized in useSimulationManager / simulator-core.\n    return this.getCurrentState();\n  }\n\n  async fireTransitionSpecific(transitionId, options = {}) {\n    // Skip expensive enabled checks if firing in batch mode (caller will handle after all fires complete)\n    const skipEnabledCheck = options.skipEnabledCheck || false;\n    // Capture previous enabled transitions for parity payload\n    const previouslyEnabled = skipEnabledCheck ? [] : await this.getEnabledTransitionsSpecific();\n    // A simple re-evaluation: find one satisfying assignment and apply\n    const t = (this.petriNet.transitions || []).find(x => x.id === transitionId);\n    if (!t) return this.getCurrentState();\n    const inputArcs = (this.petriNet.arcs || []).filter(a => (a.targetId === transitionId || a.target === transitionId) && (a.sourceType === 'place' || !a.sourceType));\n    const outputArcs = (this.petriNet.arcs || []).filter(a => (a.sourceId === transitionId || a.source === transitionId) && (a.targetType === 'place' || !a.targetType));\n    const placesById = Object.fromEntries((this.petriNet.places || []).map(p => [p.id, p]));\n    const guardAst = this.cache.guardAstByTransition.get(transitionId);\n\n    const result = await findSatisfyingAssignment({\n      transition: t,\n      inputArcs,\n      placesById,\n      bindingAstsByArc: this.cache.bindingAstsByArc,\n      guardAst,\n      parseArithmetic,\n      evaluateBooleanPredicate: evaluateBooleanPredicateWithPool,\n      matchPattern,\n      getTokensForPlace,\n      evaluateArithmeticWithBindings,\n      evaluateBooleanWithBindings,\n      evaluatePatternLiteral,\n      maxTokensPerPlace: this._config.maxTokensPerPlace,\n    });\n    if (!result) throw new Error(`Transition ${transitionId} is not enabled`);\n    let env = result.env || {};\n    const picks = result.picks || [];\n\n    // If guard has free variables, try to solve the guard to bind them before producing outputs\n    if (guardAst) {\n      const free = getUnboundBooleanGuardVars(guardAst, env);\n      if (free.length > 0) {\n        try {\n          // Use SAT check to see if any assignment exists; if so, keep env as-is\n          const ok = await evaluateBooleanPredicateWithPool(guardAst, env, parseArithmetic);\n          if (!ok) throw new Error('Guard unsatisfied under any extension');\n        } catch (_) { /* ignore */ }\n      }\n    }\n\n    // Track which places will change for cache invalidation\n    const changedPlaces = new Set();\n    for (const pick of picks) {\n      changedPlaces.add(pick.srcId);\n    }\n    for (const arc of outputArcs) {\n      changedPlaces.add(arc.targetId || arc.target);\n    }\n\n    // Consume tokens\n    // When multiple tokens from the same place are consumed, remove by descending\n    // indices to avoid index-shift bugs.\n    consumeTokens(picks, placesById);\n\n    // Produce tokens on outputs\n    produceTokens(\n      outputArcs,\n      this.cache.bindingAstsByArc,\n      env,\n      placesById,\n      {\n        evaluateArithmeticWithBindings,\n        evaluateBooleanWithBindings,\n        evaluatePatternLiteral,\n        parseArithmetic,\n      }\n    );\n\n    // Apply transition action if provided: action like \"y = x + 1, z = x - 1\"\n    if (t.action && typeof t.action === 'string') {\n      try {\n        const assignments = evaluateAction(t.action, env, parseArithmetic);\n        // No direct store for variables; actions only affect produced token expressions above.\n        // If future semantics require, we could apply assignments to outputs here.\n      } catch (_) { /* ignore action errors */ }\n    }\n\n    // Invalidate enabled cache for transitions connected to changed places\n    this._invalidateEnabledCache(changedPlaces);\n\n    // Skip expensive checks if firing in batch mode (caller will handle after all fires complete)\n    if (!skipEnabledCheck) {\n      await this.checkTransitionStateChanges();\n      const newState = this.getCurrentState();\n      // Emit transitionFired via shared event bus\n      this.emitTransitionFired({ transitionId, newPetriNet: newState });\n      // Emit transitionsChanged with parity payload\n      const enabledAfter = await this.getEnabledTransitionsSpecific();\n      this.emitTransitionsChanged({ enabled: enabledAfter, previouslyEnabled });\n      return newState;\n    }\n\n    return this.getCurrentState();\n  }\n\n  getCurrentState() {\n    return getCurrentStateNormalized(this.petriNet);\n  }\n\n  async checkTransitionStateChanges() {\n    if (!this.isInitialized) return;\n    try {\n      const currentEnabled = await this.getEnabledTransitionsSpecific();\n      const changed = JSON.stringify([...currentEnabled].sort()) !== JSON.stringify([...this.lastEnabledTransitions].sort());\n      if (changed) {\n        const prev = [...this.lastEnabledTransitions];\n        this.lastEnabledTransitions = [...currentEnabled];\n        this.emitTransitionsChanged({\n          enabled: currentEnabled,\n          previouslyEnabled: prev,\n        });\n      }\n    } catch (_) { /* ignore */ }\n  }\n\n  /**\n   * Reset simulator-specific state\n   */\n  resetSpecific() {\n    this.lastEnabledTransitions = [];\n    this.cache.guardAstByTransition.clear();\n    this.cache.bindingAstsByArc.clear();\n    this._cacheSignature = null;\n    this._config.maxTokensPerPlace = Infinity;\n    this._clearEnabledCache();\n  }\n}\n\n// Utility: obtain tokens for a place in algebraic mode.\n// If explicit int tokens are not provided (valueTokens), fall back to PT count by\n// materializing that many tokens with value 1. This keeps APNs usable when only counts are set.\n\n// Build a lightweight signature over guards/bindings (and actions) to detect semantic changes\n","/**\n * Factory for creating simulator instances based on Petri net type\n */\nimport { PTSimulator } from './pt-simulator.js';\nimport { AlgebraicSimulator } from './algebraic-simulator.js';\n\nexport class SimulatorFactory {\n  /**\n   * Create a simulator instance based on the Petri net type\n   * @param {string} netMode - The net mode ('pt' or 'algebraic')\n   * @returns {BaseSimulator} Simulator instance\n   */\n  static createSimulator(netMode) {\n    switch (netMode) {\n      case 'pt':\n        return new PTSimulator();\n      case 'algebraic':\n        return new AlgebraicSimulator();\n      default:\n        throw new Error(`Unknown net mode: ${netMode}`);\n    }\n  }\n\n  /**\n   * Get available simulator types\n   * @returns {Array<string>} Array of available simulator types\n   */\n  static getAvailableTypes() {\n    return ['pt', 'algebraic'];\n  }\n\n  /**\n   * Check if a simulator type is supported\n   * @param {string} netMode - The net mode to check\n   * @returns {boolean} True if supported\n   */\n  static isSupported(netMode) {\n    return this.getAvailableTypes().includes(netMode);\n  }\n}\n","const tinyYield = async () => {\n  try { await new Promise((res) => setTimeout(res, 0)); } catch (_) {}\n  try {\n    if (typeof requestAnimationFrame !== 'undefined') {\n      await new Promise((res) => requestAnimationFrame(() => res()));\n    }\n  } catch (_) {}\n};\n\nconst computeIsolatedTransitions = (net) => {\n  const isolated = new Set();\n  if (!net || !Array.isArray(net.transitions)) return isolated;\n  const arcs = Array.isArray(net.arcs) ? net.arcs : [];\n  const places = Array.isArray(net.places) ? net.places : [];\n  const placeIds = new Set(places.map((place) => String(place.id)));\n\n  for (const transition of net.transitions) {\n    const transitionId = String(transition.id);\n    let hasInput = false;\n    let hasOutput = false;\n\n    for (const arc of arcs) {\n      const source = String(arc.sourceId || arc.source);\n      const target = String(arc.targetId || arc.target);\n\n      if (target === transitionId && source !== transitionId && placeIds.has(source)) {\n        hasInput = true;\n      }\n      if (source === transitionId && target !== transitionId && placeIds.has(target)) {\n        hasOutput = true;\n      }\n      if (hasInput && hasOutput) break;\n    }\n\n    if (!hasInput && !hasOutput) {\n      isolated.add(transitionId);\n    }\n  }\n\n  return isolated;\n};\n\nconst chooseGreedyNonConflicting = (enabledIds, arcs, batchMax) => {\n  const byTransition = new Map();\n  for (const id of enabledIds) {\n    byTransition.set(id, new Set());\n  }\n\n  for (const arc of (arcs || [])) {\n    const target = arc.targetId || arc.target;\n    const source = arc.sourceId || arc.source;\n    const placeToTransition = (arc.type === 'place-to-transition') || (arc.sourceType === 'place');\n    if (placeToTransition && byTransition.has(target)) {\n      byTransition.get(target).add(source);\n    }\n  }\n\n  const order = enabledIds.slice();\n  for (let i = order.length - 1; i > 0; i--) {\n    const j = (Math.random() * (i + 1)) | 0;\n    const tmp = order[i];\n    order[i] = order[j];\n    order[j] = tmp;\n  }\n\n  const usedPlaces = new Set();\n  const selection = [];\n  for (const id of order) {\n    const inputs = byTransition.get(id) || new Set();\n    let canUse = true;\n    for (const place of inputs) {\n      if (usedPlaces.has(place)) {\n        canUse = false;\n        break;\n      }\n    }\n    if (!canUse) continue;\n    selection.push(id);\n    for (const place of inputs) {\n      usedPlaces.add(place);\n    }\n    if (batchMax > 0 && selection.length >= batchMax) break;\n  }\n\n  return selection;\n};\n\nconst normalizeEnabledIds = (enabled = []) => enabled.map((entry) => {\n  if (typeof entry === 'string') return entry;\n  if (entry && typeof entry === 'object') {\n    if (entry.id) return entry.id;\n    if (entry.get) return entry.get('id');\n  }\n  return String(entry);\n}).filter(Boolean);\n\nexport const runHeadlessSimulation = async ({\n  simulator,\n  mode = 'single',\n  maxSteps = 100000,\n  timeBudgetMs = 30000,\n  yieldEvery = 100,\n  onProgress,\n  shouldCancel,\n  batchMax = 0,\n  progressEveryMs = 0,\n  yieldEveryMs = 0,\n}) => {\n  const now = (typeof performance !== 'undefined' && performance.now)\n    ? () => performance.now()\n    : () => Date.now();\n\n  const startTs = now();\n  let steps = 0;\n  let lastProgressTs = startTs;\n  let lastYieldTs = startTs;\n  let lastReportedBucket = -1;\n\n  const emitProgress = (timestamp) => {\n    if (!onProgress) return;\n    const elapsed = timestamp - startTs;\n    const bucket = progressEveryMs > 0 ? Math.floor(elapsed / progressEveryMs) : 0;\n    if (bucket === lastReportedBucket) return;\n    lastReportedBucket = bucket;\n    try {\n      onProgress({ steps, elapsedMs: elapsed });\n    } catch (_) {}\n  };\n\n  const isolatedIds = computeIsolatedTransitions(simulator.petriNet || {});\n\n  const getEnabledIds = async () => {\n    const enabled = await simulator.getEnabledTransitions();\n    const ids = normalizeEnabledIds(enabled);\n    return ids.filter((id) => !isolatedIds.has(String(id)));\n  };\n\n  const shouldContinueAfterStep = async () => {\n    if (shouldCancel && shouldCancel()) return false;\n\n    const timestamp = now();\n    const elapsed = timestamp - startTs;\n\n    if (yieldEvery > 0 && steps % yieldEvery === 0) {\n      const preYieldTs = now();\n      emitProgress(preYieldTs);\n      await tinyYield();\n      const postYieldTs = now();\n      lastYieldTs = postYieldTs;\n      lastProgressTs = postYieldTs;\n      if (progressEveryMs > 0) emitProgress(postYieldTs);\n      if (timeBudgetMs > 0 && (postYieldTs - startTs) > timeBudgetMs) return false;\n      if (shouldCancel && shouldCancel()) return false;\n      return true;\n    }\n\n    if (progressEveryMs > 0 && (timestamp - lastProgressTs) >= progressEveryMs) {\n      emitProgress(timestamp);\n      lastProgressTs = timestamp;\n    }\n\n    if (yieldEveryMs > 0 && (timestamp - lastYieldTs) >= yieldEveryMs) {\n      await tinyYield();\n      const postYieldTs = now();\n      lastYieldTs = postYieldTs;\n      if (progressEveryMs > 0 && (postYieldTs - lastProgressTs) >= progressEveryMs) {\n        emitProgress(postYieldTs);\n        lastProgressTs = postYieldTs;\n      }\n      if (timeBudgetMs > 0 && (postYieldTs - startTs) > timeBudgetMs) return false;\n      if (shouldCancel && shouldCancel()) return false;\n    }\n\n    if (timeBudgetMs > 0 && elapsed > timeBudgetMs) return false;\n    if (shouldCancel && shouldCancel()) return false;\n    return true;\n  };\n\n  let continueRunning = true;\n  while (continueRunning && steps < maxSteps) {\n    if (shouldCancel && shouldCancel()) break;\n    const enabledIds = await getEnabledIds();\n    if (!enabledIds || enabledIds.length === 0) break;\n\n    if (mode === 'maximal') {\n      const net = simulator.petriNet || {};\n      const cap = batchMax > 0 ? batchMax : Number.POSITIVE_INFINITY;\n      let batch = chooseGreedyNonConflicting(enabledIds, net.arcs || [], cap);\n      if (!batch || batch.length === 0) {\n        const fallback = enabledIds[Math.floor(Math.random() * enabledIds.length)];\n        batch = fallback ? [fallback] : [];\n      }\n\n      if (shouldCancel && shouldCancel()) {\n        continueRunning = false;\n        break;\n      }\n\n      await Promise.all(batch.map((id) => simulator.fireTransition(id, { skipEnabledCheck: true })));\n      steps += batch.length;\n      continueRunning = await shouldContinueAfterStep();\n    } else {\n      const pick = enabledIds[Math.floor(Math.random() * enabledIds.length)];\n      await simulator.fireTransition(pick);\n      steps += 1;\n      continueRunning = await shouldContinueAfterStep();\n    }\n  }\n\n  if (onProgress) {\n    try {\n      onProgress({ steps, elapsedMs: now() - startTs });\n    } catch (_) {}\n  }\n\n  return {\n    petriNet: simulator.petriNet || null,\n    steps,\n  };\n};\n\nexport const headlessHelpers = {\n  computeIsolatedTransitions,\n  chooseGreedyNonConflicting,\n  normalizeEnabledIds,\n};\n\n","import { logger } from '../../../utils/logger.js';\n\nexport const determineNetMode = (petriNet, options = {}) => {\n  logger.debug('determineNetMode called with:', { petriNet, options });\n  const configured = options?.netMode || petriNet?.netMode;\n  logger.debug('Found netMode from options/petriNet:', configured);\n  if (configured) {\n    const normalized = (configured === 'algebraic-int') ? 'algebraic' : configured;\n    logger.debug('Using configured netMode:', normalized);\n    return normalized;\n  }\n  logger.debug('No configured netMode, detecting from content');\n  return detectNetModeFromContent(petriNet);\n};\n\nexport const detectNetModeFromContent = (petriNet) => {\n  const net = petriNet || {};\n  const transitions = Array.isArray(net.transitions) ? net.transitions : [];\n  const arcs = Array.isArray(net.arcs) ? net.arcs : [];\n  const places = Array.isArray(net.places) ? net.places : [];\n\n  logger.debug('Net mode detection:', { places, transitions, arcs });\n\n  for (const t of transitions) {\n    if (typeof t.guard === 'string' && t.guard.trim().length > 0) {\n      logger.debug('Found guard, using algebraic mode');\n      return 'algebraic';\n    }\n    if (typeof t.action === 'string' && t.action.trim().length > 0) {\n      logger.debug('Found action, using algebraic mode');\n      return 'algebraic';\n    }\n  }\n\n  for (const arc of arcs) {\n    const bindings = Array.isArray(arc.bindings) ? arc.bindings : (arc.binding ? [arc.binding] : []);\n    logger.debug('Checking arc bindings:', bindings);\n    const hasAlgebraicBinding = bindings.some((binding) => (\n      typeof binding === 'string'\n        && (/:[ ]*(integer|boolean)/i.test(binding)\n          || binding === 'T'\n          || binding === 'F'\n          || /[+\\-*/()]/.test(binding))\n    ));\n    if (hasAlgebraicBinding) {\n      logger.debug('Found algebraic binding, using algebraic mode');\n      return 'algebraic';\n    }\n  }\n\n  if (places.some((place) => Array.isArray(place.valueTokens) && place.valueTokens.length > 0)) {\n    logger.debug('Found valueTokens, using algebraic mode');\n    return 'algebraic';\n  }\n\n  logger.debug('Using P/T mode');\n  return 'pt';\n};\n\n","/**\n * Simulator Core - Factory-based, pure JS implementation\n * Replaces legacy Pyodide-based core\n */\n\nimport { SimulatorFactory } from './SimulatorFactory.js';\nimport { logger } from '../../utils/logger.js';\nimport { runHeadlessSimulation } from './core/headlessRunner.js';\nimport {\n  determineNetMode as determineCoreNetMode,\n  detectNetModeFromContent as detectCoreNetMode,\n} from './core/netModeDetection.js';\n\nexport class SimulatorCore {\n  constructor() {\n    this.currentSimulator = null;\n    this._ready = false;\n    this.netMode = null;\n    this.eventBus = null;\n    this.pendingListeners = new Map();\n  }\n\n  async initialize(petriNet, options = {}) {\n    try {\n      logger.debug('SimulatorCore.initialize called with:', { petriNet, options });\n      const netMode = determineCoreNetMode(petriNet, options);\n      \n      // Always create a fresh simulator to avoid stale state\n      // This ensures proper reinitialization when loading the same net multiple times\n      this.currentSimulator = SimulatorFactory.createSimulator(netMode);\n      \n      this.netMode = netMode;\n      if (this.eventBus) this.currentSimulator.setEventBus(this.eventBus);\n      await this.currentSimulator.initialize(petriNet, options);\n      this._ready = true;\n      this.setupPendingListeners();\n      logger.debug(`Simulator initialized with ${netMode} simulator`);\n      return { success: true, netMode, simulatorType: this.currentSimulator.getType() };\n    } catch (error) {\n      console.error('Failed to initialize simulator:', error);\n      this._ready = false;\n      this.currentSimulator = null;\n      throw error;\n    }\n  }\n\n  async update(petriNet) {\n    if (!this.currentSimulator) return { success: true };\n    try {\n      await this.currentSimulator.update(petriNet);\n      return { success: true };\n    } catch (error) {\n      console.error('Failed to update simulator:', error);\n      throw error;\n    }\n  }\n\n  async getEnabledTransitions() {\n    if (!this.currentSimulator) return [];\n    try { return await this.currentSimulator.getEnabledTransitions(); }\n    catch (error) { console.error('Failed to get enabled transitions:', error); return []; }\n  }\n\n  async fireTransition(transitionId) {\n    if (!this.currentSimulator) throw new Error('Simulator not initialized');\n    try { return await this.currentSimulator.fireTransition(transitionId); }\n    catch (error) { console.error(`Failed to fire transition ${transitionId}:`, error); throw error; }\n  }\n\n  async stepSimulation() {\n    if (!this.currentSimulator) throw new Error('Simulator not initialized');\n    try {\n      // Centralized single-step semantics: choose one enabled transition and fire it\n      const enabled = await this.currentSimulator.getEnabledTransitions();\n      if (!enabled || enabled.length === 0) {\n        // No-op: return current state if available\n        return this.currentSimulator.petriNet || null;\n      }\n      const pick = enabled[Math.floor(Math.random() * enabled.length)];\n      const transitionId = (typeof pick === 'string') ? pick : (pick && pick.id) ? pick.id : String(pick);\n      return await this.currentSimulator.fireTransition(transitionId);\n    } catch (error) {\n      console.error('Failed to step simulation:', error);\n      throw error;\n    }\n  }\n\n  // Headless run to completion without per-step UI events\n  async runToCompletion({\n    mode = 'single',\n    maxSteps = 100000,\n    timeBudgetMs = 30000,\n    yieldEvery = 100,\n    onProgress,\n    shouldCancel,\n    batchMax = 0,\n    progressEveryMs = 0,\n    yieldEveryMs = 0,\n  } = {}) {\n    if (!this.currentSimulator) throw new Error('Simulator not initialized');\n    // Detach event bus to suppress per-step emissions\n    const prevBus = this.currentSimulator.eventBus || null;\n    try {\n      if (this.currentSimulator.setEventBus) this.currentSimulator.setEventBus(null);\n    } catch (_) {}\n\n    try {\n      if (this.currentSimulator.setSimulationMode) this.currentSimulator.simulationMode = mode;\n      return await runHeadlessSimulation({\n        simulator: this.currentSimulator,\n        mode,\n        maxSteps,\n        timeBudgetMs,\n        yieldEvery,\n        onProgress,\n        shouldCancel,\n        batchMax,\n        progressEveryMs,\n        yieldEveryMs,\n      });\n    } finally {\n      try { if (this.currentSimulator.setEventBus) this.currentSimulator.setEventBus(prevBus); } catch (_) {}\n    }\n  }\n\n  reset() {\n    if (this.currentSimulator) this.currentSimulator.reset();\n    this.currentSimulator = null;\n    this._ready = false;\n    this.netMode = null;\n    this.pendingListeners.clear();\n  }\n\n  deactivateSimulation() { this._active = false; }\n\n  activateSimulation(continuous = false) {\n    if (!this.currentSimulator) throw new Error('Simulator not initialized');\n    logger.debug(`Simulation activated (continuous: ${continuous})`);\n  }\n\n  async isReady() { return this._ready && this.currentSimulator && this.currentSimulator.isReady(); }\n\n  getSimulatorStatus() { return { isReady: this._ready, netMode: this.netMode, simulatorType: this.currentSimulator?.getType() || 'none', simulatorStatus: { simulator: this.currentSimulator } }; }\n\n  getSimulatorType() { return this.currentSimulator?.getType() || 'none'; }\n\n  getSimulationMode() { return this.currentSimulator?.simulationMode || 'single'; }\n  setSimulationMode(mode) { if (this.currentSimulator) this.currentSimulator.simulationMode = mode; }\n\n  setEventBus(eventBus) { this.eventBus = eventBus; if (this.currentSimulator) this.currentSimulator.setEventBus(eventBus); }\n  __queueListener(event, callback) { if (!this.pendingListeners.has(event)) this.pendingListeners.set(event, []); this.pendingListeners.get(event).push(callback); }\n  setupPendingListeners() { if (!this.currentSimulator || !this.eventBus) return; for (const [event, cbs] of this.pendingListeners) { for (const cb of cbs) this.eventBus.on(event, cb); } this.pendingListeners.clear(); }\n\n  determineNetMode(petriNet, options) {\n    return determineCoreNetMode(petriNet, options);\n  }\n\n  detectNetModeFromContent(petriNet) {\n    return detectCoreNetMode(petriNet);\n  }\n\n}\n\nexport const simulatorCore = new SimulatorCore();\nexport default simulatorCore;\n","import { SimulatorCore } from '../features/simulation/simulator-core.js';\nimport { setZ3WorkerConfig } from '../utils/z3-remote';\n\nlet core = null;\nlet canceled = false;\n\nconst tinyYield = async () => {\n  try { await new Promise((res) => setTimeout(res, 0)); } catch (_) {}\n  try { if (typeof requestAnimationFrame !== 'undefined') await new Promise((res) => requestAnimationFrame(() => res())); } catch (_) {}\n};\n\nself.onmessage = async (e) => {\n  const { op, payload } = e.data || {};\n  try {\n    if (op === 'prewarm') {\n      const { z3 } = payload || {};\n      if (z3 && typeof z3 === 'object') { \n        try { \n          setZ3WorkerConfig(z3); \n        } catch (err) {\n          console.error('Prewarm failed to set Z3 config:', err);\n        } \n      }\n      if (!core) core = new SimulatorCore();\n      postMessage({ op: 'prewarm:ok' });\n      return;\n    }\n\n    if (op === 'cancel') {\n      canceled = true;\n      postMessage({ op: 'cancel:ack' });\n      return;\n    }\n\n    if (op === 'dispose') {\n      core = null; canceled = false;\n      postMessage({ op: 'dispose:ok' });\n      return;\n    }\n\n    if (op === 'start') {\n      canceled = false;\n      const { elements, simOptions = {}, run = {}, z3 = {} } = payload || {};\n      try { \n        setZ3WorkerConfig(z3 || {}); \n      } catch (configErr) {\n        console.error('Failed to set Z3 worker config:', configErr);\n        // Don't crash, but logging is important\n      }\n      if (!core) core = new SimulatorCore();\n\n      await core.initialize(elements || {}, { netMode: simOptions.netMode || elements?.netMode });\n\n      const shouldCancel = () => canceled === true;\n      const onProgress = () => {\n        // Silent - no progress reporting to frontend\n      };\n\n      // Track timing for completion stats\n      const startTime = performance.now ? performance.now() : Date.now();\n\n      const result = await core.runToCompletion({\n        mode: run.mode || 'single',\n        maxSteps: run.maxSteps ?? 200000,\n        timeBudgetMs: run.timeBudgetMs ?? 0,\n        yieldEvery: run.yieldEvery ?? 5000,\n        progressEveryMs: run.progressEveryMs ?? 0,\n        yieldEveryMs: run.yieldEveryMs ?? 0,\n        batchMax: run.batchMax ?? 0,\n        onProgress,\n        shouldCancel,\n      });\n\n      const endTime = performance.now ? performance.now() : Date.now();\n      const elapsedMs = Math.round(endTime - startTime);\n\n      postMessage({\n        op: 'done',\n        payload: {\n          canceled: shouldCancel(),\n          elements: result?.petriNet || core.currentSimulator?.petriNet || null,\n          stats: { elapsedMs, steps: result?.steps || 0 }\n        }\n      });\n      return;\n    }\n\n    postMessage({ op: 'error', payload: { message: 'unknown op' } });\n  } catch (err) {\n    postMessage({ op: 'error', payload: { message: String(err?.message || err) } });\n  } finally {\n    await tinyYield();\n  }\n};\n\n\n"],"names":["SimulationEvents","BaseSimulator","petriNet","options","transitionId","eventBus","payload","enabled","previouslyEnabled","hasEnabled","newPetriNet","places","transitions","arcs","net","placeIdSet","p","transitionIdSet","t","place","count","arc","src","tgt","w","totalTokens","sum","consumeTokens","picks","placesById","picksByPlace","srcId","arr","fallbackCount","current","indexed","a","b","produceTokens","outputArcs","bindingAstsByArc","env","evaluators","evaluateArithmeticWithBindings","evaluateBooleanWithBindings","evaluatePatternLiteral","parseArithmetic","tgtId","bindingAsts","astObj","v","kind","ast","isPair","n","i","vals","first","LEVEL_ORDER","DEFAULT_ENV_LEVEL","_a","_b","_c","globalLevel","nodeLevel","fallback","resolveLevel","level","key","currentLevel","shouldLog","resolved","logger","args","PTSimulator","optMax","transition","inputArcs","requiredTokens","skipEnabledCheck","newPlaces","outputArcsNormalized","enabledAfter","input","isDigit","ch","skipWs","parseIntLiteral","start","text","isIdentStart","isIdentPart","parseStringLiteral","value","next","parseIdent","name","parseExpr","save","tStart","tWord","parseListLiteral","elements","parseFactor","second","parseTerm","left","op","right","result","normalize","node","parsePattern","parsePatternElement","varType","matchPattern","pattern","bindings","matchElement","pat","val","expectedType","index","getTokensForPlace","cap","ensureOutputBindingsTypeCompatible","cache","defaultAllowedOps","allowedOps","buildGuardCache","parseBooleanExpr","parsePredicate","guardAstByTransition","containsOperationCall","ops","len","j","ident","k","buildBindingCache","asts","trimmed","preferArithmetic","isAllowedFuncall","tryArithmetic","parsed","tryPattern","handled","tf","findSatisfyingAssignment","guardAst","evaluateBooleanPredicate","maxTokensPerPlace","tryArc","arcIndex","arcId","tokens","needed","used","tryBind","localEnv","tok","ok","nextEnv","varName","varValue","res","extractVariablesFromPattern","variables","traverse","extractVariablesFromExpression","checkForUnboundVariables","boundVariables","guardVars","getCurrentStateNormalized","placeIds","transitionIds","s","inferredSourceType","inferredTargetType","type","z3InitPromise","ensureZ3Available","originalModule","baseUrl","origin","pathname","assetsIdx","lastSlash","dir","buildAssetUrl","assetPath","cleanPath","wasmPath","wasmResponse","wasmDataUrl","patchedModule","path","jsPath","response","z3Script","resolve","error","reject","scriptElement","err","getContext","init","z3","ctx","isNodeJSTest","fallbackError","nodeError","buildZ3Expr","sym","Int","Z3String","arg1","arg2","str","l","r","evalNode","a1","a2","st","ln","arg","sub","list","element","expr","depth","opIndex","foundOp","two","leftStr","rightStr","leftAst","rightAst","isWordBoundaryAt","pos","startsWithWord","word","parseIdentWithOptionalType","parseAnyTermString","term","inner","splitAt","m","parseBoolPrimary","startArgs","d","inside","cur","parts","a0","afterOp","end","wordBoundary","isTopLevelLogicAt","rest","LOGIC_SYMS","LOGIC_WORDS","ch2","parseIff","OP_WORDS","OP_SYMS","tryConsumeSymbolOrWord","symbols","words","parseNot","parseAnd","parseXor","parseOr","parseImplies","toBool","tryEvalAnyTerm","evalBool","eq","boolAstOrString","Bool","Solver","And","Not","Or","intVars","boolVars","collect","addArith","intSym","boolSym","buildBool","str1","canBuildIntTerm","buildArith","solver","timeout","equalities","evaluateAction","actionString","_parseArithmetic","part","eqIdx","_evalArithWithBindings","workerPool","nextId","pending","roundRobinIndex","idleTimer","workerSupported","sharedArrayBufferSupported","z3Config","publishConfig","target","normalizePoolSize","setZ3WorkerConfig","cfg","ensurePoolCapacity","createWorker","data","id","entry","tickIdleTimer","getWorker","call","getConfiguredPoolSize","isWorkerPoolEnabled","astOrStr","_parseArithmeticIgnored","evaluateBooleanPredicateWithPool","parseArithmeticFn","z3Pool.isWorkerPoolEnabled","z3Pool.evaluateBooleanPredicate","evaluateBooleanPredicateDirect","deepCloneNet","getUnboundBooleanGuardVars","names","collectArith","arithAst","bound","computeCacheSignature","tSig","aSig","AlgebraicSimulator","mode","changedPlaces","placeId","tId","shouldRebuildCaches","toCheck","poolSize","z3Pool.getConfiguredPoolSize","concurrency","flags","nextIndex","runSlot","idx","workers","checkUnbound","x","pick","assignments","newState","currentEnabled","prev","SimulatorFactory","netMode","tinyYield","computeIsolatedTransitions","isolated","hasInput","hasOutput","source","chooseGreedyNonConflicting","enabledIds","batchMax","byTransition","order","tmp","usedPlaces","selection","inputs","canUse","normalizeEnabledIds","runHeadlessSimulation","simulator","maxSteps","timeBudgetMs","yieldEvery","onProgress","shouldCancel","progressEveryMs","yieldEveryMs","now","startTs","steps","lastProgressTs","lastYieldTs","lastReportedBucket","emitProgress","timestamp","elapsed","bucket","isolatedIds","getEnabledIds","shouldContinueAfterStep","preYieldTs","postYieldTs","continueRunning","batch","determineNetMode","configured","normalized","detectNetModeFromContent","binding","SimulatorCore","determineCoreNetMode","prevBus","continuous","event","callback","cbs","cb","detectCoreNetMode","core","canceled","e","simOptions","run","configErr","startTime","endTime","elapsedMs"],"mappings":"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"}