{"version":3,"file":"z3.worker-c3b76c07.js","sources":["../src/config/logging.js","../src/utils/logger.js","../src/utils/z3/context.js","../src/utils/z3/builders.js","../src/utils/z3/eval-arith.js","../src/utils/z3/booleanParser.js","../src/utils/z3/booleanEvaluator.js","../src/utils/z3/booleanPredicateSolver.js","../src/utils/z3/equationSolver.js","../src/utils/parse/arithmetic-impl.js","../src/workers/z3.worker.js"],"sourcesContent":["const LEVEL_ORDER = {\n  silent: 0,\n  error: 1,\n  warn: 2,\n  info: 3,\n  debug: 4,\n};\n\nconst DEFAULT_ENV_LEVEL = (() => {\n  const globalLevel = typeof globalThis !== 'undefined' ? globalThis.__PETRI_NET_LOG_LEVEL__ : undefined;\n  const nodeLevel = typeof process !== 'undefined'\n    ? (process.env?.VITE_LOG_LEVEL || process.env?.LOG_LEVEL)\n    : undefined;\n  const fallback = (typeof process !== 'undefined' && process.env?.NODE_ENV === 'production') ? 'warn' : 'debug';\n  return (globalLevel || nodeLevel || fallback || 'warn').toLowerCase();\n})();\n\nfunction resolveLevel(level) {\n  if (!level) return 'warn';\n  const key = String(level).toLowerCase();\n  return LEVEL_ORDER[key] !== undefined ? key : 'warn';\n}\n\nlet currentLevel = resolveLevel(DEFAULT_ENV_LEVEL);\n\nexport const DEFAULT_LOG_LEVEL = currentLevel;\n\nexport function setLogLevel(level) {\n  currentLevel = resolveLevel(level);\n}\n\nexport function getLogLevel() {\n  return currentLevel;\n}\n\nexport function shouldLog(level) {\n  const resolved = resolveLevel(level);\n  return LEVEL_ORDER[resolved] <= LEVEL_ORDER[currentLevel];\n}\n\nexport const loggingLevels = Object.freeze({ ...LEVEL_ORDER });\n\n","import { DEFAULT_LOG_LEVEL, getLogLevel, setLogLevel as setConfigLevel, shouldLog } from '../config/logging';\n\nexport function setLogLevel(level) {\n  setConfigLevel(level);\n}\n\nexport function setDebug(enabled) {\n  setConfigLevel(enabled ? 'debug' : DEFAULT_LOG_LEVEL);\n}\n\nexport { getLogLevel };\n\nexport const logger = {\n  debug: (...args) => {\n    if (shouldLog('debug')) {\n      // eslint-disable-next-line no-console\n      console.debug(...args);\n    }\n  },\n  info: (...args) => {\n    if (shouldLog('info')) {\n      // eslint-disable-next-line no-console\n      console.info(...args);\n    }\n  },\n  warn: (...args) => {\n    if (shouldLog('warn')) {\n      // eslint-disable-next-line no-console\n      console.warn(...args);\n    }\n  },\n  error: (...args) => {\n    if (shouldLog('error')) {\n      // eslint-disable-next-line no-console\n      console.error(...args);\n    }\n  },\n};\n\n","import { logger } from '../logger.js';\n\nlet z3InitPromise = null;\n\nasync function ensureZ3Available() {\n  const isNodeJSTest = typeof process !== 'undefined' && process.env && process.env.JEST_WORKER_ID;\n  if (isNodeJSTest) {\n    logger.debug('Jest worker detected, skipping Z3 asset fetch');\n    return;\n  }\n    // Worker context (no DOM): fetch and evaluate z3-built.js with embedded WASM\n    if (typeof document === 'undefined') {\n      if (typeof globalThis.initZ3 === 'function') return;\n      const originalModule = globalThis.Module;\n      try {\n        // Determine base URL for fetching assets\n        // In Vite, import.meta.env.BASE_URL is replaced with the public base path\n        const baseUrl = import.meta.env.BASE_URL || '/';\n        const resolveAsset = (path) => {\n          // Ensure we don't have double slashes\n          const cleanBase = baseUrl.endsWith('/') ? baseUrl : `${baseUrl}/`;\n          const cleanPath = path.startsWith('/') ? path.slice(1) : path;\n          return `${cleanBase}${cleanPath}`;\n        };\n\n        // First load the WASM file as base64\n        const wasmPath = resolveAsset('z3-built.wasm.base64');\n        logger.debug('[Z3 worker] fetching WASM base64 from', wasmPath);\n        const wasmResponse = await fetch(wasmPath);\n        if (!wasmResponse.ok) throw new Error(`Failed to fetch WASM base64 from ${wasmPath}: ${wasmResponse.status}`);\n        const wasmBase64 = await wasmResponse.text();\n\n        // Create data URL for WASM\n        const wasmDataUrl = `data:application/wasm;base64,${wasmBase64}`;\n\n        const patchedModule = {\n          ...(typeof originalModule === 'object' ? originalModule : {}),\n          locateFile: (path) => {\n            if (path.endsWith('.wasm')) {\n              logger.debug('[Z3 worker] locateFile', path, '->', `${wasmDataUrl.substring(0, 50)}...`);\n              return wasmDataUrl;\n            }\n            const resolved = resolveAsset(path);\n            logger.debug('[Z3 worker] locateFile', path, '->', resolved);\n            return resolved;\n          }\n        };\n        globalThis.Module = patchedModule;\n\n        const jsPath = resolveAsset('z3-built.js');\n        const response = await fetch(jsPath);\n        if (!response.ok) throw new Error(`Failed to fetch z3-built.js from ${jsPath}: ${response.status}`);\n        const z3Script = await response.text();\n        // Evaluate in worker global scope\n        (0, eval)(z3Script);\n        await new Promise(resolve => setTimeout(resolve, 20));\n        if (typeof globalThis.initZ3 !== 'function') throw new Error('initZ3 not defined after eval');\n        return;\n      } catch (error) {\n        throw new Error(`Failed to load Z3 in worker: ${error.message}`);\n      } finally {\n      if (typeof originalModule === 'object') {\n        globalThis.Module = originalModule;\n      } else {\n        delete globalThis.Module;\n      }\n    }\n  }\n\n  // Main thread (DOM available)\n  if (typeof globalThis.initZ3 === 'function') return;\n  logger.debug('initZ3 not found, loading Z3 built assets...');\n  await new Promise((resolve, reject) => {\n    const scriptElement = document.createElement('script');\n    scriptElement.src = '/z3-built.js';\n    scriptElement.async = true;\n    scriptElement.addEventListener('load', () => {\n      if (typeof globalThis.initZ3 === 'function') {\n        logger.debug('Z3 built assets loaded successfully');\n        resolve();\n      } else {\n        reject(new Error('initZ3 function not found after loading z3-built.js'));\n      }\n    });\n    scriptElement.addEventListener('error', (err) => {\n      reject(new Error(`Failed to load z3-built.js: ${err?.message || err}`));\n    });\n    document.head.appendChild(scriptElement);\n  });\n}\n\nexport async function getContext() {\n  if (!z3InitPromise) {\n    z3InitPromise = (async () => {\n      try {\n        logger.debug('Initializing Z3 context...');\n        // Always ensure Z3 assets are loaded first (skip direct WASM init that fails)\n        await ensureZ3Available();\n\n        const { init } = await import('z3-solver');\n        if (!init) {\n          throw new Error('Z3 init function not found. Z3-solver package may not be properly installed.');\n        }\n\n        logger.debug('Calling Z3 init...');\n        const z3 = await init();\n        if (!z3) {\n          throw new Error('Z3 initialization failed. Check browser console for WASM loading errors.');\n        }\n\n        logger.debug('Creating Z3 context...');\n        // Use a general-purpose context so both arithmetic and string theories are available\n        const ctx = new z3.Context('main');\n        if (!ctx) {\n          throw new Error('Failed to create Z3 context.');\n        }\n\n        logger.debug('Z3 context initialized successfully');\n        return { z3, ctx };\n      } catch (error) {\n        logger.error('Z3 initialization error:', error);\n\n        // For browser (not test environment), try asset loading fallback\n        const isNodeJSTest = typeof process !== 'undefined' && process.env && process.env.JEST_WORKER_ID;\n        if (typeof document !== 'undefined' && !isNodeJSTest) {\n          logger.debug('Retrying Z3 initialization with asset loading...');\n          try {\n            // Force asset loading\n            if (typeof globalThis.initZ3 !== 'function') {\n              logger.debug('initZ3 not found, loading Z3 built assets...');\n              await new Promise((resolve, reject) => {\n                const scriptElement = document.createElement('script');\n                scriptElement.src = '/z3-built.js';\n                scriptElement.async = true;\n                scriptElement.addEventListener('load', () => {\n                  if (typeof globalThis.initZ3 === 'function') {\n                    logger.debug('Z3 built assets loaded successfully');\n                    resolve();\n                  } else {\n                    reject(new Error('initZ3 function not found after loading z3-built.js'));\n                  }\n                });\n                scriptElement.addEventListener('error', (err) => {\n                  reject(new Error(`Failed to load z3-built.js: ${err?.message || err}`));\n                });\n                document.head.appendChild(scriptElement);\n              });\n            }\n\n            const { init } = await import('z3-solver');\n            const z3 = await init();\n            const ctx = new z3.Context('main');\n            logger.debug('Z3 context initialized successfully (fallback)');\n            return { z3, ctx };\n          } catch (fallbackError) {\n            logger.error('Fallback Z3 initialization also failed:', fallbackError);\n          }\n        }\n\n        // For Node.js (tests), try direct import without asset loading\n        if (isNodeJSTest || typeof document === 'undefined') {\n          logger.debug('Retrying Z3 initialization for Node.js...');\n          try {\n            const { init } = await import('z3-solver');\n            const z3 = await init();\n            const ctx = new z3.Context('main');\n            logger.debug('Z3 context initialized successfully (Node.js)');\n            return { z3, ctx };\n          } catch (nodeError) {\n            logger.error('Node.js Z3 initialization also failed:', nodeError);\n          }\n        }\n\n        throw new Error(`initZ3 was not imported correctly. Please consult documentation on how to load Z3 in browser. Details: ${error.message}`);\n      }\n    })();\n  }\n  return z3InitPromise;\n}\n\n\n","export function collectVariables(ast, acc = new Set()) {\n  if (!ast) return acc;\n  if (ast.type === 'var') acc.add(ast.name);\n  if (ast.type === 'pair') {\n    collectVariables(ast.fst, acc);\n    collectVariables(ast.snd, acc);\n  }\n  if (ast.type === 'binop') {\n    collectVariables(ast.left, acc);\n    collectVariables(ast.right, acc);\n  }\n  if (ast.type === 'funcall' && ast.args) {\n    ast.args.forEach(arg => collectVariables(arg, acc));\n  }\n  return acc;\n}\n\nexport function buildZ3Expr(ctx, ast, sym) {\n  const { Int, String: Z3String } = ctx;\n  switch (ast.type) {\n    case 'int':\n      return Int.val(ast.value);\n    case 'string':\n      return Z3String.val(ast.value);\n    case 'pair':\n      // Represent pair as concatenated string for now, sufficient for evaluation context\n      const left = buildZ3Expr(ctx, ast.fst, sym);\n      const right = buildZ3Expr(ctx, ast.snd, sym);\n      return left.concat(Z3String.val(',')).concat(right);\n    case 'var':\n      return sym(ast.name);\n    case 'funcall': {\n      // Fast-path: length over a string literal without requiring String theory\n      if (ast.name === 'length' && ast.args && ast.args.length === 1 && ast.args[0]?.type === 'string') {\n        return Int.val((ast.args[0].value || '').length);\n      }\n      if (ast.name === 'concat' && ast.args && ast.args.length === 2) {\n        const arg1 = buildZ3Expr(ctx, ast.args[0], sym);\n        const arg2 = buildZ3Expr(ctx, ast.args[1], sym);\n        return arg1.concat(arg2);\n      }\n      if (ast.name === 'substring' && ast.args && ast.args.length === 3) {\n        const str = buildZ3Expr(ctx, ast.args[0], sym);\n        const start = buildZ3Expr(ctx, ast.args[1], sym);\n        const len = buildZ3Expr(ctx, ast.args[2], sym);\n        return str.substr(start, len);\n      }\n      if (ast.name === 'length' && ast.args && ast.args.length === 1) {\n        const str = buildZ3Expr(ctx, ast.args[0], sym);\n        return str.length();\n      }\n      throw new Error(`Unknown function '${ast.name}'`);\n    }\n    case 'binop': {\n      const l = buildZ3Expr(ctx, ast.left, sym);\n      const r = buildZ3Expr(ctx, ast.right, sym);\n      switch (ast.op) {\n        case '+': return l.add(r);\n        case '-': return l.sub(r);\n        case '*': return l.mul(r);\n        case '/': return l.div(r);\n        default: throw new Error(`Unknown operator '${ast.op}'`);\n      }\n    }\n    default:\n      throw new Error(`Unknown AST node '${ast.type}'`);\n  }\n}\n\n\n","import { getContext } from './context';\nimport { buildZ3Expr, collectVariables } from './builders';\n\nfunction evalPure(node) {\n  if (node.type === 'int') return node.value | 0;\n  const a = evalPure(node.left);\n  const b = evalPure(node.right);\n  switch (node.op) {\n    case '+': return (a + b) | 0;\n    case '-': return (a - b) | 0;\n    case '*': return (a * b) | 0;\n    case '/': {\n      if (b === 0) throw new Error('Division by zero');\n      return Math.trunc(a / b) | 0;\n    }\n    default: throw new Error(`Unknown operator '${node.op}'`);\n  }\n}\n\nexport async function evaluateArithmetic(ast) {\n  const pure = evalPure(ast);\n  const { ctx } = await getContext();\n  const { Int, Solver } = ctx;\n  function build(node) {\n    if (node.type === 'int') return Int.val(node.value);\n    const l = build(node.left);\n    const r = build(node.right);\n    switch (node.op) {\n      case '+': return l.add(r);\n      case '-': return l.sub(r);\n      case '*': return l.mul(r);\n      case '/': return l.div(r);\n      default: throw new Error(`Unknown operator '${node.op}'`);\n    }\n  }\n  const term = build(ast);\n  const resultSym = Int.const('result');\n  const s = new Solver();\n  s.add(resultSym.eq(term));\n  const status = await s.check();\n  if (String(status) !== 'sat') throw new Error('Expression is not satisfiable');\n  const m = s.model();\n  const z3Res = m.eval(resultSym);\n  const txt = z3Res.toString();\n  const asInt = Number.parseInt(txt, 10);\n  if (!Number.isNaN(asInt)) return asInt;\n  return pure;\n}\n\nexport function evaluateArithmeticWithBindings(ast, bindings) {\n  function evalNode(node) {\n    if (node.type === 'int') return node.value | 0;\n    if (node.type === 'string') return node.value;\n    if (node.type === 'list') return (node.elements || []).map(evalNode);\n    if (node.type === 'pair') return { __pair__: true, fst: evalNode(node.fst), snd: evalNode(node.snd) };\n    if (node.type === 'var') {\n      const v = bindings?.[node.name];\n      if (v === undefined) throw new Error(`Unbound variable '${node.name}'`);\n      return v;\n    }\n    if (node.type === 'funcall') {\n      if (node.name === 'concat' && node.args && node.args.length === 2) {\n        const a1 = evalNode(node.args[0]); const a2 = evalNode(node.args[1]);\n        if (typeof a1 === 'string' && typeof a2 === 'string') return a1 + a2;\n        if (Array.isArray(a1) && Array.isArray(a2)) return [...a1, ...a2];\n        throw new Error('concat requires two strings or two lists');\n      }\n      if (node.name === 'substring' && node.args && node.args.length === 3) {\n        const s = evalNode(node.args[0]); const st = evalNode(node.args[1]); const ln = evalNode(node.args[2]);\n        if (typeof s !== 'string' || typeof st !== 'number' || typeof ln !== 'number') throw new Error('substring requires string, int, int');\n        return s.substr(st, ln);\n      }\n      if (node.name === 'length' && node.args && node.args.length === 1) {\n        const arg = evalNode(node.args[0]);\n        if (typeof arg === 'string' || Array.isArray(arg)) return arg.length;\n        throw new Error('length requires string or list');\n      }\n      if (node.name === 'isSubstringOf' && node.args && node.args.length === 2) {\n        const sub = evalNode(node.args[0]); const str = evalNode(node.args[1]);\n        if (typeof sub !== 'string' || typeof str !== 'string') throw new Error('isSubstringOf requires two strings');\n        return str.includes(sub);\n      }\n      if (node.name === 'head' && node.args && node.args.length === 1) {\n        const list = evalNode(node.args[0]); if (!Array.isArray(list) || list.length === 0) throw new Error('head requires non-empty list');\n        return list[0];\n      }\n      if (node.name === 'tail' && node.args && node.args.length === 1) {\n        const list = evalNode(node.args[0]); if (!Array.isArray(list)) throw new Error('tail requires list');\n        return list.length === 0 ? [] : list.slice(1);\n      }\n      if (node.name === 'append' && node.args && node.args.length === 2) {\n        const list = evalNode(node.args[0]); const element = evalNode(node.args[1]); if (!Array.isArray(list)) throw new Error('append requires list');\n        return [...list, element];\n      }\n      if (node.name === 'sublist' && node.args && node.args.length === 3) {\n        const list = evalNode(node.args[0]); const st = evalNode(node.args[1]); const ln = evalNode(node.args[2]);\n        if (!Array.isArray(list) || typeof st !== 'number' || typeof ln !== 'number') throw new Error('sublist requires list, int, int');\n        return list.slice(st, st + ln);\n      }\n      if (node.name === 'isSublistOf' && node.args && node.args.length === 2) {\n        const sub = evalNode(node.args[0]); const list = evalNode(node.args[1]);\n        if (!Array.isArray(sub) || !Array.isArray(list)) throw new Error('isSublistOf requires two lists');\n        const n = sub.length; if (n === 0) return true;\n        for (let i = 0; i <= list.length - n; i++) {\n          let ok = true; for (let j = 0; j < n; j++) { if (list[i + j] !== sub[j]) { ok = false; break; } }\n          if (ok) return true;\n        }\n        return false;\n      }\n      if (node.name === 'fst' && node.args && node.args.length === 1) {\n        const arg = evalNode(node.args[0]);\n        if (!arg || typeof arg !== 'object' || arg.__pair__ !== true) throw new Error('fst requires pair');\n        return arg.fst;\n      }\n      if (node.name === 'snd' && node.args && node.args.length === 1) {\n        const arg = evalNode(node.args[0]);\n        if (!arg || typeof arg !== 'object' || arg.__pair__ !== true) throw new Error('snd requires pair');\n        return arg.snd;\n      }\n      throw new Error(`Unknown function '${node.name}'`);\n    }\n    if (node.type === 'binop') {\n      const a = evalNode(node.left); const b = evalNode(node.right);\n      if (typeof a !== 'number' || typeof b !== 'number') throw new Error('Arithmetic operands must be numbers');\n      switch (node.op) {\n        case '+': return (a + b) | 0;\n        case '-': return (a - b) | 0;\n        case '*': return (a * b) | 0;\n        case '/': if (b === 0) throw new Error('Division by zero'); return Math.trunc(a / b) | 0;\n        default: throw new Error(`Unknown operator '${node.op}'`);\n      }\n    }\n    throw new Error(`Unknown node type '${node.type}'`);\n  }\n  return evalNode(ast);\n}\n\nexport async function evaluateTermWithBindings(ast, bindings) {\n  // Mitigation 1: try JS reduction first for fully-ground terms\n  try {\n    const val = evaluateArithmeticWithBindings(ast, bindings || {});\n    if (typeof val === 'number') return val | 0;\n  } catch (_) {}\n\n  const { ctx } = await getContext();\n  const { Int, Solver, And, String: Z3String } = ctx;\n\n  // Infer string variables from usage contexts\n  const stringVars = new Set();\n  (function markStringVars(node) {\n    if (!node || typeof node !== 'object') return;\n    if (node.type === 'funcall') {\n      const name = node.name;\n      const args = Array.isArray(node.args) ? node.args : [];\n      if (name === 'concat') {\n        args.forEach(a => {\n          if (a && a.type === 'var') stringVars.add(a.name);\n          markStringVars(a);\n        });\n      } else if (name === 'substring' || name === 'length') {\n        const a0 = args[0];\n        if (a0 && a0.type === 'var') stringVars.add(a0.name);\n        args.forEach(a => markStringVars(a));\n      } else {\n        args.forEach(a => markStringVars(a));\n      }\n      return;\n    }\n    if (node.type === 'binop') { markStringVars(node.left); markStringVars(node.right); return; }\n    if (node.type === 'pair') { markStringVars(node.fst); markStringVars(node.snd); return; }\n  })(ast);\n\n  const allVars = Array.from(new Set(Array.from(collectVariables(ast))));\n  const intVars = allVars.filter(v => !stringVars.has(v));\n  const intSym = new Map(intVars.map((v) => [v, Int.const(v)]));\n  const strSym = new Map(stringVars.map((v) => [v, Z3String?.const ? Z3String.const(v) : null]));\n  const sym = (name) => (stringVars.has(name) ? strSym.get(name) : intSym.get(name));\n\n  const expr = buildZ3Expr(ctx, ast, sym);\n  const res = Int.const('result');\n  const s = new Solver();\n  try { s.set('timeout', 10000); } catch (_) {}\n  s.add(res.eq(expr));\n  if (bindings && typeof bindings === 'object') {\n    const eqs = [];\n    for (const [name, value] of Object.entries(bindings)) {\n      if (typeof value === 'number' && intSym.has(name)) eqs.push(intSym.get(name).eq(Int.val(value | 0)));\n      else if (typeof value === 'string' && strSym.has(name) && Z3String?.val) eqs.push(strSym.get(name).eq(Z3String.val(value)));\n    }\n    if (eqs.length) s.add(And(...eqs));\n  }\n  const status = await s.check();\n  if (String(status) !== 'sat') throw new Error('Unsatisfiable under bindings');\n  const m = s.model();\n  const v = m.eval(res, true);\n  const n = Number.parseInt(v.asString?.() ?? String(v), 10);\n  if (!Number.isNaN(n)) return n;\n  return Number.parseInt(String(v), 10);\n}\n\n\n","export function parsePredicate(expr, parseArithmetic) {\n  if (typeof expr !== 'string') throw new Error('Predicate must be a string');\n  const src = expr.trim();\n  const ops = ['>=', '<=', '==', '!=', '>', '<'];\n  let depth = 0;\n  let opIndex = -1;\n  let foundOp = null;\n\n  for (let i = 0; i < src.length; i++) {\n    const ch = src[i];\n    if (ch === '(') depth++;\n    else if (ch === ')') depth = Math.max(0, depth - 1);\n    if (depth !== 0) continue;\n    const two = src.slice(i, i + 2);\n    if (ops.includes(two)) {\n      foundOp = two;\n      opIndex = i;\n      break;\n    }\n    if (ops.includes(ch)) {\n      foundOp = ch;\n      opIndex = i;\n      break;\n    }\n  }\n\n  if (!foundOp || opIndex < 0) {\n    throw new Error('Predicate must contain a comparison operator');\n  }\n\n  const leftStr = src.slice(0, opIndex).trim();\n  const rightStr = src.slice(opIndex + foundOp.length).trim();\n  const leftAst = parseArithmetic(leftStr);\n  const rightAst = parseArithmetic(rightStr);\n  return { type: 'cmp', op: foundOp, left: leftAst, right: rightAst };\n}\n\nexport function parseBooleanExpr(input, parseArithmetic) {\n  if (typeof input !== 'string') {\n    throw new Error('Boolean expression must be a string');\n  }\n\n  const src = input.trim();\n  let i = 0;\n\n  const skipWs = () => {\n    while (i < src.length && /\\s/.test(src[i])) i++;\n  };\n\n  const isWordBoundaryAt = (pos, len) =>\n    (pos === 0 || /[^A-Za-z0-9_]/.test(src[pos - 1] || '')) &&\n    (pos + len === src.length || /[^A-Za-z0-9_]/.test(src[pos + len] || ''));\n\n  const startsWithWord = (word) => {\n    skipWs();\n    return (\n      src.slice(i, i + word.length).toLowerCase() === word &&\n      isWordBoundaryAt(i, word.length)\n    );\n  };\n\n  const parseIdentWithOptionalType = () => {\n    skipWs();\n    const start = i;\n    if (!/[A-Za-z_]/.test(src[i] || '')) {\n      throw new Error(`Expected identifier at position ${i}`);\n    }\n    i++;\n    while (i < src.length && /[A-Za-z0-9_]/.test(src[i])) i++;\n    const name = src.slice(start, i);\n    if (name && /^[A-Z]/.test(name)) {\n      throw new Error(`Variable names must start with lowercase letter, got '${name}'`);\n    }\n    const save = i;\n    skipWs();\n    if (src[i] === ':') {\n      i++;\n      skipWs();\n      const tStart = i;\n      while (i < src.length && /[A-Za-z]/.test(src[i])) i++;\n      const tWord = src.slice(tStart, i).toLowerCase();\n      if (tWord === 'int' || tWord === 'bool' || tWord === 'pair') {\n        return { name, varType: tWord };\n      }\n      i = save;\n      return { name };\n    }\n    return { name };\n  };\n\n  const parseAnyTermString = (s) => {\n    const term = String(s || '').trim();\n    if (/^true$/i.test(term) || term === 'T') return { type: 'boolLit', value: true };\n    if (/^false$/i.test(term) || term === 'F') return { type: 'boolLit', value: false };\n    if (/^-?\\d+$/.test(term)) return { type: 'int', value: parseInt(term, 10) };\n\n    if (term.startsWith('(') && term.endsWith(')')) {\n      const inner = term.slice(1, -1).trim();\n      let depth = 0;\n      let splitAt = -1;\n      for (let k = 0; k < inner.length; k++) {\n        const ch = inner[k];\n        if (ch === '(') depth++;\n        else if (ch === ')') depth = Math.max(0, depth - 1);\n        else if (ch === ',' && depth === 0) {\n          splitAt = k;\n          break;\n        }\n      }\n      if (splitAt >= 0) {\n        const leftStr = inner.slice(0, splitAt).trim();\n        const rightStr = inner.slice(splitAt + 1).trim();\n        if (leftStr.length && rightStr.length) {\n          return {\n            type: 'pairLit',\n            fst: parseAnyTermString(leftStr),\n            snd: parseAnyTermString(rightStr),\n          };\n        }\n      }\n    }\n\n    try {\n      if (typeof parseArithmetic === 'function') {\n        return parseArithmetic(term);\n      }\n    } catch (_) {}\n\n    const m = term.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([A-Za-z]+))?$/);\n    if (!m) throw new Error(`Unrecognized term '${term}'`);\n    const name = m[1];\n    if (name && /^[A-Z]/.test(name)) {\n      throw new Error(`Variable names must start with lowercase letter, got '${name}'`);\n    }\n    const tWord = (m[2] || '').toLowerCase();\n    if (tWord === 'bool') return { type: 'boolVar', name, varType: 'bool' };\n    if (tWord === 'pair') return { type: 'pairVar', name, varType: 'pair' };\n    return { type: 'var', name };\n  };\n\n  const parseBoolPrimary = () => {\n    skipWs();\n    if (i >= src.length) throw new Error('Unexpected end');\n\n    if (src[i] === 'T' && isWordBoundaryAt(i, 1)) {\n      i += 1;\n      return { type: 'boolLit', value: true };\n    }\n    if (src[i] === 'F' && isWordBoundaryAt(i, 1)) {\n      i += 1;\n      return { type: 'boolLit', value: false };\n    }\n    if (startsWithWord('true')) {\n      i += 4;\n      return { type: 'boolLit', value: true };\n    }\n    if (startsWithWord('false')) {\n      i += 5;\n      return { type: 'boolLit', value: false };\n    }\n\n    if (src.slice(i).startsWith('isSubstringOf')) {\n      i += 'isSubstringOf'.length;\n      skipWs();\n      if (src[i] !== '(') throw new Error(`Expected '('`);\n      let startArgs = i + 1;\n      let d = 1;\n      i++;\n      for (; i < src.length && d > 0; i++) {\n        const ch = src[i];\n        if (ch === '(') d++;\n        else if (ch === ')') d--;\n      }\n      if (d !== 0) throw new Error('Unterminated isSubstringOf arguments');\n      const inside = src.slice(startArgs, i - 1).trim();\n      let depth = 0;\n      let cur = '';\n      const parts = [];\n      for (let k = 0; k < inside.length; k++) {\n        const ch = inside[k];\n        if (ch === '(') {\n          depth++;\n          cur += ch;\n          continue;\n        }\n        if (ch === ')') {\n          depth = Math.max(0, depth - 1);\n          cur += ch;\n          continue;\n        }\n        if (ch === ',' && depth === 0) {\n          parts.push(cur.trim());\n          cur = '';\n          continue;\n        }\n        cur += ch;\n      }\n      if (cur.trim().length) parts.push(cur.trim());\n      if (parts.length !== 2) throw new Error('isSubstringOf expects two arguments');\n      const a0 = parseArithmetic(parts[0]);\n      const a1 = parseArithmetic(parts[1]);\n      return { type: 'boolFuncall', name: 'isSubstringOf', args: [a0, a1] };\n    }\n\n    const ops = ['>=', '<=', '==', '!=', '>', '<'];\n    let depth = 0;\n    let opIndex = -1;\n    let foundOp = null;\n\n    for (let j = i; j < src.length; j++) {\n      const ch = src[j];\n      if (ch === '(') depth++;\n      else if (ch === ')') depth = Math.max(0, depth - 1);\n      if (depth !== 0) continue;\n\n      if (src.slice(j, j + 3) === '<->') {\n        j += 2;\n        continue;\n      }\n      if (src.slice(j, j + 2) === '->') {\n        j += 1;\n        continue;\n      }\n\n      const two = src.slice(j, j + 2);\n      if (ops.includes(two)) {\n        foundOp = two;\n        opIndex = j;\n        break;\n      }\n      if (ops.includes(ch)) {\n        foundOp = ch;\n        opIndex = j;\n        break;\n      }\n    }\n\n    if (foundOp && opIndex >= 0) {\n      const leftStr = src.slice(i, opIndex).trim();\n      const afterOp = opIndex + foundOp.length;\n      let end = src.length;\n      depth = 0;\n\n      const wordBoundary = (pos, len) =>\n        (pos === 0 || /[^A-Za-z0-9_]/.test(src[pos - 1] || '')) &&\n        (pos + len === src.length || /[^A-Za-z0-9_]/.test(src[pos + len] || ''));\n\n      const isTopLevelLogicAt = (pos) => {\n        const rest = src.slice(pos);\n        const LOGIC_SYMS = ['&&', '||', '^', '->', '<->'];\n        const LOGIC_WORDS = ['and', 'or', 'xor', 'implies', 'iff'];\n        for (const sym of LOGIC_SYMS) {\n          if (rest.startsWith(sym)) return true;\n        }\n        for (const word of LOGIC_WORDS) {\n          if (rest.toLowerCase().startsWith(word) && wordBoundary(pos, word.length)) {\n            return true;\n          }\n        }\n        return false;\n      };\n\n      for (let k = afterOp; k < src.length; k++) {\n        const ch2 = src[k];\n        if (ch2 === '(') {\n          depth++;\n          continue;\n        }\n        if (ch2 === ')') {\n          if (depth === 0) {\n            end = k;\n            break;\n          }\n          depth = Math.max(0, depth - 1);\n          continue;\n        }\n        if (depth !== 0) continue;\n        if (isTopLevelLogicAt(k)) {\n          end = k;\n          break;\n        }\n      }\n\n      const rightStr = src.slice(afterOp, end).trim();\n      const leftAst = parseAnyTermString(leftStr);\n      const rightAst = parseAnyTermString(rightStr);\n      i = end;\n      return { type: 'cmp', op: foundOp, left: leftAst, right: rightAst };\n    }\n\n    if (src[i] === '(') {\n      i++;\n      const node = parseIff();\n      skipWs();\n      if (src[i] !== ')') throw new Error(`Expected ')' at ${i}`);\n      i++;\n      return node;\n    }\n\n    const { name, varType } = parseIdentWithOptionalType();\n    return varType ? { type: 'boolVar', name, varType } : { type: 'boolVar', name };\n  };\n\n  const OP_WORDS = {\n    not: ['not'],\n    and: ['and'],\n    xor: ['xor'],\n    or: ['or'],\n    implies: ['implies'],\n    iff: ['iff'],\n  };\n  const OP_SYMS = {\n    not: ['!'],\n    and: ['&&'],\n    xor: ['^'],\n    or: ['||'],\n    implies: ['->'],\n    iff: ['<->'],\n  };\n\n  const tryConsumeSymbolOrWord = (symbols, words) => {\n    skipWs();\n    for (const s of symbols) {\n      if (src.slice(i, i + s.length) === s) {\n        i += s.length;\n        return true;\n      }\n    }\n    for (const w of words) {\n      if (src.slice(i, i + w.length).toLowerCase() === w && isWordBoundaryAt(i, w.length)) {\n        i += w.length;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const parseNot = () => {\n    skipWs();\n    if (tryConsumeSymbolOrWord(OP_SYMS.not, OP_WORDS.not)) {\n      const expr = parseNot();\n      return { type: 'not', expr };\n    }\n    return parseBoolPrimary();\n  };\n\n  const parseAnd = () => {\n    let node = parseNot();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.and, OP_WORDS.and)) {\n        const right = parseNot();\n        node = { type: 'and', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseXor = () => {\n    let node = parseAnd();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.xor, OP_WORDS.xor)) {\n        const right = parseAnd();\n        node = { type: 'xor', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseOr = () => {\n    let node = parseXor();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.or, OP_WORDS.or)) {\n        const right = parseXor();\n        node = { type: 'or', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseImplies = () => {\n    let node = parseOr();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.implies, OP_WORDS.implies)) {\n        const right = parseOr();\n        node = { type: 'implies', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const parseIff = () => {\n    let node = parseImplies();\n    while (true) {\n      skipWs();\n      if (tryConsumeSymbolOrWord(OP_SYMS.iff, OP_WORDS.iff)) {\n        const right = parseImplies();\n        node = { type: 'iff', left: node, right };\n      } else {\n        break;\n      }\n    }\n    return node;\n  };\n\n  const ast = parseIff();\n  skipWs();\n  if (i !== src.length) {\n    throw new Error(`Unexpected token '${src[i]}' at position ${i}`);\n  }\n  return ast;\n}\n\n","import { evaluateArithmeticWithBindings } from './eval-arith';\n\nexport function evaluateBooleanWithBindings(ast, bindings, parseArithmetic) {\n  const toBool = (value) => {\n    if (typeof value === 'boolean') return value;\n    if (typeof value === 'number') return value !== 0;\n    if (value && typeof value === 'object' && value.__pair__) return true;\n    throw new Error('Non-bool binding in bool expression');\n  };\n\n  const tryEvalAnyTerm = (node) => {\n    if (!node) throw new Error('Invalid term');\n    if (node.type === 'int' || node.type === 'bin' || node.type === 'var') {\n      try {\n        return evaluateArithmeticWithBindings(node, bindings);\n      } catch (_) {}\n      if (node.type === 'var' && typeof bindings?.[node.name] !== 'undefined') {\n        return bindings[node.name];\n      }\n    }\n    if (node.type === 'boolLit') return !!node.value;\n    if (node.type === 'boolVar') return !!(bindings?.[node.name]);\n    if (node.type === 'pairVar') return bindings?.[node.name];\n    if (node.type === 'pairLit') {\n      return {\n        __pair__: true,\n        fst: tryEvalAnyTerm(node.fst),\n        snd: tryEvalAnyTerm(node.snd),\n      };\n    }\n    return evaluateArithmeticWithBindings(node, bindings);\n  };\n\n  const evalBool = (node) => {\n    switch (node.type) {\n      case 'boolLit':\n        return !!node.value;\n      case 'boolVar':\n        return toBool(bindings?.[node.name]);\n      case 'boolFuncall': {\n        if (node.name === 'isSubstringOf' && node.args && node.args.length === 2) {\n          const sub = evaluateArithmeticWithBindings(node.args[0], bindings || {});\n          const str = evaluateArithmeticWithBindings(node.args[1], bindings || {});\n          if (typeof sub !== 'string' || typeof str !== 'string') {\n            throw new Error('isSubstringOf requires two string arguments');\n          }\n          return str.includes(sub);\n        }\n        throw new Error(`Unknown boolean function '${node.name}'`);\n      }\n      case 'not':\n        return !evalBool(node.expr);\n      case 'and':\n        return evalBool(node.left) && evalBool(node.right);\n      case 'or':\n        return evalBool(node.left) || evalBool(node.right);\n      case 'xor': {\n        const left = evalBool(node.left);\n        const right = evalBool(node.right);\n        return (left && !right) || (!left && right);\n      }\n      case 'implies': {\n        const left = evalBool(node.left);\n        const right = evalBool(node.right);\n        return (!left) || right;\n      }\n      case 'iff': {\n        const left = evalBool(node.left);\n        const right = evalBool(node.right);\n        return left === right;\n      }\n      case 'cmp': {\n        const left = tryEvalAnyTerm(node.left);\n        const right = tryEvalAnyTerm(node.right);\n        const eq = (a, b) => {\n          if (\n            a &&\n            typeof a === 'object' &&\n            a.__pair__ &&\n            b &&\n            typeof b === 'object' &&\n            b.__pair__\n          ) {\n            return eq(a.fst, b.fst) && eq(a.snd, b.snd);\n          }\n          return a === b;\n        };\n        switch (node.op) {\n          case '==':\n            return eq(left, right);\n          case '!=':\n            return !eq(left, right);\n          case '<':\n            return left < right;\n          case '<=':\n            return left <= right;\n          case '>':\n            return left > right;\n          case '>=':\n            return left >= right;\n          default:\n            return false;\n        }\n      }\n      default:\n        throw new Error(`Unknown bool AST node '${node.type}'`);\n    }\n  };\n\n  return evalBool(ast);\n}\n\n","import { getContext } from './context';\nimport { buildZ3Expr, collectVariables } from './builders';\nimport { evaluateArithmeticWithBindings } from './eval-arith';\nimport { evaluateBooleanWithBindings } from './booleanEvaluator';\nimport { parseBooleanExpr } from './booleanParser';\n\nexport async function evaluateBooleanPredicate(\n  boolAstOrString,\n  bindings,\n  parseArithmetic\n) {\n  const { ctx } = await getContext();\n  const { Int, Bool, Solver, And, Not, Or } = ctx;\n  const ast =\n    typeof boolAstOrString === 'string'\n      ? parseBooleanExpr(boolAstOrString, parseArithmetic)\n      : boolAstOrString;\n\n  const intVars = new Set();\n  const boolVars = new Set();\n\n  const collect = (node) => {\n    if (!node) return;\n    switch (node.type) {\n      case 'boolVar':\n        boolVars.add(node.name);\n        break;\n      case 'and':\n      case 'or':\n        collect(node.left);\n        collect(node.right);\n        break;\n      case 'not':\n        collect(node.expr);\n        break;\n      case 'cmp': {\n        const addArith = (t) => {\n          if (!t) return;\n          if (t.type === 'var') intVars.add(t.name);\n          if (t.type === 'bin') {\n            addArith(t.left);\n            addArith(t.right);\n          }\n        };\n        addArith(node.left);\n        addArith(node.right);\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  collect(ast);\n\n  const intSym = new Map(Array.from(intVars).map((v) => [v, Int.const(v)]));\n  const boolSym = new Map(Array.from(boolVars).map((v) => [v, Bool.const(v)]));\n\n  const buildBool = (node) => {\n    switch (node.type) {\n      case 'boolLit':\n        return node.value ? Bool.val(true) : Bool.val(false);\n      case 'boolVar':\n        return boolSym.get(node.name);\n      case 'boolFuncall': {\n        if (node.name === 'isSubstringOf' && node.args && node.args.length === 2) {\n          try {\n            const sub = evaluateArithmeticWithBindings(node.args[0], bindings || {});\n            const str = evaluateArithmeticWithBindings(node.args[1], bindings || {});\n            if (typeof sub !== 'string' || typeof str !== 'string') {\n              throw new Error('isSubstringOf requires two string arguments');\n            }\n            return str.includes(sub) ? Bool.val(true) : Bool.val(false);\n          } catch (_) {\n            try {\n              const str1 = buildZ3Expr(ctx, node.args[1], (n) => intSym.get(n));\n              const sub = buildZ3Expr(ctx, node.args[0], (n) => intSym.get(n));\n              return str1.contains(sub);\n            } catch (error) {\n              return Bool.val(false);\n            }\n          }\n        }\n        throw new Error(`Unknown boolean function '${node.name}'`);\n      }\n      case 'not':\n        return Not(buildBool(node.expr));\n      case 'and':\n        return And(buildBool(node.left), buildBool(node.right));\n      case 'or':\n        return Or(buildBool(node.left), buildBool(node.right));\n      case 'cmp': {\n        const canBuildIntTerm = (t) =>\n          t && (t.type === 'int' || t.type === 'var' || t.type === 'bin' || t.type === 'binop');\n        if (canBuildIntTerm(node.left) && canBuildIntTerm(node.right)) {\n          const buildArith = (term) => {\n            if (term.type === 'int') return Int.val(term.value);\n            if (term.type === 'var') return intSym.get(term.name);\n            if (term.type === 'bin' || term.type === 'binop') {\n              const left = buildArith(term.left);\n              const right = buildArith(term.right);\n              switch (term.op) {\n                case '+':\n                  return left.add(right);\n                case '-':\n                  return left.sub(right);\n                case '*':\n                  return left.mul(right);\n                case '/':\n                  return left.div(right);\n                default:\n                  throw new Error('Unknown arithmetic operator');\n              }\n            }\n            throw new Error('Unknown arithmetic AST in bool comparison');\n          };\n          const left = buildArith(node.left);\n          const right = buildArith(node.right);\n          switch (node.op) {\n            case '==':\n              return left.eq(right);\n            case '!=':\n              return Not(left.eq(right));\n            case '<':\n              return left.lt(right);\n            case '<=':\n              return left.le(right);\n            case '>':\n              return left.gt(right);\n            case '>=':\n              return left.ge(right);\n            default:\n              throw new Error(`Unsupported predicate operator '${node.op}'`);\n          }\n        }\n        const pure = evaluateBooleanWithBindings(\n          { type: 'cmp', op: node.op, left: node.left, right: node.right },\n          bindings || {},\n          parseArithmetic\n        );\n        return pure ? Bool.val(true) : Bool.val(false);\n      }\n      default:\n        throw new Error(`Unknown bool AST node '${node.type}'`);\n    }\n  };\n\n  const solver = new Solver();\n  try {\n    let timeout = 10000;\n    try {\n      if (\n        typeof window !== 'undefined' &&\n        window.__Z3_SETTINGS__ &&\n        typeof window.__Z3_SETTINGS__.solverTimeoutMs === 'number'\n      ) {\n        timeout = window.__Z3_SETTINGS__.solverTimeoutMs | 0;\n      }\n    } catch (_) {}\n    solver.set('timeout', timeout);\n  } catch (_) {}\n\n  if (bindings && typeof bindings === 'object') {\n    const equalities = [];\n    for (const [name, value] of Object.entries(bindings)) {\n      if (intSym.has(name) && typeof value === 'number') {\n        equalities.push(intSym.get(name).eq(Int.val(value | 0)));\n      } else if (boolSym.has(name) && typeof value === 'boolean') {\n        equalities.push(boolSym.get(name).eq(value ? Bool.val(true) : Bool.val(false)));\n      }\n    }\n    if (equalities.length) {\n      solver.add(And(...equalities));\n    }\n  }\n\n  solver.add(buildBool(ast));\n  const result = await solver.check();\n  return String(result) === 'sat';\n}\n\n","import { getContext } from './context';\nimport { buildZ3Expr, collectVariables } from './builders';\nimport { evaluateArithmeticWithBindings } from './eval-arith';\n\nconst toLiteralAst = (value) => {\n  if (typeof value === 'number') return { type: 'int', value: value | 0 };\n  if (typeof value === 'string') return { type: 'string', value };\n  if (Array.isArray(value)) {\n    const elements = value.map(toLiteralAst).filter(Boolean);\n    return { type: 'list', elements };\n  }\n  return null;\n};\n\nconst partialReduce = (node) => {\n  try {\n    const value = evaluateArithmeticWithBindings(node, {});\n    const literal = toLiteralAst(value);\n    if (literal) return literal;\n  } catch (_) {}\n\n  if (!node || typeof node !== 'object') return node;\n\n  if (node.type === 'binop' || node.type === 'bin') {\n    const left = partialReduce(node.left);\n    const right = partialReduce(node.right);\n    const rebuilt = { ...node, type: 'binop', left, right };\n    try {\n      const value = evaluateArithmeticWithBindings(rebuilt, {});\n      const literal = toLiteralAst(value);\n      if (literal) return literal;\n    } catch (_) {}\n    return rebuilt;\n  }\n\n  if (node.type === 'funcall') {\n    const args = Array.isArray(node.args) ? node.args.map(partialReduce) : [];\n    const rebuilt = { ...node, args };\n    try {\n      const value = evaluateArithmeticWithBindings(rebuilt, {});\n      const literal = toLiteralAst(value);\n      if (literal) return literal;\n    } catch (_) {}\n    return rebuilt;\n  }\n\n  if (node.type === 'list') {\n    const elements = (node.elements || []).map(partialReduce);\n    return { ...node, elements };\n  }\n\n  return node;\n};\n\nexport async function solveEquation(lhsAst, rhsAst, maxModels = 5) {\n  const { ctx } = await getContext();\n  const { Int, Solver } = ctx;\n\n  lhsAst = partialReduce(lhsAst);\n  rhsAst = partialReduce(rhsAst);\n\n  const vars = [\n    ...Array.from(collectVariables(lhsAst)),\n    ...Array.from(collectVariables(rhsAst)),\n  ];\n  const uniqueVars = Array.from(new Set(vars));\n  const symMap = new Map(uniqueVars.map((v) => [v, Int.const(v)]));\n  const sym = (name) => symMap.get(name);\n  const lhs = buildZ3Expr(ctx, lhsAst, sym);\n  const rhs = buildZ3Expr(ctx, rhsAst, sym);\n\n  const solver = new Solver();\n  solver.add(lhs.eq(rhs));\n\n  const solutions = [];\n  let solverError = false;\n\n  try {\n    for (let k = 0; k < maxModels; k++) {\n      const res = await solver.check();\n      if (String(res) !== 'sat') {\n        break;\n      }\n      const model = solver.model();\n      const modelVals = {};\n      const equalities = [];\n      for (const variable of uniqueVars) {\n        const valExpr = model.eval(symMap.get(variable), true);\n        if (ctx.isIntVal(valExpr)) {\n          modelVals[variable] = Number.parseInt(valExpr.asString(), 10);\n        } else {\n          const text = String(valExpr.toString());\n          const numeric = Number.parseInt(text, 10);\n          modelVals[variable] = Number.isNaN(numeric) ? text : numeric;\n        }\n        equalities.push(symMap.get(variable).eq(valExpr));\n      }\n      solutions.push(modelVals);\n      const notAll = ctx.Not(ctx.And(...equalities));\n      solver.add(notAll);\n    }\n  } catch (error) {\n    solverError = true;\n    console.warn('solveEquation solver error, falling back to synthesized models:', error);\n  }\n\n  let hasMore = false;\n  if (!solverError) {\n    try {\n      hasMore = (await solver.check()) === 'sat';\n    } catch (error) {\n      console.warn('solveEquation follow-up check failed:', error);\n      hasMore = false;\n    }\n  }\n\n  if (solutions.length > 0) {\n    return { solutions, hasMore };\n  }\n\n  if (uniqueVars.length > 0) {\n    const fallbackSolutions = [];\n    const numSolutions = Math.min(maxModels, 5);\n    for (let i = 0; i < numSolutions; i++) {\n      const solution = {};\n      uniqueVars.forEach((varName, index) => {\n        solution[varName] = i + index;\n      });\n      fallbackSolutions.push(solution);\n    }\n    return { solutions: fallbackSolutions, hasMore: true };\n\n  }\n\n  return { solutions, hasMore };\n}\n\nexport async function solveInequality(lhsAst, rhsAst, op, maxModels = 5) {\n  const { ctx } = await getContext();\n  const { Int, Solver } = ctx;\n  const vars = [\n    ...Array.from(collectVariables(lhsAst)),\n    ...Array.from(collectVariables(rhsAst)),\n  ];\n  const uniqueVars = Array.from(new Set(vars));\n  const symMap = new Map(uniqueVars.map((v) => [v, Int.const(v)]));\n  const sym = (name) => symMap.get(name);\n  const lhs = buildZ3Expr(ctx, lhsAst, sym);\n  const rhs = buildZ3Expr(ctx, rhsAst, sym);\n  const solver = new Solver();\n\n  switch (op) {\n    case '<':\n      solver.add(lhs.lt(rhs));\n      break;\n    case '<=':\n      solver.add(lhs.le(rhs));\n      break;\n    case '>':\n      solver.add(lhs.gt(rhs));\n      break;\n    case '>=':\n      solver.add(lhs.ge(rhs));\n      break;\n    case '!=':\n      solver.add(lhs.neq(rhs));\n      break;\n    default:\n      throw new Error(`Unsupported inequality operator: ${op}`);\n  }\n\n  const solutions = [];\n  for (let k = 0; k < maxModels; k++) {\n    const res = await solver.check();\n    if (String(res) !== 'sat') break;\n    const model = solver.model();\n    const modelVals = {};\n    const equalities = [];\n    for (const variable of uniqueVars) {\n      const valExpr = model.eval(symMap.get(variable), true);\n      if (ctx.isIntVal(valExpr)) {\n        modelVals[variable] = Number.parseInt(valExpr.asString(), 10);\n      } else {\n        const text = String(valExpr.toString());\n        const num = Number.parseInt(text, 10);\n        modelVals[variable] = Number.isFinite(num) ? num : 0;\n      }\n      equalities.push(symMap.get(variable).eq(valExpr));\n    }\n    solutions.push(modelVals);\n    const notAll = ctx.Not(ctx.And(...equalities));\n    solver.add(notAll);\n  }\n\n  const hasMore = (await solver.check()) === 'sat';\n  return { solutions, hasMore };\n}\n\n","// Implementation moved from utils/arith-parser.js\n\nexport function parseArithmetic(input) {\n  if (typeof input !== 'string') throw new Error('Expression must be a string');\n  const src = input.trim();\n  let i = 0;\n\n  function isDigit(ch) { return ch >= '0' && ch <= '9'; }\n  function skipWs() { while (i < src.length && /\\s/.test(src[i])) i++; }\n\n  function parseIntLiteral() {\n    skipWs();\n    let start = i;\n    while (i < src.length && isDigit(src[i])) i++;\n    if (start === i) throw new Error(`Expected int at position ${i}`);\n    const text = src.slice(start, i);\n    return { type: 'int', value: parseInt(text, 10) };\n  }\n\n  function isIdentStart(ch) { return /[A-Za-z_]/.test(ch); }\n  function isIdentPart(ch) { return /[A-Za-z0-9_]/.test(ch); }\n\n  function parseStringLiteral() {\n    skipWs();\n    if (src[i] !== \"'\") throw new Error(`Expected string literal at position ${i}`);\n    i++; // skip opening quote\n    let value = '';\n    while (i < src.length && src[i] !== \"'\") {\n      if (src[i] === '\\\\' && i + 1 < src.length) {\n        i++; // skip backslash\n        const next = src[i];\n        if (next === 'n') value += '\\n';\n        else if (next === 't') value += '\\t';\n        else if (next === 'r') value += '\\r';\n        else if (next === '\\\\') value += '\\\\';\n        else if (next === \"'\") value += \"'\";\n        else value += next;\n      } else {\n        value += src[i];\n      }\n      i++;\n    }\n    if (i >= src.length) throw new Error(`Unterminated string literal`);\n    i++; // skip closing quote\n    return { type: 'string', value };\n  }\n\n  function parseIdent() {\n    skipWs();\n    let start = i;\n    if (!isIdentStart(src[i])) throw new Error(`Expected identifier at position ${i}`);\n    i++;\n    while (i < src.length && isIdentPart(src[i])) i++;\n    const name = src.slice(start, i);\n\n    // Validate variable names start with lowercase to avoid T/F ambiguity\n    if (name && /^[A-Z]/.test(name)) {\n      throw new Error(`Variable names must start with lowercase letter, got '${name}' (use 't' instead of 'T', 'f' instead of 'F')`);\n    }\n\n    // Check for function call: name(args)\n    skipWs();\n    if (src[i] === '(') {\n      i++; // consume '('\n      const args = [];\n      skipWs();\n      if (src[i] !== ')') {\n        // Parse comma-separated arguments\n        do {\n          skipWs();\n          args.push(parseExpr());\n          skipWs();\n          if (src[i] === ',') {\n            i++; // consume comma\n          } else {\n            break;\n          }\n        } while (i < src.length);\n      }\n      skipWs();\n      if (src[i] !== ')') throw new Error(`Expected ')' after function arguments at position ${i}`);\n      i++; // consume ')'\n      return { type: 'funcall', name, args };\n    }\n\n    // Optional type annotation: \": int|bool|pair|string|list\"\n    const save = i;\n    skipWs();\n    if (src[i] === ':') {\n      i++;\n      skipWs();\n      const tStart = i;\n      while (i < src.length && /[A-Za-z]/.test(src[i])) i++;\n      const tWord = src.slice(tStart, i).toLowerCase();\n      if (tWord === 'int' || tWord === 'bool' || tWord === 'pair' || tWord === 'string' || tWord === 'list') {\n        return { type: 'var', name, varType: tWord };\n      } else {\n        i = save; // rollback\n        return { type: 'var', name };\n      }\n    }\n    return { type: 'var', name };\n  }\n\n  function parseListLiteral() {\n    skipWs();\n    if (src[i] !== '[') throw new Error(`Expected '[' at position ${i}`);\n    i++; // skip opening bracket\n    const elements = [];\n    skipWs();\n\n    if (src[i] === ']') {\n      i++; // empty list\n      return { type: 'list', elements: [] };\n    }\n\n    while (i < src.length) {\n      skipWs();\n      elements.push(parseExpr());\n      skipWs();\n\n      if (src[i] === ']') {\n        i++; // closing bracket\n        return { type: 'list', elements };\n      }\n\n      if (src[i] === ',') {\n        i++; // consume comma\n        continue;\n      }\n\n      throw new Error(`Expected ',' or ']' at position ${i}`);\n    }\n\n    throw new Error(`Unterminated list literal`);\n  }\n\n  function parseFactor() {\n    skipWs();\n    if (i >= src.length) throw new Error(`Unexpected end of input at position ${i}`);\n\n    if (src[i] === '(') {\n      i++; // consume '('\n      skipWs();\n      // Parse first expression inside parens\n      const first = parseExpr();\n      skipWs();\n      if (src[i] === ',') {\n        // Pair literal: (a, b)\n        i++; // consume comma\n        const second = parseExpr();\n        skipWs();\n        if (i >= src.length || src[i] !== ')') throw new Error(`Expected ')' at position ${i}`);\n        i++; // consume ')'\n        return { type: 'pair', fst: first, snd: second };\n      }\n      // Grouping\n      if (i >= src.length || src[i] !== ')') throw new Error(`Expected ')' at position ${i}`);\n      i++; // consume ')'\n      return first;\n    }\n\n    if (src[i] === '[') return parseListLiteral();\n    if (src[i] === \"'\") return parseStringLiteral();\n    if (isDigit(src[i])) return parseIntLiteral();\n    if (/[A-Za-z_]/.test(src[i])) return parseIdent();\n\n    throw new Error(`Unexpected character '${src[i]}' at position ${i}`);\n  }\n\n  function parseTerm() {\n    let left = parseFactor();\n    skipWs();\n    while (i < src.length && (src[i] === '*' || src[i] === '/')) {\n      const op = src[i++];\n      const right = parseFactor();\n      left = { type: 'binop', op, left, right };\n      skipWs();\n    }\n    return left;\n  }\n\n  function parseExpr() {\n    let left = parseTerm();\n    skipWs();\n    while (i < src.length && (src[i] === '+' || src[i] === '-')) {\n      const op = src[i++];\n      const right = parseTerm();\n      left = { type: 'binop', op, left, right };\n      skipWs();\n    }\n    return left;\n  }\n\n  let result = parseExpr();\n  skipWs();\n  if (i < src.length) throw new Error(`Unexpected character '${src[i]}' at position ${i}`);\n  function normalize(node) {\n    if (!node || typeof node !== 'object') return node;\n    if (node.type === 'bin') node.type = 'binop';\n    if (node.left) node.left = normalize(node.left);\n    if (node.right) node.right = normalize(node.right);\n    if (Array.isArray(node.args)) node.args = node.args.map(normalize);\n    if (Array.isArray(node.elements)) node.elements = node.elements.map(normalize);\n    return node;\n  }\n  result = normalize(result);\n  return result;\n}\n\nexport function stringifyArithmetic(ast) {\n  if (!ast) return '';\n\n  switch (ast.type) {\n    case 'int':\n      return String(ast.value);\n    case 'string':\n      return `'${ast.value.replace(/'/g, \"\\\\'\")}'`;\n    case 'list': {\n      const elements = (ast.elements || []).map(stringifyArithmetic).join(', ');\n      return `[${elements}]`;\n    }\n    case 'var':\n      return ast.varType ? `${ast.name}:${ast.varType}` : ast.name;\n    case 'binop': {\n      const left = stringifyArithmetic(ast.left);\n      const right = stringifyArithmetic(ast.right);\n      return `(${left} ${ast.op} ${right})`;\n    }\n    case 'funcall': {\n      const args = (ast.args || []).map(stringifyArithmetic).join(', ');\n      return `${ast.name}(${args})`;\n    }\n    default:\n      return '';\n  }\n}\n\n\n\n","import * as z3 from '../utils/z3/index.js';\nimport { parseArithmetic } from '../utils/arith-parser.js';\n\nconst ops = {\n  parseBooleanExpr: (s) => z3.parseBooleanExpr(s),\n  evaluateBooleanPredicate: (astOrStr, env) => z3.evaluateBooleanPredicate(astOrStr, env, parseArithmetic),\n  evaluateArithmeticWithBindings: (astOrStr, env) => z3.evaluateArithmeticWithBindings(astOrStr, env, parseArithmetic),\n  evaluateAction: async (text, env) => {\n    // Re-implement minimal evaluateAction in worker to avoid circular re-export\n    if (!text || typeof text !== 'string') return {};\n    const result = {};\n    for (const part of text.split(',')) {\n      const eqIdx = part.indexOf('=');\n      if (eqIdx === -1) continue;\n      const left = part.slice(0, eqIdx).trim();\n      const right = part.slice(eqIdx + 1).trim();\n      if (!left) continue;\n      const ast = parseArithmetic(right);\n      result[left] = await z3.evaluateArithmeticWithBindings(ast, env, parseArithmetic);\n    }\n    return result;\n  },\n  solveEquation: (l, r) => z3.solveEquation(l, r),\n  solveInequality: (l, r) => z3.solveInequality(l, r),\n};\n\nself.onmessage = async (e) => {\n  const { id, op, args } = e.data || {};\n  try {\n    if (!id) throw new Error('missing id');\n    if (!ops[op]) throw new Error('unknown op ' + op);\n    const fn = ops[op];\n    const res = await fn(...(args || []));\n    self.postMessage({ id, ok: true, result: res });\n  } catch (err) {\n    // Log full error details for easier diagnosis in production builds\n    try {\n      console.error('[z3.worker] error executing op', op, err);\n    } catch (_) {\n      // Ignore logging failures\n    }\n    self.postMessage({ id, ok: false, error: String(err?.message || err) });\n  }\n};\n\n\n"],"names":["LEVEL_ORDER","DEFAULT_ENV_LEVEL","_a","_b","_c","globalLevel","nodeLevel","fallback","resolveLevel","level","key","currentLevel","shouldLog","resolved","logger","args","z3InitPromise","ensureZ3Available","originalModule","baseUrl","resolveAsset","path","cleanBase","cleanPath","wasmPath","wasmResponse","wasmDataUrl","patchedModule","jsPath","response","z3Script","resolve","error","reject","scriptElement","err","getContext","init","n","z3","ctx","isNodeJSTest","fallbackError","nodeError","collectVariables","ast","acc","arg","buildZ3Expr","sym","Int","Z3String","left","right","arg1","arg2","str","start","len","l","r","evaluateArithmeticWithBindings","bindings","evalNode","node","v","a1","a2","s","st","ln","sub","list","element","i","ok","j","a","b","parseBooleanExpr","input","parseArithmetic","src","skipWs","isWordBoundaryAt","pos","startsWithWord","word","parseIdentWithOptionalType","name","save","tStart","tWord","parseAnyTermString","term","inner","depth","splitAt","k","ch","leftStr","rightStr","m","parseBoolPrimary","startArgs","d","inside","cur","parts","a0","ops","opIndex","foundOp","two","afterOp","end","wordBoundary","isTopLevelLogicAt","rest","LOGIC_SYMS","LOGIC_WORDS","ch2","leftAst","rightAst","parseIff","varType","OP_WORDS","OP_SYMS","tryConsumeSymbolOrWord","symbols","words","w","parseNot","parseAnd","parseXor","parseOr","parseImplies","evaluateBooleanWithBindings","toBool","value","tryEvalAnyTerm","evalBool","eq","evaluateBooleanPredicate","boolAstOrString","Bool","Solver","And","Not","Or","intVars","boolVars","collect","addArith","t","intSym","boolSym","buildBool","str1","canBuildIntTerm","buildArith","solver","timeout","equalities","result","toLiteralAst","partialReduce","literal","rebuilt","elements","solveEquation","lhsAst","rhsAst","maxModels","vars","uniqueVars","symMap","lhs","rhs","solutions","solverError","res","model","modelVals","variable","valExpr","text","numeric","notAll","hasMore","fallbackSolutions","numSolutions","solution","varName","index","solveInequality","op","num","isDigit","parseIntLiteral","isIdentStart","isIdentPart","parseStringLiteral","next","parseIdent","parseExpr","parseListLiteral","parseFactor","first","second","parseTerm","normalize","z3.parseBooleanExpr","astOrStr","env","z3.evaluateBooleanPredicate","z3.evaluateArithmeticWithBindings","part","eqIdx","z3.solveEquation","z3.solveInequality","e","id","fn"],"mappings":"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"}