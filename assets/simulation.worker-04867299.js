const it={transitionsChanged:"transitionsChanged",transitionFired:"transitionFired"};class wt{constructor(){this.isInitialized=!1,this.petriNet=null,this.eventBus=null,this.simulationMode="single"}async initialize(e,t={}){if(!this.validatePetriNet(e))throw new Error("Invalid Petri net structure");this.petriNet=this.normalizeNet(e),this.isInitialized=!0,this.simulationMode=t.simulationMode||"single",await this.initializeSpecific(this.petriNet,t)}async initializeSpecific(e,t){}async update(e){if(!this.isInitialized)throw new Error("Simulator not initialized");if(!this.validatePetriNet(e))throw new Error("Invalid Petri net structure");this.petriNet=this.normalizeNet(e),await this.updateSpecific(this.petriNet)}async updateSpecific(e){}async getEnabledTransitions(){return this.isInitialized?await this.getEnabledTransitionsSpecific():[]}async getEnabledTransitionsSpecific(){return[]}async fireTransition(e,t={}){if(!this.isInitialized)throw new Error("Simulator not initialized");if(!(t.skipEnabledCheck||!1)&&!(await this.getEnabledTransitions()).includes(e))throw new Error(`Transition ${e} is not enabled`);return await this.fireTransitionSpecific(e,t)}async fireTransitionSpecific(e){return this.petriNet}async stepSimulation(){if(!this.isInitialized)throw new Error("Simulator not initialized");return await this.stepSimulationSpecific()}async stepSimulationSpecific(){return this.petriNet}reset(){this.isInitialized=!1,this.petriNet=null,this.simulationMode="single",this.resetSpecific()}resetSpecific(){}setEventBus(e){this.eventBus=e}emitTransitionsChanged(e={}){if(!this.eventBus)return;const t=Array.isArray(e.enabled)?e.enabled:[],r=Array.isArray(e.previouslyEnabled)?e.previouslyEnabled:[],i=typeof e.hasEnabled=="boolean"?e.hasEnabled:t.length>0;this.eventBus.emit(it.transitionsChanged,{enabled:t,previouslyEnabled:r,hasEnabled:i})}emitTransitionFired(e={}){if(!this.eventBus)return;const{transitionId:t,newPetriNet:r}=e||{};t&&this.eventBus.emit(it.transitionFired,{transitionId:t,newPetriNet:r})}getType(){throw new Error("getType() must be implemented by subclasses")}validatePetriNet(e){if(!e||typeof e!="object")return!1;const{places:t,transitions:r,arcs:i}=e;return!(!Array.isArray(t)||!Array.isArray(r)||!Array.isArray(i))}normalizeNet(e){const t=JSON.parse(JSON.stringify(e||{places:[],transitions:[],arcs:[]})),r=Array.isArray(t.places)?t.places:[],i=Array.isArray(t.transitions)?t.transitions:[],s=Array.isArray(t.arcs)?t.arcs:[],n=new Set(r.map(o=>String(o.id))),c=new Set(i.map(o=>String(o.id)));for(const o of r){if(o.id=String(o.id),Array.isArray(o.valueTokens)){const u=o.valueTokens.length;(!Number.isFinite(o.tokens)||o.tokens!==u)&&(o.tokens=u)}else Number.isFinite(o.tokens)||(o.tokens=0);!o.label&&o.name&&(o.label=o.name),!o.name&&o.label&&(o.name=o.label)}for(const o of s){o.id!==void 0&&(o.id=String(o.id));const u=o.sourceId||o.source,d=o.targetId||o.target;o.sourceId=String(u),o.targetId=String(d),o.source===void 0&&(o.source=o.sourceId),o.target===void 0&&(o.target=o.targetId);const f=Number(o.weight);o.weight=Number.isFinite(f)&&f>0?f:1,Array.isArray(o.bindings)||(o.binding?o.bindings=[String(o.binding)]:o.bindings=[]),o.sourceType||(o.sourceType=n.has(o.sourceId)?"place":c.has(o.sourceId)?"transition":o.sourceType),o.targetType||(o.targetType=n.has(o.targetId)?"place":c.has(o.targetId)?"transition":o.targetType)}return t.places=r,t.transitions=i,t.arcs=s,t}isReady(){return this.isInitialized&&this.petriNet!==null}getSimulationStats(){if(!this.isInitialized)return{enabledTransitions:[],totalTokens:0,totalPlaces:0,totalTransitions:0};const{places:e,transitions:t}=this.petriNet,r=e.reduce((i,s)=>i+(s.tokens||0),0);return{enabledTransitions:[],totalTokens:r,totalPlaces:e.length,totalTransitions:t.length}}}function Tt(a,e){const t=new Map;for(const r of a)r.srcId&&(t.has(r.srcId)||t.set(r.srcId,[]),t.get(r.srcId).push(r));for(const[r,i]of t.entries()){const s=e[r];if(!s)continue;const n=i.filter(o=>o.countFallback).length;if(n>0){const o=Number(s.tokens||0);s.tokens=Math.max(0,o-n)}const c=i.filter(o=>!o.countFallback);if(Array.isArray(s.valueTokens)&&c.length>0){c.sort((o,u)=>u.tokenIndex-o.tokenIndex);for(const o of c)o.tokenIndex>=0&&o.tokenIndex<s.valueTokens.length&&s.valueTokens.splice(o.tokenIndex,1);s.tokens=s.valueTokens.length}}}function xt(a,e,t,r,i){const{evaluateArithmeticWithBindings:s,evaluateBooleanWithBindings:n,evaluatePatternLiteral:c,parseArithmetic:o}=i;for(const u of a){const d=u.targetId,f=r[d];if(!f)continue;const w=e.get(u.id)||[];if(w.length>0){Array.isArray(f.valueTokens)||(f.valueTokens=[]);for(const m of w)try{let h;const{kind:E,ast:l}=m;l&&(l.type==="var"||l.type==="boolVar"||l.type==="pairVar")?h=(t||{})[l.name]:E==="arith"?h=s(l,t):E==="bool"?h=n(l,t,o):E==="pattern"?h=c(l,t||{}):E==="pair"&&l.type==="pairLit"&&(h=c(l,t||{})),Array.isArray(f.valueTokens)||(f.valueTokens=[]),typeof h=="number"?f.valueTokens.push(h|0):typeof h=="boolean"||typeof h=="string"||Nt(h)?f.valueTokens.push(h):Array.isArray(h)&&(E==="arith"||E==="pair"||l&&(l.type==="list"||l.type==="listPattern"||l.type==="tuplePattern")?f.valueTokens.push(h):f.valueTokens.push(...h))}catch{}}else if(u.weight&&(u.weight|0)>0){const m=u.weight|0;for(let h=0;h<m;h++){const E=Object.values(t||{});if(Array.isArray(f.valueTokens)){const l=E[0];f.valueTokens.push(typeof l=="boolean"?!!l:Number.isFinite(l)?l|0:1)}else f.tokens=Number(f.tokens||0)+1|0}}else Array.isArray(f.valueTokens)?f.valueTokens.push(1):f.tokens=Number(f.tokens||0)+1|0;Array.isArray(f.valueTokens)&&(f.tokens=f.valueTokens.length)}}function Nt(a){return!!(a&&typeof a=="object"&&a.__pair__===!0&&"fst"in a&&"snd"in a)}const rt={silent:0,error:1,warn:2,info:3,debug:4},zt=(()=>{var r,i,s;const a=typeof globalThis<"u"?globalThis.__PETRI_NET_LOG_LEVEL__:void 0,e=typeof process<"u"?((r=process.env)==null?void 0:r.VITE_LOG_LEVEL)||((i=process.env)==null?void 0:i.LOG_LEVEL):void 0,t=typeof process<"u"&&((s=process.env)==null?void 0:s.NODE_ENV)==="production"?"warn":"debug";return(a||e||t||"warn").toLowerCase()})();function St(a){if(!a)return"warn";const e=String(a).toLowerCase();return rt[e]!==void 0?e:"warn"}let It=St(zt);function Y(a){const e=St(a);return rt[e]<=rt[It]}const v={debug:(...a)=>{Y("debug")&&console.debug(...a)},info:(...a)=>{Y("info")&&console.info(...a)},warn:(...a)=>{Y("warn")&&console.warn(...a)},error:(...a)=>{Y("error")&&console.error(...a)}};class Mt extends wt{constructor(){super(),this.maxTokens=1/0}getType(){return"pt"}async initializeSpecific(e,t={}){const r=Number(t.maxTokens);this.maxTokens=Number.isFinite(r)&&r>=0?r:1/0,this.validatePTNet(e),this.initializeTokens(e),v.debug("P/T Simulator initialized with",e.places.length,"places and",e.transitions.length,"transitions")}async updateSpecific(e){this.initializeTokens(e);const t=await this.getEnabledTransitionsSpecific();this.emitTransitionsChanged({enabled:t})}async getEnabledTransitionsSpecific(){if(!this.petriNet)return[];const{places:e,transitions:t,arcs:r}=this.petriNet,i=[];for(const s of t)this.isTransitionEnabled(s,e,r)&&i.push(s.id);return i}isTransitionEnabled(e,t,r){const i=r.filter(s=>s.target===e.id&&s.source!==e.id);for(const s of i){const n=t.find(u=>u.id===s.source);if(!n)continue;const c=s.weight||1;if((n.tokens||0)<c)return!1}return!0}async fireTransitionSpecific(e,t={}){const{places:r,transitions:i,arcs:s}=this.petriNet,n=t.skipEnabledCheck||!1,c=n?[]:await this.getEnabledTransitionsSpecific();if(!i.find(l=>l.id===e))throw new Error(`Transition ${e} not found`);const u=JSON.parse(JSON.stringify(this.petriNet)),d=u.places,f=s.filter(l=>l.target===e&&l.source!==e),w=s.filter(l=>l.source===e&&l.target!==e),m=[];for(const l of f){const b=(l.weight||1)|0;for(let $=0;$<b;$++)m.push({srcId:l.source,countFallback:!0})}const h=Object.fromEntries(d.map(l=>[l.id,l]));Tt(m,h);const E=w.map(l=>({id:l.id,sourceId:l.source,targetId:l.target,weight:l.weight||1}));for(const l of E){const b=h[l.targetId];if(!b)continue;Array.isArray(b.valueTokens)&&delete b.valueTokens;const $=(l.weight||1)|0;b.tokens=Number(b.tokens||0)+$|0}for(const l of d)Array.isArray(l.valueTokens)?(l.tokens=Math.min(this.maxTokens,Array.isArray(l.valueTokens)?l.valueTokens.length:l.tokens||0),delete l.valueTokens):l.tokens=Math.min(this.maxTokens,l.tokens||0);if(this.petriNet=u,!n){this.emitTransitionFired({transitionId:e,newPetriNet:u});const l=await this.getEnabledTransitionsSpecific();this.emitTransitionsChanged({enabled:l,previouslyEnabled:c})}return u}async stepSimulationSpecific(){return this.petriNet}resetSpecific(){this.maxTokens=1/0}validatePTNet(e){const{transitions:t}=e;for(const r of t){if(r.guard&&typeof r.guard=="string"&&(r.guard.includes("+")||r.guard.includes("-")||r.guard.includes("*")||r.guard.includes("/")||r.guard.includes("=")||r.guard.includes("<")||r.guard.includes(">")||r.guard.includes("!=")))throw new Error("P/T simulator cannot handle algebraic expressions. Use algebraic simulator instead.");if(r.action&&typeof r.action=="string"&&(r.action.includes("+")||r.action.includes("-")||r.action.includes("*")||r.action.includes("/")||r.action.includes("=")))throw new Error("P/T simulator cannot handle algebraic expressions. Use algebraic simulator instead.")}}initializeTokens(e){const{places:t}=e;for(const r of t)(r.tokens===void 0||r.tokens===null)&&(r.tokens=0),r.tokens=Math.min(this.maxTokens,Math.max(0,r.tokens))}getSimulationStats(){if(!this.isInitialized)return{enabledTransitions:[],totalTokens:0,totalPlaces:0,totalTransitions:0};const{places:e,transitions:t}=this.petriNet,r=e.reduce((s,n)=>s+(n.tokens||0),0);return{enabledTransitions:this.getEnabledTransitionsSync(),totalTokens:r,totalPlaces:e.length,totalTransitions:t.length}}getEnabledTransitionsSync(){if(!this.petriNet)return[];const{places:e,transitions:t,arcs:r}=this.petriNet,i=[];for(const s of t)this.isTransitionEnabled(s,e,r)&&i.push(s.id);return i}}function U(a){if(typeof a!="string")throw new Error("Expression must be a string");const e=a.trim();let t=0;function r(l){return l>="0"&&l<="9"}function i(){for(;t<e.length&&/\s/.test(e[t]);)t++}function s(){i();let l=t;for(;t<e.length&&r(e[t]);)t++;if(l===t)throw new Error(`Expected int at position ${t}`);const b=e.slice(l,t);return{type:"int",value:parseInt(b,10)}}function n(l){return/[A-Za-z_]/.test(l)}function c(l){return/[A-Za-z0-9_]/.test(l)}function o(){if(i(),e[t]!=="'")throw new Error(`Expected string literal at position ${t}`);t++;let l="";for(;t<e.length&&e[t]!=="'";){if(e[t]==="\\"&&t+1<e.length){t++;const b=e[t];b==="n"?l+=`
`:b==="t"?l+="	":b==="r"?l+="\r":b==="\\"?l+="\\":b==="'"?l+="'":l+=b}else l+=e[t];t++}if(t>=e.length)throw new Error("Unterminated string literal");return t++,{type:"string",value:l}}function u(){i();let l=t;if(!n(e[t]))throw new Error(`Expected identifier at position ${t}`);for(t++;t<e.length&&c(e[t]);)t++;const b=e.slice(l,t);if(b&&/^[A-Z]/.test(b))throw new Error(`Variable names must start with lowercase letter, got '${b}' (use 't' instead of 'T', 'f' instead of 'F')`);if(i(),e[t]==="("){t++;const p=[];if(i(),e[t]!==")")do if(i(),p.push(m()),i(),e[t]===",")t++;else break;while(t<e.length);if(i(),e[t]!==")")throw new Error(`Expected ')' after function arguments at position ${t}`);return t++,{type:"funcall",name:b,args:p}}const $=t;if(i(),e[t]===":"){t++,i();const p=t;for(;t<e.length&&/[A-Za-z]/.test(e[t]);)t++;const y=e.slice(p,t).toLowerCase();return y==="int"||y==="bool"||y==="pair"||y==="string"||y==="list"?{type:"var",name:b,varType:y}:(t=$,{type:"var",name:b})}return{type:"var",name:b}}function d(){if(i(),e[t]!=="[")throw new Error(`Expected '[' at position ${t}`);t++;const l=[];if(i(),e[t]==="]")return t++,{type:"list",elements:[]};for(;t<e.length;){if(i(),l.push(m()),i(),e[t]==="]")return t++,{type:"list",elements:l};if(e[t]===","){t++;continue}throw new Error(`Expected ',' or ']' at position ${t}`)}throw new Error("Unterminated list literal")}function f(){if(i(),t>=e.length)throw new Error(`Unexpected end of input at position ${t}`);if(e[t]==="("){t++,i();const l=m();if(i(),e[t]===","){t++;const b=m();if(i(),t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,{type:"pair",fst:l,snd:b}}if(t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,l}if(e[t]==="[")return d();if(e[t]==="'")return o();if(r(e[t]))return s();if(/[A-Za-z_]/.test(e[t]))return u();throw new Error(`Unexpected character '${e[t]}' at position ${t}`)}function w(){let l=f();for(i();t<e.length&&(e[t]==="*"||e[t]==="/");){const b=e[t++],$=f();l={type:"binop",op:b,left:l,right:$},i()}return l}function m(){let l=w();for(i();t<e.length&&(e[t]==="+"||e[t]==="-");){const b=e[t++],$=w();l={type:"binop",op:b,left:l,right:$},i()}return l}let h=m();if(i(),t<e.length)throw new Error(`Unexpected character '${e[t]}' at position ${t}`);function E(l){return!l||typeof l!="object"||(l.type==="bin"&&(l.type="binop"),l.left&&(l.left=E(l.left)),l.right&&(l.right=E(l.right)),Array.isArray(l.args)&&(l.args=l.args.map(E)),Array.isArray(l.elements)&&(l.elements=l.elements.map(E))),l}return h=E(h),h}function $t(a){if(typeof a!="string")throw new Error("Pattern must be a string");const e=a.trim();let t=0;function r(){for(;t<e.length&&/\s/.test(e[t]);)t++}function i(){if(r(),t>=e.length)throw new Error(`Unexpected end of input at position ${t}`);if(e.slice(t,t+1)==="T")return t++,{type:"boolLit",value:!0};if(e.slice(t,t+1)==="F")return t++,{type:"boolLit",value:!1};if(e.slice(t,t+4)==="true")return t+=4,{type:"boolLit",value:!0};if(e.slice(t,t+5)==="false")return t+=5,{type:"boolLit",value:!1};if(/[0-9]/.test(e[t])){let n=t;for(;t<e.length&&/[0-9]/.test(e[t]);)t++;return{type:"int",value:parseInt(e.slice(n,t),10)}}if(e[t]==="["){t++,r();const n=[];for(;t<e.length&&e[t]!=="]";)n.push(i()),r(),e[t]===","&&(t++,r());if(t>=e.length||e[t]!=="]")throw new Error(`Expected ']' at position ${t}`);return t++,{type:"listPattern",elements:n}}if(/[a-zA-Z_]/.test(e[t])){let n=t;for(;t<e.length&&/[a-zA-Z0-9_]/.test(e[t]);)t++;const c=e.slice(n,t);if(r(),e[t]===":"){t++,r();let o=t;for(;t<e.length&&/[a-zA-Z]/.test(e[t]);)t++;const u=e.slice(o,t).toLowerCase();if(u==="int"||u==="bool"||u==="pair"||u==="string"||u==="list")return{type:"var",name:c,varType:u};throw new Error(`Unknown type '${u}' at position ${o}`)}return{type:"var",name:c}}if(e[t]==="("){t++,r();const n=[];for(;t<e.length&&e[t]!==")";)n.push(i()),r(),t<e.length&&e[t]===","&&(t++,r());if(t>=e.length||e[t]!==")")throw new Error(`Expected ')' at position ${t}`);return t++,n.length===2?{type:"pairPattern",fst:n[0],snd:n[1]}:{type:"tuplePattern",elements:n}}throw new Error(`Unexpected character '${e[t]}' at position ${t}`)}const s=i();if(r(),t<e.length)throw new Error(`Unexpected character '${e[t]}' at position ${t}`);return s}function st(a,e){const t=new Map;function r(s,n){switch(s.type){case"int":return!(typeof n!="number"||n!==s.value);case"boolLit":return!(typeof n!="boolean"||n!==s.value);case"var":if(s.varType){const c=s.varType;if(c==="int"&&typeof n!="number"||c==="bool"&&typeof n!="boolean"||c==="string"&&typeof n!="string"||c==="list"&&!Array.isArray(n)||c==="pair"&&(!n||typeof n!="object"||!n.__pair__))return!1}if(t.has(s.name)){if(t.get(s.name)!==n)return!1}else t.set(s.name,n);return!0;case"pairPattern":return!(!n||typeof n!="object"||!n.__pair__||!r(s.fst,n.fst)||!r(s.snd,n.snd));case"tuplePattern":if(!Array.isArray(n)||n.length!==s.elements.length)return!1;for(let c=0;c<s.elements.length;c++)if(!r(s.elements[c],n[c]))return!1;return!0;case"listPattern":if(!Array.isArray(n)||n.length!==s.elements.length)return!1;for(let c=0;c<s.elements.length;c++)if(!r(s.elements[c],n[c]))return!1;return!0;default:return!1}}return r(a,e)?Object.fromEntries(t):null}function at(a,e=20){if(!a)return[];if(Array.isArray(a.valueTokens))return a.valueTokens.slice(0,e);const t=Number(a.tokens||0);return Number.isFinite(t)&&t>0?Array.from({length:Math.min(t,e)},()=>1):[]}function Z(a,e){if(!a)return null;switch(a.type){case"pairLit":return{__pair__:!0,fst:Z(a.fst,e),snd:Z(a.snd,e)};case"list":return(a.elements||[]).map(t=>Z(t,e));case"pairPattern":return{__pair__:!0,fst:Z(a.fst,e),snd:Z(a.snd,e)};case"tuplePattern":return(a.elements||a.components||[]).map(t=>Z(t,e));case"listPattern":return(a.elements||[]).map(t=>Z(t,e));case"boolLit":return!!a.value;case"int":return a.value|0;case"var":case"boolVar":case"pairVar":return(e||{})[a.name];default:return null}}function Ct(a,e,t,r){var i;try{const s=(a.arcs||[]).filter(n=>n.sourceId===t&&(n.targetType==="place"||!n.targetType));for(const n of s){const c=((i=e==null?void 0:e.bindingAstsByArc)==null?void 0:i.get(n.id))||[];for(const o of c){const{ast:u}=o||{};if(u&&(u.type==="var"||u.type==="boolVar"||u.type==="pairVar")){const d=r?r[u.name]:void 0;if(d===void 0)continue;const f=u.varType;if(f==="int"&&typeof d!="number"||f==="bool"&&typeof d!="boolean"||f==="string"&&typeof d!="string"||f==="pair"&&!(d&&typeof d=="object"&&d.__pair__===!0)||f==="list"&&!Array.isArray(d))return!1}}}return!0}catch{return!1}}const Bt=["concat","substring","length","head","tail","append","sublist","isSublistOf","isSubstringOf","fst","snd"],Ot=new Set(Bt);function Lt(a,e,t,r){const i=new Map;for(const s of a.transitions||[])if(s.guard&&typeof s.guard=="string")try{const n=t(String(s.guard),e);i.set(s.id,n)}catch{try{const c=r(String(s.guard),e);i.set(s.id,c)}catch{}}return i}function Zt(a,e){if(!a)return!1;const t=a.length;for(let r=0;r<t;r+=1){const i=a[r];if(!/[A-Za-z_]/.test(i))continue;let s=r+1;for(;s<t&&/[A-Za-z0-9_]/.test(a[s]);)s+=1;const n=a.slice(r,s);if(e.has(n)){let c=s;for(;c<t&&/\s/.test(a[c]);)c+=1;if(c<t&&a[c]==="(")return!0}r=s-1}return!1}function Ft(a,e,t,r,i){const s=new Map;for(const n of a.arcs||[]){const c=n.id,o=Array.isArray(n.bindings)?n.bindings:n.binding?[n.binding]:[],u=[];for(const d of o){const f=String(d),w=f.trim(),m=Zt(w,i),h=p=>{if(!p||typeof p!="object")return!0;switch(p.type){case"funcall":return i.has(p.name)?(p.args||[]).every(h):!1;case"pair":return h(p.fst)&&h(p.snd);case"list":return(p.elements||[]).every(h);case"binop":return h(p.left)&&h(p.right);default:return!0}},E=()=>{let p=null;try{p=t(f)}catch{p=null}return!p||!h(p)?!1:(p.type==="var"&&p.varType==="bool"?u.push({kind:"bool",ast:{type:"boolVar",name:p.name,varType:"bool"}}):p.type==="var"&&p.varType==="pair"?u.push({kind:"pair",ast:{type:"pairVar",name:p.name,varType:"pair"}}):u.push({kind:"arith",ast:p}),!0)},l=()=>{try{const p=e(f);return u.push({kind:"pattern",ast:p}),!0}catch{return!1}};let b=!1;if(m?(b=E(),b||(b=l())):(b=l(),b||(b=E())),b)continue;const $=f==="T"?!0:f==="F"?!1:null;if($!==null){u.push({kind:"bool",ast:{type:"boolLit",value:$}});continue}try{u.push({kind:"bool",ast:r(f,t)});continue}catch{}}u.length&&s.set(c,u)}return s}function ot(a){return!!(a&&typeof a=="object"&&a.__pair__===!0&&"fst"in a&&"snd"in a)}async function ct({transition:a,inputArcs:e,placesById:t,bindingAstsByArc:r,guardAst:i,parseArithmetic:s,evaluateBooleanPredicate:n,matchPattern:c,getTokensForPlace:o,evaluateArithmeticWithBindings:u,evaluateBooleanWithBindings:d,evaluatePatternLiteral:f,maxTokensPerPlace:w=20}){const m=[],h=async(E,l)=>{if(E>=e.length){if(!i)return{env:l,picks:m};try{return d(i,l||{},s)?{env:l,picks:m}:null}catch{try{return await n(i,l||{},s)?{env:l,picks:m}:null}catch{return null}}}const b=e[E],$=b.id,p=b.sourceId||b.source,y=t[p],g=o(y,w),T=r.get($)||[],S=T.length||(b.weight?Math.max(1,b.weight|0):0);if(S===0)return h(E+1,l);if(g.length<S)return null;const _=new Array(g.length).fill(!1),I=async(A,P)=>{if(A>=S)return h(E+1,P);for(let M=0;M<g.length;M++){if(_[M])continue;_[M]=!0;const x=g[M];let z=!0,C=P;const W=T[A];if(W){const{kind:L,ast:k}=W;if(L==="pattern"){const N=c(k,x);if(N===null)z=!1;else{for(const[D,X]of Object.entries(N))if(C&&Object.prototype.hasOwnProperty.call(C,D)&&C[D]!==X){z=!1;break}z&&(C={...C||{},...N})}}else if(k&&(k.type==="var"||k.type==="boolVar"||k.type==="pairVar"))C&&Object.prototype.hasOwnProperty.call(C,k.name)&&C[k.name]!==x?z=!1:(typeof x=="boolean"&&k.varType&&k.varType!=="bool"&&(z=!1),typeof x=="number"&&k.varType&&k.varType!=="int"&&(z=!1),typeof x=="string"&&k.varType&&k.varType!=="string"&&(z=!1),Array.isArray(x)&&k.varType&&k.varType!=="list"&&(z=!1),ot(x)&&k.varType&&k.varType!=="pair"&&(z=!1),z&&(C={...C||{},[k.name]:x}));else if(L==="arith")try{const N=u(k,P||{});(typeof x!="number"||N!==(x|0))&&(z=!1)}catch{z=!1}else if(L==="bool")try{const N=d(k,P||{},s);(typeof x!="bool"||N!==x)&&(z=!1)}catch{z=!1}else if(L==="pair")try{if(k.type==="pairLit"){const N=f(k,P||{});(!ot(x)||JSON.stringify(N)!==JSON.stringify(x))&&(z=!1)}}catch{z=!1}}if(z){m.push({arcId:b.id,srcId:p,tokenIndex:M,value:x,countFallback:!Array.isArray(y==null?void 0:y.valueTokens)});const L=await I(A+1,C);if(L)return L;m.pop()}_[M]=!1}return null};return I(0,l||{})};return h(0,{})}function kt(a){const e=new Set;function t(r){if(r)switch(r.type){case"var":e.add(r.name);break;case"pairPattern":t(r.fst),t(r.snd);break;case"listPattern":Array.isArray(r.elements)&&r.elements.forEach(t);break;case"tuplePattern":r.elements&&r.elements.forEach(t);break}}return t(a),Array.from(e)}function Et(a){const e=new Set;function t(r){if(r)switch(r.type){case"var":case"boolVar":case"pairVar":e.add(r.name);break;case"binop":case"cmp":t(r.left),t(r.right);break;case"unop":t(r.operand);break;case"call":r.args&&r.args.forEach(t);break;case"pairPattern":t(r.fst),t(r.snd);break;case"tuplePattern":r.elements&&r.elements.forEach(t);break;case"pairLit":t(r.fst),t(r.snd);break}}return t(a),Array.from(e)}function Vt(a,e,t,r,i){const s=new Set;for(const o of i){const u=e.get(o.id)||[];for(const d of u){const{kind:f,ast:w}=d||{};f==="pattern"&&kt(w).forEach(h=>s.add(h))}}const n=t.get(r);if(n){const o=Et(n);for(const u of o)if(!s.has(u))return!0}const c=(a.arcs||[]).filter(o=>o.sourceId===r&&(o.targetType==="place"||!o.targetType));for(const o of c){const u=e.get(o.id)||[];if(u.length===0)return!0;for(const d of u){const{kind:f,ast:w}=d||{};if(f==="pattern"&&w.type==="var"&&!s.has(w.name))return!0}}return!1}function jt(a){const e=(a.places||[]).map(n=>({id:n.id,label:n.label||"",tokens:Number(Array.isArray(n.valueTokens)?n.valueTokens.length:n.tokens||0),x:Number(n.x||0),y:Number(n.y||0),name:n.name||"",type:"place",valueTokens:Array.isArray(n.valueTokens)?[...n.valueTokens]:void 0})),t=(a.transitions||[]).map(n=>({id:n.id,label:n.label||"",x:Number(n.x||0),y:Number(n.y||0),name:n.name||"",type:"transition",guard:n.guard,action:n.action})),r=new Set(e.map(n=>n.id)),i=new Set(t.map(n=>n.id)),s=(a.arcs||[]).map(n=>{const c=n.sourceId||n.source,o=n.targetId||n.target,u=r.has(c)?"place":i.has(c)?"transition":n.sourceType||"place",d=r.has(o)?"place":i.has(o)?"transition":n.targetType||"transition",f=n.type||`${u}-to-${d}`;return{id:n.id,sourceId:c,targetId:o,source:c,target:o,weight:Number(n.weight||1),sourceType:u,targetType:d,type:f,bindings:Array.isArray(n.bindings)?[...n.bindings]:n.binding?[n.binding]:[]}});return{places:e,transitions:t,arcs:s}}let Q=null;async function Ut(){if(typeof process<"u"&&process.env&&{}.JEST_WORKER_ID){v.debug("Jest worker detected, skipping Z3 asset fetch");return}if(typeof document>"u"){if(typeof globalThis.initZ3=="function")return;const e=globalThis.Module;try{const r=(()=>{try{const{origin:m,pathname:h}=self.location||{};if(!m)return"";if(typeof h=="string"){const E=h.indexOf("/assets/");if(E!==-1)return`${m}${h.slice(0,E+1)}`;const l=h.lastIndexOf("/"),b=l>=0?h.slice(0,l+1):"/";return`${m}${b}`}return`${m}/`}catch{return""}})(),i=m=>{const h=m.startsWith("/")?m.slice(1):m;return r?`${r}${h}`:`/${h}`},s=i("z3-built.wasm.base64");v.debug("[Z3 worker] fetching WASM base64 from",s);const n=await fetch(s);if(!n.ok)throw new Error(`Failed to fetch WASM base64 from ${s}: ${n.status}`);const o=`data:application/wasm;base64,${await n.text()}`,u={...typeof e=="object"?e:{},locateFile:m=>{if(m.endsWith(".wasm"))return v.debug("[Z3 worker] locateFile",m,"->",`${o.substring(0,50)}...`),o;const h=i(m);return v.debug("[Z3 worker] locateFile",m,"->",h),h}};globalThis.Module=u;const d=i("z3-built.js"),f=await fetch(d);if(!f.ok)throw new Error(`Failed to fetch z3-built.js from ${d}: ${f.status}`);const w=await f.text();if((0,eval)(w),await new Promise(m=>setTimeout(m,20)),typeof globalThis.initZ3!="function")throw new Error("initZ3 not defined after eval");return}catch(t){throw new Error(`Failed to load Z3 in worker: ${t.message}`)}finally{typeof e=="object"?globalThis.Module=e:delete globalThis.Module}}typeof globalThis.initZ3!="function"&&(v.debug("initZ3 not found, loading Z3 built assets..."),await new Promise((e,t)=>{const r=document.createElement("script");r.src="/z3-built.js",r.async=!0,r.addEventListener("load",()=>{typeof globalThis.initZ3=="function"?(v.debug("Z3 built assets loaded successfully"),e()):t(new Error("initZ3 function not found after loading z3-built.js"))}),r.addEventListener("error",i=>{t(new Error(`Failed to load z3-built.js: ${(i==null?void 0:i.message)||i}`))}),document.head.appendChild(r)}))}async function Wt(){return Q||(Q=(async()=>{try{v.debug("Initializing Z3 context..."),await Ut();const{init:a}=await import("./browser-56e37675.js").then(function(r){return r.b});if(!a)throw new Error("Z3 init function not found. Z3-solver package may not be properly installed.");v.debug("Calling Z3 init...");const e=await a();if(!e)throw new Error("Z3 initialization failed. Check browser console for WASM loading errors.");v.debug("Creating Z3 context...");const t=new e.Context("main");if(!t)throw new Error("Failed to create Z3 context.");return v.debug("Z3 context initialized successfully"),{z3:e,ctx:t}}catch(a){v.error("Z3 initialization error:",a);const e=typeof process<"u"&&process.env&&{}.JEST_WORKER_ID;if(typeof document<"u"&&!e){v.debug("Retrying Z3 initialization with asset loading...");try{typeof globalThis.initZ3!="function"&&(v.debug("initZ3 not found, loading Z3 built assets..."),await new Promise((s,n)=>{const c=document.createElement("script");c.src="/z3-built.js",c.async=!0,c.addEventListener("load",()=>{typeof globalThis.initZ3=="function"?(v.debug("Z3 built assets loaded successfully"),s()):n(new Error("initZ3 function not found after loading z3-built.js"))}),c.addEventListener("error",o=>{n(new Error(`Failed to load z3-built.js: ${(o==null?void 0:o.message)||o}`))}),document.head.appendChild(c)}));const{init:t}=await import("./browser-56e37675.js").then(function(s){return s.b}),r=await t(),i=new r.Context("main");return v.debug("Z3 context initialized successfully (fallback)"),{z3:r,ctx:i}}catch(t){v.error("Fallback Z3 initialization also failed:",t)}}if(e||typeof document>"u"){v.debug("Retrying Z3 initialization for Node.js...");try{const{init:t}=await import("./browser-56e37675.js").then(function(s){return s.b}),r=await t(),i=new r.Context("main");return v.debug("Z3 context initialized successfully (Node.js)"),{z3:r,ctx:i}}catch(t){v.error("Node.js Z3 initialization also failed:",t)}}throw new Error(`initZ3 was not imported correctly. Please consult documentation on how to load Z3 in browser. Details: ${a.message}`)}})()),Q}function O(a,e,t){var s;const{Int:r,String:i}=a;switch(e.type){case"int":return r.val(e.value);case"string":return i.val(e.value);case"pair":const n=O(a,e.fst,t),c=O(a,e.snd,t);return n.concat(i.val(",")).concat(c);case"var":return t(e.name);case"funcall":{if(e.name==="length"&&e.args&&e.args.length===1&&((s=e.args[0])==null?void 0:s.type)==="string")return r.val((e.args[0].value||"").length);if(e.name==="concat"&&e.args&&e.args.length===2){const o=O(a,e.args[0],t),u=O(a,e.args[1],t);return o.concat(u)}if(e.name==="substring"&&e.args&&e.args.length===3){const o=O(a,e.args[0],t),u=O(a,e.args[1],t),d=O(a,e.args[2],t);return o.substr(u,d)}if(e.name==="length"&&e.args&&e.args.length===1)return O(a,e.args[0],t).length();throw new Error(`Unknown function '${e.name}'`)}case"binop":{const o=O(a,e.left,t),u=O(a,e.right,t);switch(e.op){case"+":return o.add(u);case"-":return o.sub(u);case"*":return o.mul(u);case"/":return o.div(u);default:throw new Error(`Unknown operator '${e.op}'`)}}default:throw new Error(`Unknown AST node '${e.type}'`)}}function F(a,e){function t(r){if(r.type==="int")return r.value|0;if(r.type==="string")return r.value;if(r.type==="list")return(r.elements||[]).map(t);if(r.type==="pair")return{__pair__:!0,fst:t(r.fst),snd:t(r.snd)};if(r.type==="var"){const i=e==null?void 0:e[r.name];if(i===void 0)throw new Error(`Unbound variable '${r.name}'`);return i}if(r.type==="funcall"){if(r.name==="concat"&&r.args&&r.args.length===2){const i=t(r.args[0]),s=t(r.args[1]);if(typeof i=="string"&&typeof s=="string")return i+s;if(Array.isArray(i)&&Array.isArray(s))return[...i,...s];throw new Error("concat requires two strings or two lists")}if(r.name==="substring"&&r.args&&r.args.length===3){const i=t(r.args[0]),s=t(r.args[1]),n=t(r.args[2]);if(typeof i!="string"||typeof s!="number"||typeof n!="number")throw new Error("substring requires string, int, int");return i.substr(s,n)}if(r.name==="length"&&r.args&&r.args.length===1){const i=t(r.args[0]);if(typeof i=="string"||Array.isArray(i))return i.length;throw new Error("length requires string or list")}if(r.name==="isSubstringOf"&&r.args&&r.args.length===2){const i=t(r.args[0]),s=t(r.args[1]);if(typeof i!="string"||typeof s!="string")throw new Error("isSubstringOf requires two strings");return s.includes(i)}if(r.name==="head"&&r.args&&r.args.length===1){const i=t(r.args[0]);if(!Array.isArray(i)||i.length===0)throw new Error("head requires non-empty list");return i[0]}if(r.name==="tail"&&r.args&&r.args.length===1){const i=t(r.args[0]);if(!Array.isArray(i))throw new Error("tail requires list");return i.length===0?[]:i.slice(1)}if(r.name==="append"&&r.args&&r.args.length===2){const i=t(r.args[0]),s=t(r.args[1]);if(!Array.isArray(i))throw new Error("append requires list");return[...i,s]}if(r.name==="sublist"&&r.args&&r.args.length===3){const i=t(r.args[0]),s=t(r.args[1]),n=t(r.args[2]);if(!Array.isArray(i)||typeof s!="number"||typeof n!="number")throw new Error("sublist requires list, int, int");return i.slice(s,s+n)}if(r.name==="isSublistOf"&&r.args&&r.args.length===2){const i=t(r.args[0]),s=t(r.args[1]);if(!Array.isArray(i)||!Array.isArray(s))throw new Error("isSublistOf requires two lists");const n=i.length;if(n===0)return!0;for(let c=0;c<=s.length-n;c++){let o=!0;for(let u=0;u<n;u++)if(s[c+u]!==i[u]){o=!1;break}if(o)return!0}return!1}if(r.name==="fst"&&r.args&&r.args.length===1){const i=t(r.args[0]);if(!i||typeof i!="object"||i.__pair__!==!0)throw new Error("fst requires pair");return i.fst}if(r.name==="snd"&&r.args&&r.args.length===1){const i=t(r.args[0]);if(!i||typeof i!="object"||i.__pair__!==!0)throw new Error("snd requires pair");return i.snd}throw new Error(`Unknown function '${r.name}'`)}if(r.type==="binop"){const i=t(r.left),s=t(r.right);if(typeof i!="number"||typeof s!="number")throw new Error("Arithmetic operands must be numbers");switch(r.op){case"+":return i+s|0;case"-":return i-s|0;case"*":return i*s|0;case"/":if(s===0)throw new Error("Division by zero");return Math.trunc(i/s)|0;default:throw new Error(`Unknown operator '${r.op}'`)}}throw new Error(`Unknown node type '${r.type}'`)}return t(a)}function qt(a,e){if(typeof a!="string")throw new Error("Predicate must be a string");const t=a.trim(),r=[">=","<=","==","!=",">","<"];let i=0,s=-1,n=null;for(let f=0;f<t.length;f++){const w=t[f];if(w==="("?i++:w===")"&&(i=Math.max(0,i-1)),i!==0)continue;const m=t.slice(f,f+2);if(r.includes(m)){n=m,s=f;break}if(r.includes(w)){n=w,s=f;break}}if(!n||s<0)throw new Error("Predicate must contain a comparison operator");const c=t.slice(0,s).trim(),o=t.slice(s+n.length).trim(),u=e(c),d=e(o);return{type:"cmp",op:n,left:u,right:d}}function nt(a,e){if(typeof a!="string")throw new Error("Boolean expression must be a string");const t=a.trim();let r=0;const i=()=>{for(;r<t.length&&/\s/.test(t[r]);)r++},s=(y,g)=>(y===0||/[^A-Za-z0-9_]/.test(t[y-1]||""))&&(y+g===t.length||/[^A-Za-z0-9_]/.test(t[y+g]||"")),n=y=>(i(),t.slice(r,r+y.length).toLowerCase()===y&&s(r,y.length)),c=()=>{i();const y=r;if(!/[A-Za-z_]/.test(t[r]||""))throw new Error(`Expected identifier at position ${r}`);for(r++;r<t.length&&/[A-Za-z0-9_]/.test(t[r]);)r++;const g=t.slice(y,r);if(g&&/^[A-Z]/.test(g))throw new Error(`Variable names must start with lowercase letter, got '${g}'`);const T=r;if(i(),t[r]===":"){r++,i();const S=r;for(;r<t.length&&/[A-Za-z]/.test(t[r]);)r++;const _=t.slice(S,r).toLowerCase();return _==="int"||_==="bool"||_==="pair"?{name:g,varType:_}:(r=T,{name:g})}return{name:g}},o=y=>{const g=String(y||"").trim();if(/^true$/i.test(g)||g==="T")return{type:"boolLit",value:!0};if(/^false$/i.test(g)||g==="F")return{type:"boolLit",value:!1};if(/^-?\d+$/.test(g))return{type:"int",value:parseInt(g,10)};if(g.startsWith("(")&&g.endsWith(")")){const I=g.slice(1,-1).trim();let A=0,P=-1;for(let M=0;M<I.length;M++){const x=I[M];if(x==="(")A++;else if(x===")")A=Math.max(0,A-1);else if(x===","&&A===0){P=M;break}}if(P>=0){const M=I.slice(0,P).trim(),x=I.slice(P+1).trim();if(M.length&&x.length)return{type:"pairLit",fst:o(M),snd:o(x)}}}try{if(typeof e=="function")return e(g)}catch{}const T=g.match(/^([A-Za-z_][A-Za-z0-9_]*)(?::([A-Za-z]+))?$/);if(!T)throw new Error(`Unrecognized term '${g}'`);const S=T[1];if(S&&/^[A-Z]/.test(S))throw new Error(`Variable names must start with lowercase letter, got '${S}'`);const _=(T[2]||"").toLowerCase();return _==="bool"?{type:"boolVar",name:S,varType:"bool"}:_==="pair"?{type:"pairVar",name:S,varType:"pair"}:{type:"var",name:S}},u=()=>{if(i(),r>=t.length)throw new Error("Unexpected end");if(t[r]==="T"&&s(r,1))return r+=1,{type:"boolLit",value:!0};if(t[r]==="F"&&s(r,1))return r+=1,{type:"boolLit",value:!1};if(n("true"))return r+=4,{type:"boolLit",value:!0};if(n("false"))return r+=5,{type:"boolLit",value:!1};if(t.slice(r).startsWith("isSubstringOf")){if(r+=13,i(),t[r]!=="(")throw new Error("Expected '('");let A=r+1,P=1;for(r++;r<t.length&&P>0;r++){const k=t[r];k==="("?P++:k===")"&&P--}if(P!==0)throw new Error("Unterminated isSubstringOf arguments");const M=t.slice(A,r-1).trim();let x=0,z="";const C=[];for(let k=0;k<M.length;k++){const N=M[k];if(N==="("){x++,z+=N;continue}if(N===")"){x=Math.max(0,x-1),z+=N;continue}if(N===","&&x===0){C.push(z.trim()),z="";continue}z+=N}if(z.trim().length&&C.push(z.trim()),C.length!==2)throw new Error("isSubstringOf expects two arguments");const W=e(C[0]),L=e(C[1]);return{type:"boolFuncall",name:"isSubstringOf",args:[W,L]}}const y=[">=","<=","==","!=",">","<"];let g=0,T=-1,S=null;for(let A=r;A<t.length;A++){const P=t[A];if(P==="("?g++:P===")"&&(g=Math.max(0,g-1)),g!==0)continue;if(t.slice(A,A+3)==="<->"){A+=2;continue}if(t.slice(A,A+2)==="->"){A+=1;continue}const M=t.slice(A,A+2);if(y.includes(M)){S=M,T=A;break}if(y.includes(P)){S=P,T=A;break}}if(S&&T>=0){const A=t.slice(r,T).trim(),P=T+S.length;let M=t.length;g=0;const x=(k,N)=>(k===0||/[^A-Za-z0-9_]/.test(t[k-1]||""))&&(k+N===t.length||/[^A-Za-z0-9_]/.test(t[k+N]||"")),z=k=>{const N=t.slice(k),D=["&&","||","^","->","<->"],X=["and","or","xor","implies","iff"];for(const G of D)if(N.startsWith(G))return!0;for(const G of X)if(N.toLowerCase().startsWith(G)&&x(k,G.length))return!0;return!1};for(let k=P;k<t.length;k++){const N=t[k];if(N==="("){g++;continue}if(N===")"){if(g===0){M=k;break}g=Math.max(0,g-1);continue}if(g===0&&z(k)){M=k;break}}const C=t.slice(P,M).trim(),W=o(A),L=o(C);return r=M,{type:"cmp",op:S,left:W,right:L}}if(t[r]==="("){r++;const A=$();if(i(),t[r]!==")")throw new Error(`Expected ')' at ${r}`);return r++,A}const{name:_,varType:I}=c();return I?{type:"boolVar",name:_,varType:I}:{type:"boolVar",name:_}},d={not:["not"],and:["and"],xor:["xor"],or:["or"],implies:["implies"],iff:["iff"]},f={not:["!"],and:["&&"],xor:["^"],or:["||"],implies:["->"],iff:["<->"]},w=(y,g)=>{i();for(const T of y)if(t.slice(r,r+T.length)===T)return r+=T.length,!0;for(const T of g)if(t.slice(r,r+T.length).toLowerCase()===T&&s(r,T.length))return r+=T.length,!0;return!1},m=()=>(i(),w(f.not,d.not)?{type:"not",expr:m()}:u()),h=()=>{let y=m();for(;i(),w(f.and,d.and);){const g=m();y={type:"and",left:y,right:g}}return y},E=()=>{let y=h();for(;i(),w(f.xor,d.xor);){const g=h();y={type:"xor",left:y,right:g}}return y},l=()=>{let y=E();for(;i(),w(f.or,d.or);){const g=E();y={type:"or",left:y,right:g}}return y},b=()=>{let y=l();for(;i(),w(f.implies,d.implies);){const g=l();y={type:"implies",left:y,right:g}}return y},$=()=>{let y=b();for(;i(),w(f.iff,d.iff);){const g=b();y={type:"iff",left:y,right:g}}return y},p=$();if(i(),r!==t.length)throw new Error(`Unexpected token '${t[r]}' at position ${r}`);return p}function H(a,e,t){const r=n=>{if(typeof n=="boolean")return n;if(typeof n=="number")return n!==0;if(n&&typeof n=="object"&&n.__pair__)return!0;throw new Error("Non-bool binding in bool expression")},i=n=>{if(!n)throw new Error("Invalid term");if(n.type==="int"||n.type==="bin"||n.type==="var"){try{return F(n,e)}catch{}if(n.type==="var"&&typeof(e==null?void 0:e[n.name])<"u")return e[n.name]}return n.type==="boolLit"?!!n.value:n.type==="boolVar"?!!(e!=null&&e[n.name]):n.type==="pairVar"?e==null?void 0:e[n.name]:n.type==="pairLit"?{__pair__:!0,fst:i(n.fst),snd:i(n.snd)}:F(n,e)},s=n=>{switch(n.type){case"boolLit":return!!n.value;case"boolVar":return r(e==null?void 0:e[n.name]);case"boolFuncall":{if(n.name==="isSubstringOf"&&n.args&&n.args.length===2){const c=F(n.args[0],e||{}),o=F(n.args[1],e||{});if(typeof c!="string"||typeof o!="string")throw new Error("isSubstringOf requires two string arguments");return o.includes(c)}throw new Error(`Unknown boolean function '${n.name}'`)}case"not":return!s(n.expr);case"and":return s(n.left)&&s(n.right);case"or":return s(n.left)||s(n.right);case"xor":{const c=s(n.left),o=s(n.right);return c&&!o||!c&&o}case"implies":{const c=s(n.left),o=s(n.right);return!c||o}case"iff":{const c=s(n.left),o=s(n.right);return c===o}case"cmp":{const c=i(n.left),o=i(n.right),u=(d,f)=>d&&typeof d=="object"&&d.__pair__&&f&&typeof f=="object"&&f.__pair__?u(d.fst,f.fst)&&u(d.snd,f.snd):d===f;switch(n.op){case"==":return u(c,o);case"!=":return!u(c,o);case"<":return c<o;case"<=":return c<=o;case">":return c>o;case">=":return c>=o;default:return!1}}default:throw new Error(`Unknown bool AST node '${n.type}'`)}};return s(a)}async function Rt(a,e,t){const{ctx:r}=await Wt(),{Int:i,Bool:s,Solver:n,And:c,Not:o,Or:u}=r,d=typeof a=="string"?nt(a,t):a,f=new Set,w=new Set,m=p=>{if(p)switch(p.type){case"boolVar":w.add(p.name);break;case"and":case"or":m(p.left),m(p.right);break;case"not":m(p.expr);break;case"cmp":{const y=g=>{g&&(g.type==="var"&&f.add(g.name),g.type==="bin"&&(y(g.left),y(g.right)))};y(p.left),y(p.right);break}}};m(d);const h=new Map(Array.from(f).map(p=>[p,i.const(p)])),E=new Map(Array.from(w).map(p=>[p,s.const(p)])),l=p=>{switch(p.type){case"boolLit":return p.value?s.val(!0):s.val(!1);case"boolVar":return E.get(p.name);case"boolFuncall":{if(p.name==="isSubstringOf"&&p.args&&p.args.length===2)try{const y=F(p.args[0],e||{}),g=F(p.args[1],e||{});if(typeof y!="string"||typeof g!="string")throw new Error("isSubstringOf requires two string arguments");return g.includes(y)?s.val(!0):s.val(!1)}catch{try{const g=O(r,p.args[1],S=>h.get(S)),T=O(r,p.args[0],S=>h.get(S));return g.contains(T)}catch{return s.val(!1)}}throw new Error(`Unknown boolean function '${p.name}'`)}case"not":return o(l(p.expr));case"and":return c(l(p.left),l(p.right));case"or":return u(l(p.left),l(p.right));case"cmp":{const y=T=>T&&(T.type==="int"||T.type==="var"||T.type==="bin"||T.type==="binop");if(y(p.left)&&y(p.right)){const T=I=>{if(I.type==="int")return i.val(I.value);if(I.type==="var")return h.get(I.name);if(I.type==="bin"||I.type==="binop"){const A=T(I.left),P=T(I.right);switch(I.op){case"+":return A.add(P);case"-":return A.sub(P);case"*":return A.mul(P);case"/":return A.div(P);default:throw new Error("Unknown arithmetic operator")}}throw new Error("Unknown arithmetic AST in bool comparison")},S=T(p.left),_=T(p.right);switch(p.op){case"==":return S.eq(_);case"!=":return o(S.eq(_));case"<":return S.lt(_);case"<=":return S.le(_);case">":return S.gt(_);case">=":return S.ge(_);default:throw new Error(`Unsupported predicate operator '${p.op}'`)}}return H({type:"cmp",op:p.op,left:p.left,right:p.right},e||{})?s.val(!0):s.val(!1)}default:throw new Error(`Unknown bool AST node '${p.type}'`)}},b=new n;try{let p=1e4;try{typeof window<"u"&&window.__Z3_SETTINGS__&&typeof window.__Z3_SETTINGS__.solverTimeoutMs=="number"&&(p=window.__Z3_SETTINGS__.solverTimeoutMs|0)}catch{}b.set("timeout",p)}catch{}if(e&&typeof e=="object"){const p=[];for(const[y,g]of Object.entries(e))h.has(y)&&typeof g=="number"?p.push(h.get(y).eq(i.val(g|0))):E.has(y)&&typeof g=="boolean"&&p.push(E.get(y).eq(g?s.val(!0):s.val(!1)));p.length&&b.add(c(...p))}b.add(l(d));const $=await b.check();return String($)==="sat"}function Jt(a,e,t=U){if(!a||typeof a!="string")return{};const r={},i=a.split(",");for(const s of i){const n=s.indexOf("=");if(n===-1)continue;const c=s.slice(0,n).trim(),o=s.slice(n+1).trim();if(!c)continue;const u=t(o);r[c]=F(u,e)}return r}let V=[],Dt=1;const R=new Map;let lt=0,tt=null;const J=typeof Worker<"u",At=typeof SharedArrayBuffer<"u",B={poolSize:0,idleTimeoutMs:3e5,prewarmOnAlgebraicMode:!0,solverTimeoutMs:1e4};function Gt(){try{if(typeof globalThis<"u"){const a=globalThis;a.__Z3_SETTINGS__={...a.__Z3_SETTINGS__||{},...B}}}catch{}}function q(a){return Math.max(0,(Number.isFinite(a)?a:0)|0)}function ut(a={}){typeof a.poolSize=="number"&&(B.poolSize=q(a.poolSize)),typeof a.idleTimeoutMs=="number"&&(B.idleTimeoutMs=Math.max(1e3,a.idleTimeoutMs|0)),typeof a.prewarmOnAlgebraicMode=="boolean"&&(B.prewarmOnAlgebraicMode=a.prewarmOnAlgebraicMode),typeof a.solverTimeoutMs=="number"&&(B.solverTimeoutMs=Math.max(0,a.solverTimeoutMs|0)),Yt()}function vt(){if(!J)throw new Error("Z3 worker pool unavailable in this environment");if(!At)throw new Error("SharedArrayBuffer not available. COOP/COEP headers may not be set correctly.");const a=new Worker(new URL(""+new URL("z3.worker-1562d2b4.js",import.meta.url).href,self.location),{type:"module"});return a.onerror=e=>{console.error("Z3 worker error:",e)},a.onmessage=({data:e})=>{const{id:t,ok:r,result:i,error:s}=e||{},n=R.get(t);n&&(R.delete(t),r?n.resolve(i):n.reject(new Error(s)),_t())},a}function Yt(){if(Gt(),!J)return;const a=q(B.poolSize);for(;V.length<a;)V.push(vt());for(;V.length>a;){const e=V.pop();try{e.terminate()}catch{}}}function Kt(){if(!J)throw new Error("Z3 worker pool unavailable in this environment");if(q(B.poolSize)<=0)throw new Error("Z3 worker pool disabled");V.length===0&&V.push(vt());const e=V[lt%V.length];return lt++,e}function _t(){J&&(B.idleTimeoutMs<=0||(tt&&clearTimeout(tt),tt=setTimeout(()=>{const a=q(B.poolSize);for(;V.length>a;){const e=V.pop();try{e.terminate()}catch{}}},B.idleTimeoutMs)))}function Ht(a,...e){const t=Kt(),r=Dt++;return new Promise((i,s)=>{const n=setTimeout(()=>{R.delete(r),s(new Error(`Z3 worker operation "${a}" timed out after ${B.solverTimeoutMs}ms`))},B.solverTimeoutMs||1e4);R.set(r,{resolve:c=>{clearTimeout(n),i(c)},reject:c=>{clearTimeout(n),s(c)}});try{t.postMessage({id:r,op:a,args:e})}catch(c){clearTimeout(n),R.delete(r),s(c);return}_t()})}function ft(){return q(B.poolSize)}function ht(){return J&&At&&q(B.poolSize)>0}const pt=(a,e,t)=>Ht("evaluateBooleanPredicate",a,e),et=async(a,e,t)=>{try{if((typeof ht=="function"?ht():!1)&&typeof pt=="function")try{return await pt(a,e,t)}catch{}}catch{}return Rt(a,e,t)},gt=a=>JSON.parse(JSON.stringify(a||{places:[],transitions:[],arcs:[]})),Xt=(a,e)=>{const t=new Set,r=n=>{if(n)switch(n.type){case"boolVar":case"pairVar":t.add(n.name);break;case"and":case"or":r(n.left),r(n.right);break;case"not":r(n.expr);break;case"cmp":i(n.left),i(n.right);break}},i=n=>{n&&(n.type==="var"||n.type==="boolVar"||n.type==="pairVar"?t.add(n.name):n.type==="bin"?(i(n.left),i(n.right)):n.type==="pairLit"&&(i(n.fst),i(n.snd)))};r(a);const s=new Set(Object.keys(e||{}));return Array.from(t).filter(n=>!s.has(n))},dt=a=>{try{const e=Array.isArray(a==null?void 0:a.transitions)?a.transitions.slice():[],t=Array.isArray(a==null?void 0:a.arcs)?a.arcs.slice():[];e.sort((s,n)=>String(s.id).localeCompare(String(n.id))),t.sort((s,n)=>String(s.id).localeCompare(String(n.id)));const r=e.map(s=>`${s.id}|g:${String(s.guard||"")}|a:${String(s.action||"")}`).join(";"),i=t.map(s=>`${s.id}|b:${Array.isArray(s.bindings)?s.bindings.join(","):s.binding?String(s.binding):""}`).join(";");return`${r}||${i}`}catch{return String(Math.random())}};class Qt extends wt{constructor(){super(),this.lastEnabledTransitions=[],this.cache={guardAstByTransition:new Map,bindingAstsByArc:new Map},this._cacheSignature=null,this._config={maxTokensPerPlace:1/0},this._enabledCache=new Map}getType(){return"algebraic"}async initializeSpecific(e,t={}){this.lastEnabledTransitions=[],this._enabledCache.clear(),this._cacheSignature=null,this.petriNet=gt(e),t&&typeof t.maxTokensPerPlace=="number"&&t.maxTokensPerPlace>=0?this._config.maxTokensPerPlace=t.maxTokensPerPlace|0:this._config.maxTokensPerPlace=1/0,await this.buildCaches(),await this.checkTransitionStateChanges()}async buildCaches(){this.cache.guardAstByTransition.clear(),this.cache.bindingAstsByArc.clear(),this.cache.guardAstByTransition=Lt(this.petriNet,U,nt,qt),this.cache.bindingAstsByArc=Ft(this.petriNet,$t,U,nt,Ot),this._cacheSignature=dt(this.petriNet)}getStatus(){var e,t,r;return{isInitialized:this.isInitialized,hasPyodide:!1,hasSimulator:!0,hasPetriNet:!!this.petriNet,simulationMode:this.simulationMode,petriNetSize:this.petriNet?{places:((e=this.petriNet.places)==null?void 0:e.length)||0,transitions:((t=this.petriNet.transitions)==null?void 0:t.length)||0,arcs:((r=this.petriNet.arcs)==null?void 0:r.length)||0}:null}}async setSimulationMode(e){if(e==="single"||e==="maximal")this.simulationMode=e;else throw new Error("Mode must be 'single' or 'maximal'")}_outputBindingsTypeCompatible(e,t){return Ct(this.petriNet,this.cache,e,t)}_invalidateEnabledCache(e){if(!e||e.size===0)return;const t=this.petriNet.arcs||[];for(const r of t){const i=r.sourceId||r.source;if((r.type==="place-to-transition"||r.sourceType==="place")&&e.has(i)){const n=String(r.targetId||r.target);this._enabledCache.delete(n)}}}_clearEnabledCache(){this._enabledCache.clear()}async updateSpecific(e){const r=dt(e)!==this._cacheSignature;this.petriNet=gt(e),r&&await this.buildCaches(),this._clearEnabledCache(),await this.checkTransitionStateChanges()}async getEnabledTransitionsSpecific(){const e=Array.isArray(this.petriNet.transitions)?this.petriNet.transitions:[];if(e.length===0)return[];const t=[];for(let i=0;i<e.length;i++){const s=String(e[i].id);this._enabledCache.has(s)||t.push(e[i])}if(t.length>0){const i=typeof ft=="function"?Number(ft()||0):0,s=Math.max(1,Math.min(t.length,i>0?i:1));if(s<=1)for(const n of t)try{const c=await this.isTransitionEnabled(n.id);this._enabledCache.set(String(n.id),c)}catch{this._enabledCache.set(String(n.id),!1)}else{const n=new Array(t.length).fill(!1);let c=0;const o=async()=>{for(;;){const d=c++;if(d>=t.length)break;const f=t[d];try{const w=await this.isTransitionEnabled(f.id);n[d]=w}catch{}}},u=Array.from({length:s},()=>o());await Promise.all(u);for(let d=0;d<t.length;d++)this._enabledCache.set(String(t[d].id),n[d])}}const r=[];for(const i of e){const s=String(i.id);this._enabledCache.get(s)===!0&&r.push(s)}return r}async checkForUnboundVariables(e,t){return Vt(this.petriNet,this.cache.bindingAstsByArc,this.cache.guardAstByTransition,e,t)}extractVariablesFromPattern(e){return kt(e)}extractVariablesFromExpression(e){return Et(e)}async isTransitionEnabled(e){if(!this.isInitialized)return!1;const t=(this.petriNet.transitions||[]).find(o=>o.id===e);if(!t)return!1;const r=(this.petriNet.arcs||[]).filter(o=>(o.targetId===e||o.target===e)&&(o.sourceType==="place"||!o.sourceType));if(r.length===0)return!0;if(await this.checkForUnboundVariables(e,r))return v.debug("Transition disabled due to unbound variables:",e),!1;const s=this.cache.guardAstByTransition.get(e),n=Object.fromEntries((this.petriNet.places||[]).map(o=>[o.id,o])),c=await ct({transition:t,inputArcs:r,placesById:n,bindingAstsByArc:this.cache.bindingAstsByArc,guardAst:s,parseArithmetic:U,evaluateBooleanPredicate:et,matchPattern:st,getTokensForPlace:at,evaluateArithmeticWithBindings:F,evaluateBooleanWithBindings:H,evaluatePatternLiteral:Z,maxTokensPerPlace:this._config.maxTokensPerPlace});return c?this._outputBindingsTypeCompatible(e,c.env||{}):!1}async stepSimulationSpecific(){return this.getCurrentState()}async fireTransitionSpecific(e,t={}){const r=t.skipEnabledCheck||!1,i=r?[]:await this.getEnabledTransitionsSpecific(),s=(this.petriNet.transitions||[]).find(h=>h.id===e);if(!s)return this.getCurrentState();const n=(this.petriNet.arcs||[]).filter(h=>(h.targetId===e||h.target===e)&&(h.sourceType==="place"||!h.sourceType)),c=(this.petriNet.arcs||[]).filter(h=>(h.sourceId===e||h.source===e)&&(h.targetType==="place"||!h.targetType)),o=Object.fromEntries((this.petriNet.places||[]).map(h=>[h.id,h])),u=this.cache.guardAstByTransition.get(e),d=await ct({transition:s,inputArcs:n,placesById:o,bindingAstsByArc:this.cache.bindingAstsByArc,guardAst:u,parseArithmetic:U,evaluateBooleanPredicate:et,matchPattern:st,getTokensForPlace:at,evaluateArithmeticWithBindings:F,evaluateBooleanWithBindings:H,evaluatePatternLiteral:Z,maxTokensPerPlace:this._config.maxTokensPerPlace});if(!d)throw new Error(`Transition ${e} is not enabled`);let f=d.env||{};const w=d.picks||[];if(u&&Xt(u,f).length>0)try{if(!await et(u,f,U))throw new Error("Guard unsatisfied under any extension")}catch{}const m=new Set;for(const h of w)m.add(h.srcId);for(const h of c)m.add(h.targetId||h.target);if(Tt(w,o),xt(c,this.cache.bindingAstsByArc,f,o,{evaluateArithmeticWithBindings:F,evaluateBooleanWithBindings:H,evaluatePatternLiteral:Z,parseArithmetic:U}),s.action&&typeof s.action=="string")try{const h=Jt(s.action,f,U)}catch{}if(this._invalidateEnabledCache(m),!r){await this.checkTransitionStateChanges();const h=this.getCurrentState();this.emitTransitionFired({transitionId:e,newPetriNet:h});const E=await this.getEnabledTransitionsSpecific();return this.emitTransitionsChanged({enabled:E,previouslyEnabled:i}),h}return this.getCurrentState()}getCurrentState(){return jt(this.petriNet)}async checkTransitionStateChanges(){if(this.isInitialized)try{const e=await this.getEnabledTransitionsSpecific();if(JSON.stringify([...e].sort())!==JSON.stringify([...this.lastEnabledTransitions].sort())){const r=[...this.lastEnabledTransitions];this.lastEnabledTransitions=[...e],this.emitTransitionsChanged({enabled:e,previouslyEnabled:r})}}catch{}}resetSpecific(){this.lastEnabledTransitions=[],this.cache.guardAstByTransition.clear(),this.cache.bindingAstsByArc.clear(),this._cacheSignature=null,this._config.maxTokensPerPlace=1/0,this._clearEnabledCache()}}class te{static createSimulator(e){switch(e){case"pt":return new Mt;case"algebraic":return new Qt;default:throw new Error(`Unknown net mode: ${e}`)}}static getAvailableTypes(){return["pt","algebraic"]}static isSupported(e){return this.getAvailableTypes().includes(e)}}const yt=async()=>{try{await new Promise(a=>setTimeout(a,0))}catch{}try{typeof requestAnimationFrame<"u"&&await new Promise(a=>requestAnimationFrame(()=>a()))}catch{}},ee=a=>{const e=new Set;if(!a||!Array.isArray(a.transitions))return e;const t=Array.isArray(a.arcs)?a.arcs:[],r=Array.isArray(a.places)?a.places:[],i=new Set(r.map(s=>String(s.id)));for(const s of a.transitions){const n=String(s.id);let c=!1,o=!1;for(const u of t){const d=String(u.sourceId||u.source),f=String(u.targetId||u.target);if(f===n&&d!==n&&i.has(d)&&(c=!0),d===n&&f!==n&&i.has(f)&&(o=!0),c&&o)break}!c&&!o&&e.add(n)}return e},re=(a,e,t)=>{const r=new Map;for(const c of a)r.set(c,new Set);for(const c of e||[]){const o=c.targetId||c.target,u=c.sourceId||c.source;(c.type==="place-to-transition"||c.sourceType==="place")&&r.has(o)&&r.get(o).add(u)}const i=a.slice();for(let c=i.length-1;c>0;c--){const o=Math.random()*(c+1)|0,u=i[c];i[c]=i[o],i[o]=u}const s=new Set,n=[];for(const c of i){const o=r.get(c)||new Set;let u=!0;for(const d of o)if(s.has(d)){u=!1;break}if(u){n.push(c);for(const d of o)s.add(d);if(t>0&&n.length>=t)break}}return n},ne=(a=[])=>a.map(e=>{if(typeof e=="string")return e;if(e&&typeof e=="object"){if(e.id)return e.id;if(e.get)return e.get("id")}return String(e)}).filter(Boolean),ie=async({simulator:a,mode:e="single",maxSteps:t=1e5,timeBudgetMs:r=3e4,yieldEvery:i=100,onProgress:s,shouldCancel:n,batchMax:c=0,progressEveryMs:o=0,yieldEveryMs:u=0})=>{const d=typeof performance<"u"&&performance.now?()=>performance.now():()=>Date.now(),f=d();let w=0,m=f,h=f,E=-1;const l=g=>{if(!s)return;const T=g-f,S=o>0?Math.floor(T/o):0;if(S!==E){E=S;try{s({steps:w,elapsedMs:T})}catch{}}},b=ee(a.petriNet||{}),$=async()=>{const g=await a.getEnabledTransitions();return ne(g).filter(S=>!b.has(String(S)))},p=async()=>{if(n&&n())return!1;const g=d(),T=g-f;if(i>0&&w%i===0){const S=d();l(S),await yt();const _=d();return h=_,m=_,o>0&&l(_),!(r>0&&_-f>r||n&&n())}if(o>0&&g-m>=o&&(l(g),m=g),u>0&&g-h>=u){await yt();const S=d();if(h=S,o>0&&S-m>=o&&(l(S),m=S),r>0&&S-f>r||n&&n())return!1}return!(r>0&&T>r||n&&n())};let y=!0;for(;y&&w<t&&!(n&&n());){const g=await $();if(!g||g.length===0)break;if(e==="maximal"){const T=a.petriNet||{},S=c>0?c:Number.POSITIVE_INFINITY;let _=re(g,T.arcs||[],S);if(!_||_.length===0){const I=g[Math.floor(Math.random()*g.length)];_=I?[I]:[]}if(n&&n()){y=!1;break}await Promise.all(_.map(I=>a.fireTransition(I,{skipEnabledCheck:!0}))),w+=_.length,y=await p()}else{const T=g[Math.floor(Math.random()*g.length)];await a.fireTransition(T),w+=1,y=await p()}}if(s)try{s({steps:w,elapsedMs:d()-f})}catch{}return{petriNet:a.petriNet||null,steps:w}},mt=(a,e={})=>{v.debug("determineNetMode called with:",{petriNet:a,options:e});const t=(e==null?void 0:e.netMode)||(a==null?void 0:a.netMode);if(v.debug("Found netMode from options/petriNet:",t),t){const r=t==="algebraic-int"?"algebraic":t;return v.debug("Using configured netMode:",r),r}return v.debug("No configured netMode, detecting from content"),Pt(a)},Pt=a=>{const e=a||{},t=Array.isArray(e.transitions)?e.transitions:[],r=Array.isArray(e.arcs)?e.arcs:[],i=Array.isArray(e.places)?e.places:[];v.debug("Net mode detection:",{places:i,transitions:t,arcs:r});for(const s of t){if(typeof s.guard=="string"&&s.guard.trim().length>0)return v.debug("Found guard, using algebraic mode"),"algebraic";if(typeof s.action=="string"&&s.action.trim().length>0)return v.debug("Found action, using algebraic mode"),"algebraic"}for(const s of r){const n=Array.isArray(s.bindings)?s.bindings:s.binding?[s.binding]:[];if(v.debug("Checking arc bindings:",n),n.some(o=>typeof o=="string"&&(/:[ ]*(integer|boolean)/i.test(o)||o==="T"||o==="F"||/[+\-*/()]/.test(o))))return v.debug("Found algebraic binding, using algebraic mode"),"algebraic"}return i.some(s=>Array.isArray(s.valueTokens)&&s.valueTokens.length>0)?(v.debug("Found valueTokens, using algebraic mode"),"algebraic"):(v.debug("Using P/T mode"),"pt")};class bt{constructor(){this.currentSimulator=null,this._ready=!1,this.netMode=null,this.eventBus=null,this.pendingListeners=new Map}async initialize(e,t={}){try{v.debug("SimulatorCore.initialize called with:",{petriNet:e,options:t});const r=mt(e,t);return this.currentSimulator=te.createSimulator(r),this.netMode=r,this.eventBus&&this.currentSimulator.setEventBus(this.eventBus),await this.currentSimulator.initialize(e,t),this._ready=!0,this.setupPendingListeners(),v.debug(`Simulator initialized with ${r} simulator`),{success:!0,netMode:r,simulatorType:this.currentSimulator.getType()}}catch(r){throw console.error("Failed to initialize simulator:",r),this._ready=!1,this.currentSimulator=null,r}}async update(e){if(!this.currentSimulator)return{success:!0};try{return await this.currentSimulator.update(e),{success:!0}}catch(t){throw console.error("Failed to update simulator:",t),t}}async getEnabledTransitions(){if(!this.currentSimulator)return[];try{return await this.currentSimulator.getEnabledTransitions()}catch(e){return console.error("Failed to get enabled transitions:",e),[]}}async fireTransition(e){if(!this.currentSimulator)throw new Error("Simulator not initialized");try{return await this.currentSimulator.fireTransition(e)}catch(t){throw console.error(`Failed to fire transition ${e}:`,t),t}}async stepSimulation(){if(!this.currentSimulator)throw new Error("Simulator not initialized");try{const e=await this.currentSimulator.getEnabledTransitions();if(!e||e.length===0)return this.currentSimulator.petriNet||null;const t=e[Math.floor(Math.random()*e.length)],r=typeof t=="string"?t:t&&t.id?t.id:String(t);return await this.currentSimulator.fireTransition(r)}catch(e){throw console.error("Failed to step simulation:",e),e}}async runToCompletion({mode:e="single",maxSteps:t=1e5,timeBudgetMs:r=3e4,yieldEvery:i=100,onProgress:s,shouldCancel:n,batchMax:c=0,progressEveryMs:o=0,yieldEveryMs:u=0}={}){if(!this.currentSimulator)throw new Error("Simulator not initialized");const d=this.currentSimulator.eventBus||null;try{this.currentSimulator.setEventBus&&this.currentSimulator.setEventBus(null)}catch{}try{return this.currentSimulator.setSimulationMode&&(this.currentSimulator.simulationMode=e),await ie({simulator:this.currentSimulator,mode:e,maxSteps:t,timeBudgetMs:r,yieldEvery:i,onProgress:s,shouldCancel:n,batchMax:c,progressEveryMs:o,yieldEveryMs:u})}finally{try{this.currentSimulator.setEventBus&&this.currentSimulator.setEventBus(d)}catch{}}}reset(){this.currentSimulator&&this.currentSimulator.reset(),this.currentSimulator=null,this._ready=!1,this.netMode=null,this.pendingListeners.clear()}deactivateSimulation(){this._active=!1}activateSimulation(e=!1){if(!this.currentSimulator)throw new Error("Simulator not initialized");v.debug(`Simulation activated (continuous: ${e})`)}async isReady(){return this._ready&&this.currentSimulator&&this.currentSimulator.isReady()}getSimulatorStatus(){var e;return{isReady:this._ready,netMode:this.netMode,simulatorType:((e=this.currentSimulator)==null?void 0:e.getType())||"none",simulatorStatus:{simulator:this.currentSimulator}}}getSimulatorType(){var e;return((e=this.currentSimulator)==null?void 0:e.getType())||"none"}getSimulationMode(){var e;return((e=this.currentSimulator)==null?void 0:e.simulationMode)||"single"}setSimulationMode(e){this.currentSimulator&&(this.currentSimulator.simulationMode=e)}setEventBus(e){this.eventBus=e,this.currentSimulator&&this.currentSimulator.setEventBus(e)}__queueListener(e,t){this.pendingListeners.has(e)||this.pendingListeners.set(e,[]),this.pendingListeners.get(e).push(t)}setupPendingListeners(){if(!(!this.currentSimulator||!this.eventBus)){for(const[e,t]of this.pendingListeners)for(const r of t)this.eventBus.on(e,r);this.pendingListeners.clear()}}determineNetMode(e,t){return mt(e,t)}detectNetModeFromContent(e){return Pt(e)}}let j=null,K=!1;const se=async()=>{try{await new Promise(a=>setTimeout(a,0))}catch{}try{typeof requestAnimationFrame<"u"&&await new Promise(a=>requestAnimationFrame(()=>a()))}catch{}};self.onmessage=async a=>{var r;const{op:e,payload:t}=a.data||{};try{if(e==="prewarm"){const{z3:i}=t||{};if(i&&typeof i=="object")try{ut(i)}catch(s){console.error("Prewarm failed to set Z3 config:",s)}j||(j=new bt),postMessage({op:"prewarm:ok"});return}if(e==="cancel"){K=!0,postMessage({op:"cancel:ack"});return}if(e==="dispose"){j=null,K=!1,postMessage({op:"dispose:ok"});return}if(e==="start"){K=!1;const{elements:i,simOptions:s={},run:n={},z3:c={}}=t||{};try{ut(c||{})}catch(h){console.error("Failed to set Z3 worker config:",h)}j||(j=new bt),await j.initialize(i||{},{netMode:s.netMode||(i==null?void 0:i.netMode)});const o=()=>K===!0,u=()=>{},d=performance.now?performance.now():Date.now(),f=await j.runToCompletion({mode:n.mode||"single",maxSteps:n.maxSteps??2e5,timeBudgetMs:n.timeBudgetMs??0,yieldEvery:n.yieldEvery??5e3,progressEveryMs:n.progressEveryMs??0,yieldEveryMs:n.yieldEveryMs??0,batchMax:n.batchMax??0,onProgress:u,shouldCancel:o}),w=performance.now?performance.now():Date.now(),m=Math.round(w-d);postMessage({op:"done",payload:{canceled:o(),elements:(f==null?void 0:f.petriNet)||((r=j.currentSimulator)==null?void 0:r.petriNet)||null,stats:{elapsedMs:m,steps:(f==null?void 0:f.steps)||0}}});return}postMessage({op:"error",payload:{message:"unknown op"}})}catch(i){postMessage({op:"error",payload:{message:String((i==null?void 0:i.message)||i)}})}finally{await se()}};
//# sourceMappingURL=simulation.worker-04867299.js.map
