"""
XML Parser/Serializer for Petri Nets using lxml (Pyodide)
This module provides functions to convert between the Petri net editor's internal
JSON representation and standard PNML (Petri Net Markup Language) XML format.
"""
from lxml import etree

def json_to_pnml(petri_net_json):
    """
    Convert the Petri net editor's JSON representation to PNML XML string.
    
    Args:
        petri_net_json (dict): The Petri net in JSON format with places, transitions, and arcs
        
    Returns:
        str: PNML XML representation of the Petri net
    """
    # Create the PNML structure
    nsmap = {None: "http://www.pnml.org/version-2009/grammar/pnml"}
    pnml = etree.Element("pnml", nsmap=nsmap)
    
    # Create the net element
    net = etree.SubElement(pnml, "net", id="net1", type="http://www.pnml.org/version-2009/grammar/ptnet")
    
    # Add net name
    net_name = etree.SubElement(net, "name")
    net_name_text = etree.SubElement(net_name, "text")
    net_name_text.text = "Petri Net"
    
    # Create the page element
    page = etree.SubElement(net, "page", id="page1")
    
    # Process places
    for place in petri_net_json.get('places', []):
        place_id = place.get('id')
        place_elem = etree.SubElement(page, "place", id=place_id)
        
        # Add name
        name = etree.SubElement(place_elem, "name")
        text = etree.SubElement(name, "text")
        text.text = place.get('name', f"P{place_id}")
        
        # Add graphics (position)
        graphics = etree.SubElement(place_elem, "graphics")
        position = etree.SubElement(graphics, "position", x=str(place.get('x', 0)), y=str(place.get('y', 0)))
        
        # Add initial marking (tokens)
        if place.get('tokens', 0) > 0:
            marking = etree.SubElement(place_elem, "initialMarking")
            marking_text = etree.SubElement(marking, "text")
            marking_text.text = str(place.get('tokens', 0))
    
    # Process transitions
    for transition in petri_net_json.get('transitions', []):
        transition_id = transition.get('id')
        transition_elem = etree.SubElement(page, "transition", id=transition_id)
        
        # Add name
        name = etree.SubElement(transition_elem, "name")
        text = etree.SubElement(name, "text")
        text.text = transition.get('name', f"T{transition_id}")
        
        # Add graphics (position)
        graphics = etree.SubElement(transition_elem, "graphics")
        position = etree.SubElement(graphics, "position", x=str(transition.get('x', 0)), y=str(transition.get('y', 0)))
    
    # Process arcs
    for arc in petri_net_json.get('arcs', []):
        arc_id = arc.get('id')
        source_id = arc.get('source')
        target_id = arc.get('target')
        
        arc_elem = etree.SubElement(page, "arc", id=arc_id, source=source_id, target=target_id)
        
        # Add graphics with metadata for source and target directions
        graphics = etree.SubElement(arc_elem, "graphics")
        metadata = etree.SubElement(graphics, "metadata")
        
        source_direction = etree.SubElement(metadata, "sourceDirection")
        source_direction.text = arc.get('sourceDirection', 'north')
        
        target_direction = etree.SubElement(metadata, "targetDirection")
        target_direction.text = arc.get('targetDirection', 'south')
        
        # Add inscription (weight) if > 1
        if arc.get('weight', 1) > 1:
            inscription = etree.SubElement(arc_elem, "inscription")
            inscription_text = etree.SubElement(inscription, "text")
            inscription_text.text = str(arc.get('weight', 1))
    
    # Convert to string
    return etree.tostring(pnml, pretty_print=True, encoding='unicode')

def pnml_to_json(pnml_string):
    """
    Convert PNML XML string to the Petri net editor's JSON representation.
    
    Args:
        pnml_string (str): PNML XML representation of the Petri net
        
    Returns:
        dict: The Petri net in JSON format with places, transitions, and arcs
    """
    # Initialize the result structure
    result = {
        'places': [],
        'transitions': [],
        'arcs': []
    }
    
    try:
        # Parse the XML string
        parser = etree.XMLParser(remove_blank_text=True)
        root = etree.fromstring(pnml_string.encode('utf-8'), parser)
        
        # Print the root tag for debugging
        print(f"Root tag: {root.tag}")
        
        # Get the namespace map
        nsmap = root.nsmap.copy()  # Make a copy to avoid modifying the original
        print(f"Original namespace map: {nsmap}")
        
        # Handle default namespace
        if None in nsmap:
            default_ns = nsmap.pop(None)
            nsmap['pnml'] = default_ns
            print(f"Using default namespace as pnml: {default_ns}")
        
        # Add the standard PNML namespace if not present
        if 'pnml' not in nsmap:
            nsmap['pnml'] = "http://www.pnml.org/version-2009/grammar/pnml"
            print("Added standard PNML namespace")
        
        print(f"Modified namespace map: {nsmap}")
        
        # Try multiple approaches to find the net element
        net = None
        net_paths = [
            './/net',
            './/pnml:net',
            './net',
            './pnml:net',
            '/pnml:pnml/pnml:net',
            '/*/net',
            '/*/*'
        ]
        
        for path in net_paths:
            try:
                net_elements = root.xpath(path, namespaces=nsmap)
                if net_elements:
                    net = net_elements[0]
                    print(f"Found net element using path: {path}")
                    break
            except Exception as e:
                print(f"Error with XPath {path}: {str(e)}")
        
        # Fallback to find method if XPath didn't work
        if net is None:
            net = root.find('.//net') or root.find('.//pnml:net', namespaces=nsmap)
            if net is not None:
                print("Found net element using find method")
        
        # If still not found, try direct children
        if net is None and len(root) > 0:
            # Assume the first child is the net element
            net = root[0]
            print(f"Using first child as net element: {net.tag}")
        
        if net is None:
            print("No net element found in the PNML file")
            return result
        
        # Try multiple approaches to find the page element
        page = None
        page_paths = [
            './/page',
            './/pnml:page',
            './page',
            './pnml:page',
            '/pnml:pnml/pnml:net/pnml:page',
            '*/page',
            '*/*'
        ]
        
        for path in page_paths:
            try:
                page_elements = net.xpath(path, namespaces=nsmap)
                if page_elements:
                    page = page_elements[0]
                    print(f"Found page element using path: {path}")
                    break
            except Exception as e:
                print(f"Error with XPath {path}: {str(e)}")
        
        # Fallback to find method if XPath didn't work
        if page is None:
            page = net.find('.//page') or net.find('.//pnml:page', namespaces=nsmap)
            if page is not None:
                print("Found page element using find method")
        
        # If still not found, try direct children
        if page is None and len(net) > 0:
            # Look for a child with tag containing 'page'
            for child in net:
                if 'page' in child.tag.lower():
                    page = child
                    print(f"Found page element by tag name: {child.tag}")
                    break
        
        # If still not found, use the net element itself as the page
        if page is None:
            page = net
            print("Using net element as page")
        
        if page is None:
            print("No page element found in the PNML file")
            return result
        
        # Process places - try multiple approaches
        places_found = False
        
        # Try different XPath expressions to find places
        place_paths = [
            './/place',
            './/pnml:place',
            'place',
            'pnml:place',
            '*/place',
            '*/pnml:place'
        ]
        
        places = []
        for path in place_paths:
            try:
                found_places = page.xpath(path, namespaces=nsmap)
                if found_places:
                    places = found_places
                    places_found = True
                    print(f"Found {len(places)} places using path: {path}")
                    break
            except Exception as e:
                print(f"Error with XPath {path}: {str(e)}")
        
        if not places_found:
            # Try findall as a fallback
            places = page.findall('.//place') or page.findall('.//pnml:place', namespaces=nsmap)
            if places:
                places_found = True
                print(f"Found {len(places)} places using findall")
        
        if places_found:
            for place in places:
                try:
                    place_id = place.get('id')
                    print(f"Processing place with ID: {place_id}")
                    
                    # Get name - try multiple approaches
                    name = f"P{len(result['places']) + 1}"  # Default name
                    name_paths = [
                        './/name/text',
                        './/pnml:name/pnml:text',
                        './name/text',
                        './pnml:name/pnml:text',
                        './/text',
                        './/pnml:text'
                    ]
                    
                    for name_path in name_paths:
                        try:
                            name_element = place.find(name_path) or place.xpath(name_path, namespaces=nsmap)
                            if hasattr(name_element, 'text') and name_element.text:
                                name = name_element.text
                                break
                            elif isinstance(name_element, list) and len(name_element) > 0:
                                if hasattr(name_element[0], 'text') and name_element[0].text:
                                    name = name_element[0].text
                                    break
                        except:
                            continue
                    
                    # Get position - try multiple approaches
                    x, y = 0, 0  # Default position
                    position_paths = [
                        './/graphics/position',
                        './/pnml:graphics/pnml:position',
                        './graphics/position',
                        './pnml:graphics/pnml:position'
                    ]
                    
                    for position_path in position_paths:
                        try:
                            position = place.find(position_path) or place.xpath(position_path, namespaces=nsmap)
                            if hasattr(position, 'get'):
                                x = int(float(position.get('x'))) if position.get('x') is not None else 0
                                y = int(float(position.get('y'))) if position.get('y') is not None else 0
                                break
                            elif isinstance(position, list) and len(position) > 0:
                                if hasattr(position[0], 'get'):
                                    x = int(float(position[0].get('x'))) if position[0].get('x') is not None else 0
                                    y = int(float(position[0].get('y'))) if position[0].get('y') is not None else 0
                                    break
                        except Exception as e:
                            print(f"Error getting position: {str(e)}")
                            continue
                    
                    # Get initial marking (tokens)
                    tokens = 0  # Default tokens
                    marking_paths = [
                        './/initialMarking/text',
                        './/pnml:initialMarking/pnml:text',
                        './initialMarking/text',
                        './pnml:initialMarking/pnml:text'
                    ]
                    
                    for marking_path in marking_paths:
                        try:
                            marking_element = place.find(marking_path) or place.xpath(marking_path, namespaces=nsmap)
                            if hasattr(marking_element, 'text') and marking_element.text:
                                tokens = int(marking_element.text)
                                break
                            elif isinstance(marking_element, list) and len(marking_element) > 0:
                                if hasattr(marking_element[0], 'text') and marking_element[0].text:
                                    tokens = int(marking_element[0].text)
                                    break
                        except:
                            continue
                    
                    # Create the place object
                    place_obj = {
                        'id': place_id,
                        'name': name,
                        'x': x,
                        'y': y,
                        'tokens': tokens
                    }
                    
                    print(f"Adding place: {place_obj}")
                    result['places'].append(place_obj)
                except Exception as e:
                    print(f"Error processing place: {str(e)}")
        else:
            print("No places found in the PNML file")
        
        # Process transitions - try multiple approaches
        transitions_found = False
        
        # Try different XPath expressions to find transitions
        transition_paths = [
            './/transition',
            './/pnml:transition',
            'transition',
            'pnml:transition',
            '*/transition',
            '*/pnml:transition'
        ]
        
        transitions = []
        for path in transition_paths:
            try:
                found_transitions = page.xpath(path, namespaces=nsmap)
                if found_transitions:
                    transitions = found_transitions
                    transitions_found = True
                    print(f"Found {len(transitions)} transitions using path: {path}")
                    break
            except Exception as e:
                print(f"Error with XPath {path}: {str(e)}")
        
        if not transitions_found:
            # Try findall as a fallback
            transitions = page.findall('.//transition') or page.findall('.//pnml:transition', namespaces=nsmap)
            if transitions:
                transitions_found = True
                print(f"Found {len(transitions)} transitions using findall")
        
        if transitions_found:
            for transition in transitions:
                try:
                    transition_id = transition.get('id')
                    print(f"Processing transition with ID: {transition_id}")
                    
                    # Get name - try multiple approaches
                    name = f"T{len(result['transitions']) + 1}"  # Default name
                    name_paths = [
                        './/name/text',
                        './/pnml:name/pnml:text',
                        './name/text',
                        './pnml:name/pnml:text',
                        './/text',
                        './/pnml:text'
                    ]
                    
                    for name_path in name_paths:
                        try:
                            name_element = transition.find(name_path) or transition.xpath(name_path, namespaces=nsmap)
                            if hasattr(name_element, 'text') and name_element.text:
                                name = name_element.text
                                break
                            elif isinstance(name_element, list) and len(name_element) > 0:
                                if hasattr(name_element[0], 'text') and name_element[0].text:
                                    name = name_element[0].text
                                    break
                        except:
                            continue
                    
                    # Get position - try multiple approaches
                    x, y = 0, 0  # Default position
                    position_paths = [
                        './/graphics/position',
                        './/pnml:graphics/pnml:position',
                        './graphics/position',
                        './pnml:graphics/pnml:position'
                    ]
                    
                    for position_path in position_paths:
                        try:
                            position = transition.find(position_path) or transition.xpath(position_path, namespaces=nsmap)
                            if hasattr(position, 'get'):
                                x = int(float(position.get('x'))) if position.get('x') is not None else 0
                                y = int(float(position.get('y'))) if position.get('y') is not None else 0
                                break
                            elif isinstance(position, list) and len(position) > 0:
                                if hasattr(position[0], 'get'):
                                    x = int(float(position[0].get('x'))) if position[0].get('x') is not None else 0
                                    y = int(float(position[0].get('y'))) if position[0].get('y') is not None else 0
                                    break
                        except Exception as e:
                            print(f"Error getting position: {str(e)}")
                            continue
                    
                    # Create the transition object
                    transition_obj = {
                        'id': transition_id,
                        'name': name,
                        'x': x,
                        'y': y
                    }
                    
                    print(f"Adding transition: {transition_obj}")
                    result['transitions'].append(transition_obj)
                except Exception as e:
                    print(f"Error processing transition: {str(e)}")
        else:
            print("No transitions found in the PNML file")
        
        # Process arcs - try multiple approaches
        arcs_found = False
        
        # Try different XPath expressions to find arcs
        arc_paths = [
            './/arc',
            './/pnml:arc',
            'arc',
            'pnml:arc',
            '*/arc',
            '*/pnml:arc'
        ]
        
        arcs = []
        for path in arc_paths:
            try:
                found_arcs = page.xpath(path, namespaces=nsmap)
                if found_arcs:
                    arcs = found_arcs
                    arcs_found = True
                    print(f"Found {len(arcs)} arcs using path: {path}")
                    break
            except Exception as e:
                print(f"Error with XPath {path}: {str(e)}")
        
        if not arcs_found:
            # Try findall as a fallback
            arcs = page.findall('.//arc') or page.findall('.//pnml:arc', namespaces=nsmap)
            if arcs:
                arcs_found = True
                print(f"Found {len(arcs)} arcs using findall")
        
        if arcs_found:
            for arc in arcs:
                try:
                    arc_id = arc.get('id')
                    print(f"Processing arc with ID: {arc_id}")
                    
                    # Get source and target - try multiple approaches
                    source_id = arc.get('source')
                    target_id = arc.get('target')
                    
                    # If source or target not found as attributes, try to find them as child elements
                    if not source_id:
                        source_paths = [
                            './/source',
                            './/pnml:source',
                            './source',
                            './pnml:source'
                        ]
                        for source_path in source_paths:
                            try:
                                source_elem = arc.find(source_path) or arc.xpath(source_path, namespaces=nsmap)
                                if hasattr(source_elem, 'get'):
                                    source_id = source_elem.get('ref')
                                    if source_id:
                                        break
                                elif isinstance(source_elem, list) and len(source_elem) > 0:
                                    if hasattr(source_elem[0], 'get'):
                                        source_id = source_elem[0].get('ref')
                                        if source_id:
                                            break
                            except:
                                continue
                    
                    if not target_id:
                        target_paths = [
                            './/target',
                            './/pnml:target',
                            './target',
                            './pnml:target'
                        ]
                        for target_path in target_paths:
                            try:
                                target_elem = arc.find(target_path) or arc.xpath(target_path, namespaces=nsmap)
                                if hasattr(target_elem, 'get'):
                                    target_id = target_elem.get('ref')
                                    if target_id:
                                        break
                                elif isinstance(target_elem, list) and len(target_elem) > 0:
                                    if hasattr(target_elem[0], 'get'):
                                        target_id = target_elem[0].get('ref')
                                        if target_id:
                                            break
                            except:
                                continue
                    
                    # Skip arcs with missing source or target
                    if not source_id or not target_id:
                        print(f"Skipping arc {arc_id} due to missing source or target")
                        continue
                    
                    print(f"Arc {arc_id}: source={source_id}, target={target_id}")
                    
                    # Determine arc type (place->transition or transition->place)
                    source_is_place = any(p['id'] == source_id for p in result['places'])
                    target_is_place = any(p['id'] == target_id for p in result['places'])
                    
                    if source_is_place and not target_is_place:
                        arc_type = 'place-to-transition'
                    elif not source_is_place and target_is_place:
                        arc_type = 'transition-to-place'
                    else:
                        # If we can't determine the type based on existing places/transitions,
                        # try to infer from IDs (common naming conventions)
                        if source_id.lower().startswith('p') and target_id.lower().startswith('t'):
                            arc_type = 'place-to-transition'
                        elif source_id.lower().startswith('t') and target_id.lower().startswith('p'):
                            arc_type = 'transition-to-place'
                        else:
                            print(f"Skipping invalid arc {arc_id} (place->place or transition->transition)")
                            continue
                    
                    # Get weight (inscription)
                    weight = 1  # Default weight
                    inscription_paths = [
                        './/inscription/text',
                        './/pnml:inscription/pnml:text',
                        './inscription/text',
                        './pnml:inscription/pnml:text'
                    ]
                    
                    for inscription_path in inscription_paths:
                        try:
                            inscription_element = arc.find(inscription_path) or arc.xpath(inscription_path, namespaces=nsmap)
                            if hasattr(inscription_element, 'text') and inscription_element.text:
                                weight = int(inscription_element.text)
                                break
                            elif isinstance(inscription_element, list) and len(inscription_element) > 0:
                                if hasattr(inscription_element[0], 'text') and inscription_element[0].text:
                                    weight = int(inscription_element[0].text)
                                    break
                        except:
                            continue
                    
                    # Get source and target directions from metadata if available
                    source_direction = 'north'  # Default value
                    target_direction = 'south'  # Default value
                    
                    # Try multiple approaches to find the metadata
                    graphics = None
                    
                    # Try standard path
                    graphics = arc.find('.//graphics/metadata') or arc.find('.//pnml:graphics/pnml:metadata', namespaces=nsmap)
                    
                    # Try direct path if standard path fails
                    if graphics is None:
                        try:
                            graphics_elem = arc.find('.//graphics') or arc.find('.//pnml:graphics', namespaces=nsmap)
                            if graphics_elem is not None:
                                metadata_elems = graphics_elem.findall('./metadata') or graphics_elem.findall('./pnml:metadata', namespaces=nsmap)
                                if metadata_elems:
                                    graphics = metadata_elems[0]
                        except Exception as e:
                            print(f"Error finding metadata: {str(e)}")
                    
                    # Try xpath as a last resort
                    if graphics is None:
                        try:
                            metadata_paths = [
                                './/graphics/metadata',
                                './/pnml:graphics/pnml:metadata',
                                './/graphics//metadata',
                                './/pnml:graphics//pnml:metadata'
                            ]
                            for path in metadata_paths:
                                try:
                                    metadata_elems = arc.xpath(path, namespaces=nsmap)
                                    if metadata_elems:
                                        graphics = metadata_elems[0]
                                        break
                                except:
                                    continue
                        except Exception as e:
                            print(f"Error with xpath for metadata: {str(e)}")
                    
                    print(f"Graphics element found: {graphics is not None}")
                    
                    if graphics is not None:
                        # Try multiple approaches to find direction elements
                        direction_paths = [
                            ('.//sourceDirection', './/targetDirection'),
                            ('.//pnml:sourceDirection', './/pnml:targetDirection'),
                            ('./sourceDirection', './targetDirection'),
                            ('./pnml:sourceDirection', './pnml:targetDirection')
                        ]
                        
                        for source_path, target_path in direction_paths:
                            try:
                                source_dir_elem = graphics.find(source_path)
                                target_dir_elem = graphics.find(target_path)
                                
                                if source_dir_elem is not None and source_dir_elem.text:
                                    source_direction = source_dir_elem.text
                                    print(f"Found source direction: {source_direction}")
                                
                                if target_dir_elem is not None and target_dir_elem.text:
                                    target_direction = target_dir_elem.text
                                    print(f"Found target direction: {target_direction}")
                                
                                if source_dir_elem is not None or target_dir_elem is not None:
                                    break
                            except Exception as e:
                                print(f"Error finding directions with path {source_path}: {str(e)}")
                                continue
                    
                    arc_obj = {
                        'id': arc_id,
                        'source': source_id,
                        'target': target_id,
                        'type': arc_type,
                        'weight': weight,
                        'sourceDirection': source_direction,
                        'targetDirection': target_direction
                    }
                    
                    print(f"Adding arc: {arc_obj}")
                    result['arcs'].append(arc_obj)
                except Exception as e:
                    print(f"Error processing arc: {str(e)}")
        else:
            print("No arcs found in the PNML file")
        
        # Ensure the result has the expected structure
        if 'places' not in result:
            result['places'] = []
        if 'transitions' not in result:
            result['transitions'] = []
        if 'arcs' not in result:
            result['arcs'] = []
            
        print(f"Final result structure: places={len(result['places'])}, transitions={len(result['transitions'])}, arcs={len(result['arcs'])}")
        return result
    except Exception as e:
        print(f"Error in pnml_to_json: {str(e)}")
        # Instead of raising an error, return an empty result
        return result
