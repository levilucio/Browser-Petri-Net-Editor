import React, { useState } from 'react';
import { exportToPNML, importFromPNML } from '../utils/python/index';

const Toolbar = ({ mode, setMode, gridSnappingEnabled, toggleGridSnapping, canUndo, canRedo, onUndo, onRedo, elements, setElements, updateHistory }) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  
  // Function to handle saving the Petri net as PNML XML
  const handleSave = async () => {
    try {
      setIsLoading(true);
      setError(null);
      setSuccess(null);
      
      // Convert the Petri net to PNML
      const pnmlString = await exportToPNML(elements);
      
      // Create a blob and download link
      const blob = new Blob([pnmlString], { type: 'application/xml' });
      const url = URL.createObjectURL(blob);
      
      // Create a download link and trigger it
      const a = document.createElement('a');
      a.href = url;
      a.download = 'petri-net.pnml';
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Show success message
      setSuccess('Petri net saved successfully as PNML file.');
    } catch (error) {
      console.error('Error saving Petri net:', error);
      setError(`Error saving Petri net: ${error.message}`);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Function to handle loading a Petri net from PNML XML
  const handleLoad = () => {
    // Create a file input element
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.pnml,.xml';
    
    // Handle file selection
    fileInput.onchange = async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      
      try {
        setIsLoading(true);
        setError(null);
        setSuccess(null);
        
        // Read the file
        const fileContent = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = (e) => resolve(e.target.result);
          reader.onerror = reject;
          reader.readAsText(file);
        });
        
        // Validate that the file content is not empty
        if (!fileContent || fileContent.trim() === '') {
          throw new Error('The selected file is empty');
        }
        
        // Basic XML validation
        if (!fileContent.includes('<pnml') && !fileContent.includes('<PNML')) {
          throw new Error('The file does not appear to be a valid PNML file');
        }
        
        console.log('File content loaded, converting PNML to JSON...');
        
        // Convert the PNML to JSON with a timeout to prevent UI freezing
        const petriNetJsonPromise = importFromPNML(fileContent);
        
        // Set a timeout to detect if the operation is taking too long
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Operation timed out. The file may be too large or invalid.')), 10000);
        });
        
        // Race the promises to handle timeouts
        const petriNetJson = await Promise.race([petriNetJsonPromise, timeoutPromise]);
        
        console.log('PNML converted to JSON successfully:', petriNetJson);
        
        // Validate the result structure
        if (!petriNetJson || typeof petriNetJson !== 'object') {
          throw new Error('Invalid data structure in the imported file');
        }
        
        // Ensure the required arrays exist
        const safeJson = {
          places: Array.isArray(petriNetJson.places) ? petriNetJson.places : [],
          transitions: Array.isArray(petriNetJson.transitions) ? petriNetJson.transitions : [],
          arcs: Array.isArray(petriNetJson.arcs) ? petriNetJson.arcs : []
        };
        
        console.log('About to update Petri net state with:', safeJson);
        
        // Verify the structure of the imported data
        if (safeJson.places && safeJson.places.length > 0) {
          console.log('Places found:', safeJson.places.length);
          console.log('First place:', safeJson.places[0]);
        } else {
          console.warn('No places found in imported data');
        }
        
        if (safeJson.transitions && safeJson.transitions.length > 0) {
          console.log('Transitions found:', safeJson.transitions.length);
          console.log('First transition:', safeJson.transitions[0]);
        } else {
          console.warn('No transitions found in imported data');
        }
        
        if (safeJson.arcs && safeJson.arcs.length > 0) {
          console.log('Arcs found:', safeJson.arcs.length);
          console.log('First arc:', safeJson.arcs[0]);
        } else {
          console.warn('No arcs found in imported data');
        }
        
        // Update the Petri net state
        setElements(safeJson);
        
        // Verify the state was updated by exposing it to the window for debugging
        window.__DEBUG_LOADED_STATE__ = safeJson;
        
        // Add to history
        if (updateHistory) {
          console.log('Adding imported state to history');
          updateHistory(safeJson);
        } else {
          console.warn('updateHistory function not available');
        }
        
        // Show success message
        setSuccess(`Petri net loaded successfully with ${safeJson.places.length} places, ${safeJson.transitions.length} transitions, and ${safeJson.arcs.length} arcs.`);
      } catch (error) {
        console.error('Error loading Petri net:', error);
        setError(`Error loading Petri net: ${error.message}`);
        
        // Ensure the canvas is not left in an inconsistent state
        // by keeping the current state if there's an error
      } finally {
        setIsLoading(false);
      }
    };
    
    // Trigger the file input
    fileInput.click();
  };
  
  // Function to clear the canvas
  const handleClear = () => {
    const emptyState = {
      places: [],
      transitions: [],
      arcs: []
    };
    
    setElements(emptyState);
    
    // Add to history
    if (updateHistory) {
      updateHistory(emptyState);
    }
    
    // Show success message
    setSuccess('Canvas cleared successfully.');
  };
  
  // Styles for the separator
  const separatorStyle = {
    width: '1px',
    backgroundColor: '#d1d5db', // gray-300
    margin: '0 16px',
    height: '100%', // Full height
    alignSelf: 'stretch' // Stretch to fill container height
  };

  // Common button style
  const buttonStyle = (isSelected) => ({
    padding: '0.25rem 0.75rem',
    borderRadius: '0.25rem',
    backgroundColor: isSelected ? '#4338ca' : 'white', // indigo-700 or white
    color: isSelected ? 'white' : 'black',
    border: isSelected ? 'none' : '1px solid #d1d5db', // gray-300
    margin: '0 0.25rem' // Even spacing on both sides
  });

  // Style for messages
  const messageStyle = (isError) => ({
    padding: '0.5rem',
    marginTop: '0.5rem',
    borderRadius: '0.25rem',
    backgroundColor: isError ? '#fee2e2' : '#d1fae5', // red-100 or green-100
    color: isError ? '#b91c1c' : '#047857', // red-700 or green-700
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    fontSize: '0.875rem'
  });

  return (
    <div className="toolbar flex flex-col p-2 bg-gray-100 border-b border-gray-300" style={{ minHeight: '70px' }}>
      <div className="flex">
        {/* File Operations Group */}
        <div className="file-operations">
          <h3 className="text-sm font-semibold mb-1">File</h3>
          <div className="flex justify-between">
            <button 
              style={{ ...buttonStyle(false), opacity: isLoading ? 0.5 : 1 }}
              onClick={handleSave}
              disabled={isLoading}
              title="Save as PNML"
            >
              Save
            </button>
            <button 
              style={{ ...buttonStyle(false), opacity: isLoading ? 0.5 : 1 }}
              onClick={handleLoad}
              disabled={isLoading}
              title="Load PNML file"
            >
              Load
            </button>
            <button 
              style={{ ...buttonStyle(false) }}
              onClick={handleClear}
              title="Clear canvas"
            >
              Clear
            </button>
          </div>
        </div>
        
        {/* Visual separator */}
        <div style={separatorStyle}></div>
        
        {/* Editing Tools Group */}
        <div className="editing-tools">
          <h3 className="text-sm font-semibold mb-1">Editing</h3>
          <div className="flex items-center">
            {/* Grid Snapping Toggle */}
            <div className="flex items-center mr-4">
              <input
                type="checkbox"
                id="grid-snap-toggle"
                data-testid="grid-snap-toggle"
                checked={gridSnappingEnabled}
                onChange={toggleGridSnapping}
                className="mr-1"
              />
              <label htmlFor="grid-snap-toggle" className="text-sm">Snap to Grid</label>
            </div>
            <div className="flex justify-between">
              <button 
                style={{ ...buttonStyle(mode === 'select') }}
                data-testid="toolbar-select"
                onClick={() => setMode('select')}
              >
                Select
              </button>
              <button 
                style={buttonStyle(mode === 'place')}
                data-testid="toolbar-place"
                onClick={() => setMode('place')}
              >
                Place
              </button>
              <button 
                style={buttonStyle(mode === 'transition')}
                data-testid="toolbar-transition"
                onClick={() => setMode('transition')}
              >
                Transition
              </button>
              <button 
                style={buttonStyle(mode === 'arc')}
                data-testid="toolbar-arc"
                onClick={() => setMode('arc')}
              >
                Arc
              </button>
            </div>
          </div>
        </div>
        
        {/* Visual separator */}
        <div style={separatorStyle}></div>
        
        {/* Simulation Tools Group */}
        <div className="simulation-tools">
          <h3 className="text-sm font-semibold mb-1">Simulation</h3>
          <div className="flex justify-between">
            <button style={buttonStyle(false)}>
              Step-by-Step
            </button>
            <button style={buttonStyle(false)}>
              Quick Visual
            </button>
            <button style={buttonStyle(false)}>
              Non-Visual
            </button>
            <button style={buttonStyle(false)}>
              Stop
            </button>
          </div>
        </div>

        <div className="history-tools ml-auto">
          <h3 className="text-sm font-semibold mb-1">History</h3>
          <div className="flex justify-between">
            <button 
              style={{ ...buttonStyle(false), opacity: canUndo ? 1 : 0.5 }}
              onClick={onUndo}
              disabled={!canUndo}
              title="Undo (Ctrl+Z)"
            >
              Undo
            </button>
            <button 
              style={{ ...buttonStyle(false), opacity: canRedo ? 1 : 0.5 }}
              onClick={onRedo}
              disabled={!canRedo}
              title="Redo (Ctrl+Y)"
            >
              Redo
            </button>
          </div>
        </div>
      </div>
      
      {/* Messages */}
      {error && (
        <div style={messageStyle(true)}>
          {error}
          <button onClick={() => setError(null)} style={{ marginLeft: '0.5rem' }}>×</button>
        </div>
      )}
      {success && (
        <div style={messageStyle(false)}>
          {success}
          <button onClick={() => setSuccess(null)} style={{ marginLeft: '0.5rem' }}>×</button>
        </div>
      )}
    </div>
  );
};

export default Toolbar;
